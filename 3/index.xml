<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>手把手带你写一门编程语言 on Gen 的学习笔记</title><link>https://artisanbox.github.io/3/</link><description>Recent content in 手把手带你写一门编程语言 on Gen 的学习笔记</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Mar 2022 18:37:53 +0800</lastBuildDate><atom:link href="https://artisanbox.github.io/3/index.xml" rel="self" type="application/rss+xml"/><item><title>01｜实现一门超简单的语言最快需要多久？</title><link>https://artisanbox.github.io/3/3/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/3/</guid><description>你好，我是宫文学。
说到实现一门计算机语言，你肯定觉得这是一个庞大又复杂的工程，工作量巨大！
这个理解，我只能说部分正确。其实，有的时候，实现一门语言的速度也可以很快。比如，当年兰登·艾克（Brendan Eich）只花了10天时间就把JavaScript语言设计出来了。当然，语言跟其他软件一样，也需要不断迭代，至今JS的标准和实现仍在不停的演化。
如果我说，你也完全可以在这么短的时间内实现一门语言，甚至都不需要那么长时间，你一定会觉得我是在哗众取宠、标题党。
别急，我再补充说明一下，你马上就会认可我的说法了。这个让你一开始实现的版本，只是为了去探索计算机语言的原理，是高度简化的版本，并不要求马上能实用。你可以把它看做是一个原型系统，仅此而已，实现起来不会太复杂。
好吧，我知道你肯定还在心里打鼓：再简单的计算机语言，那也是一门语言呀，难度又能低到哪里去？
这样，先保留你的疑虑，我们进入今天的课程。今天我就要带你挑战，仅仅只用一节课时间，就实现一门超简洁的语言。我会暂时忽略很多的技术细节，带你抓住实现一门计算机语言的骨干部分，掌握其核心原理。在这节课中，你会快速获得两个技能：
如何通过编译器来理解某个程序； 如何解释执行这个程序。 这两个点，分别是编译时的核心和运行时的核心。理解了这两个知识点，你就大致理解计算机语言是如何工作的了！
我们的任务这节课，我们要让下面这个程序运行起来：
//一个函数的声明，这个函数很简单，只打印"Hello World!" function sayHello(){ println("Hello World!"); } //调用刚才声明的函数 sayHello(); 这个程序做了两件事：第一件是声明了一个函数，叫做sayHello；第二件事，就是调用sayHello()函数。运行这个程序的时候，我们期待它会输出“Hello World！”。
这个程序看上去还挺像那么回事的，但其实为降低难度，我们对JavaScript/TypeScript做了极度的简化：它只支持声明函数和调用函数，在我们的sayHello()函数里，它只能调用函数。你可以调用一个自己声明的函数，如foo，也可以调用语言内置的函数，如示例中的println()。
这还不够，为了进一步降低难度，我们的编译器是从一个数组里读取程序，而不是读一个文本文件。这个数组的每一个元素是一个单词，分别是function、sayHello、左括号、右括号等等，这些单词，我们叫它Token，它们是程序的最小构成单位。注意，最后一个Token比较特殊，它叫做EOF，有时会记做$，表示程序的结尾。
好了，现在任务清楚了，那我们开始第一步，解析这个程序。
解析这个程序解析，英文叫做Parse，是指读入程序，并形成一个计算机可以理解的数据结构的过程。能够完成解析工作的程序，就叫做解析器（Parser），它是编译器的组成部分之一。
那么，什么数据结构是计算机能够理解的呢？很简单，其实就是一棵树，这棵树叫做抽象语法树，英文缩写是AST（Abstract Syntax Tree）。针对我们的例子，这棵AST是下面的样子：
你仔细看一下这棵树，你会发现它跟我们程序想表达的思想是一样的：
根节点代表了整个程序； 根节点有两个子节点，分别代表一个函数声明和一个函数调用语句； 函数声明节点，又包含了两个子节点，一个是函数名称，一个是函数体； 函数体中又包含一个函数调用语句； 而函数调用语句呢，则是由函数名称和参数列表构成的； …… 通过这样自顶向下的层层分析，你会发现这棵树确实体现了我们原来的程序想表达的意思。其实，这就跟我们自己在阅读文章的时候是一样的，我们的大脑也是把段落分解成句子，再把句子分解成主语、谓语、宾语等一个个语法单元，最终形成一棵树型的结构，我们的大脑是能够理解这种树型结构的。
总结起来，解析器的工作，就是要读取一个Token串，然后把它转换成一棵AST。
好了，知道了解析的工作目标后，我们就来实现这个解析器吧！
可是，这怎么下手呢？
你可以琢磨一下，你的大脑是如何理解这些程序，并且把它们在不知不觉之间转化成一棵树的。我们假设，人类的大脑采用了一种自顶向下的分析方式，也就是把一个大的解析任务逐步分解成小的任务，落实到解析器的实现上也是如此。
首先，我们的目的是识别Token串的特征，并把它转换成AST。我们暂时忽略细节，假设我们能够成功地完成这个解析，那么把这个解析动作写成代码，就是：
prog = parseProg()； 我们再具体一点，看看实现parseProg()需要做什么事情。
parseProg()需要建立程序的子节点，也就是函数声明或者函数调用。我们规定一个程序可以有零到多个函数声明或函数调用。我们把这个语法规则用比较严谨的方法表达出来，是这样的：
prog = (functionDecl | functionCall)* ; 咦？这个表达方式看上去有点熟悉呀？这个式子的格式叫做EBNF格式（扩展巴科斯范式）。你可以看到，它的左边是一个语法成份的名称，右边说的是这个语法成份是由哪些子成分构成的。这样，整个式子就构成了一条语法规则。
不过，编译原理的教科书里，有时会用产生式的格式。EBNF格式和产生式是等价的，区别是产生式不允许使用？、*和+号，而是用递归来表示多个元素的重复，用ε来表示不生成任何字符串。如果我们把上述语法规则用产生式来表示的话，相当于下面四条：
prog -&amp;gt; statement prog prog -&amp;gt; ε statement -&amp;gt; functionDecl statement -&amp;gt; functionCall 你马上就能看出来，还是EBNF格式更简洁吧？</description></item><item><title>02｜词法分析：识别Token也可以很简单吗？</title><link>https://artisanbox.github.io/3/4/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/4/</guid><description>你好，我是宫文学。
上一节课，我们用了很简单的方法就实现了语法分析。但当时，我们省略了词法分析的任务，使用了一个Token的列表作为语法分析阶段的输入，而这个Token列表呢，就是词法分析的结果。
其实，编译器的第一项工作就是词法分析，也是你实现一门计算机语言的头一项基本功。今天，我们就来补补课，学习一下怎么实现词法分析功能，词法分析也就是把程序从字符串转换成Token串的过程。
词法分析难不难呢？我们来对比一下，语法分析的结果是一棵AST树，而词法分析的结果是一个列表。直观上看，列表就要比树结构简单一些，所以你大概会猜想到，词法分析应该会更简单一些。
那么，具体来说，词法分析要用什么算法呢？词法是不是也像语法一样有规则？词法规则又是如何表达的？这一节课，我会带着你实现一个词法分析器，来帮你掌握这些技能。
在这里，我有个好消息告诉你。你在上一节课学到的语法分析的技能，很多可以用在词法分析中，这会大大降低你的学习难度。好了，我们开始了。
词法分析的任务你已经知道，词法分析的任务就是把程序从字符串转变成Token串，那它该怎么实现呢？我们这里先不讲具体的算法，先来看看下面这张示意图，分析一下，我们人类的大脑是如何把这个字符串断成一个个Token的？
你可能首先会想到，借助字符串中的空白字符（包括空格、回车、换行），把这个字符串截成一段段的，每一段作为一个Token，行不行？
按照这个方法，function关键字可以被单独识别出来。但是你看，我们还有一些圆括号、花括号等等，这些符号跟前一个单词之间并没有空格或回车，我们怎么把它们断开呢？
OK，你可以说，凡是遇到圆括号、花括号、加号、减号、点号等这些符号，我们把它们单独作为Token识别出来就好了。比如，对于cat.weight这样的对象属性访问的场景，点符号就是一个单独的Token。
但是，你马上会发现这个规则仍然不能处理所有的情况，例如，对于一个浮点数的字面量“3.14”的情况，点符号是浮点数的一部分，不能作为单独的Token。我稍微解释一下，这里的字面量（Literal），是指写在程序中的常量值，包括整数值、浮点数值、字符串等。
此外，还有一些难处理的情况，比如像“==”、“+=”、“-=”、“- -”、“&amp;amp;&amp;amp;”这些由两个或两个以上字符构成的运算符，程序处理时是要跟“=”、“+”、“-”等区分开的。
再比如，在JavaScript/TypeScript中，十六进制的字面量用“0x”开头，里面有a到f的字母，比如0x1F4；八进制的字面量用“0”开头，后面跟0~7的数字；而二进制的字面量用“0b”开头，后面跟着0或1。
所以，你可以看到，做词法分析需要考虑的情况还挺多，不是用简单的一两个规则就能解决的，我们必须寻找一种系统性的解决方法。
在这里，为了让你对词法分析的任务有更全面的了解，我梳理了各种不同的处理工作，你可以看看下面这张表：
那么，如何用系统性的方法进行词法分析呢？
借助这节课一开头的提示，我们试一下能否用语法分析的方法来处理词法，也就是说像做语法分析一样，我们要先用一个规则来描述每个Token的词法，然后让程序基于词法规则来做处理。
词法规则同语法规则一样，我们可以用正则表达式来描述词法。在这里，标识符的规则是用字母开头，后面的字符可以是字母、数字或下划线，标识符的词法规则可以写成下面这样：
Identifier: [a-zA-Z_][a-zA-Z0-9_]* ; 实际上，JavaScript的标识符是允许使用合法的Unicode字符的，我们这里做了简化。
看上去，词法规则跟上一节学过的语法规则没什么不同嘛，只不过词法的构成要素是字符，而语法的构成要素是Token。
表面上是这样，其实这里还是有一点不同的。实际上，词法规则使用的是正则文法（Formal Grammar），而语法规则使用的是上下文无关文法（Context-free Gammar，CFG）。正则文法是上下文无关文法的一个子集，至于对这两者差别的深入分析，我们还是放到后面的课上，这里我们先专注于完成词法分析功能。
我们再写一下前面讨论过的浮点数字面量的词法规则，这里同样是精简的版本，省略了指数部分、二进制、八进制以及十六进制的内容：
DecimalLiteral: IntegerLiteral '.' [0-9]* | '.' [0-9]+ | IntegerLiteral ; IntegerLiteral: '0' | [1-9] [0-9]* ; 对于上面这个DecimalLiteral词法规则，我们总结一下有这几个特点：
一个合法的浮点数可以是好几种格式，3.14、.14、3等等都行； 整数部分要么只有一个0，要么是1~9开头的数字； 可以没有小数点前的整数部分，但这时候小数点后至少要有一位数字，否则这就只剩了一个点号了； 也可以完全没有小数部分，只有整数部分。 好了，目前我们已经知道如何用词法规则来描述不同的Token了。接下来，我们要做的就是用程序实现这些词法规则，然后生成Token。
用程序实现词法分析上节课我们在讲语法分析的时候，提到了递归下降算法。这个算法比较让人喜欢的一点是，程序结构基本上就是对语法规则的一对一翻译。
其实词法分析程序也是一样的，比如我们要识别一个浮点数，我们照样可以根据上述DecimalLiteral的几条规则一条条地匹配过去。
首先，我们匹配第一条规则，就是既有整数部分又有小数部分的情况；如果匹配不上，就尝试第二条规则，也就是以小数点开头的情况；如果还匹配不上，就尝试第三条，即只有整数部分的情况。只要这三条匹配里有一条成功，就意味着我们匹配浮点数成功。
我们来看看具体的程序实现：
if (this.isDigit(ch)){ this.stream.next(); let ch1 = this.stream.peek(); let literal:string = ''; //首先解析整数部分 if(ch == '0'){//暂不支持八进制、二进制、十六进制 if (!</description></item><item><title>03｜支持表达式：解析表达式和解析语句有什么不同？</title><link>https://artisanbox.github.io/3/5/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/5/</guid><description>你好，我是宫文学。
到目前为止，我们已经学习了一些语法分析的算法。不过，我们主要是分析了如何来解析语句，比如函数声明、函数调用，没有把重点放在解析表达式上。
其实我是刻意为之的，故意把表达式的解析往后推迟一下。原因是表达式解析，特别是像“2+3*5”这样的看似特别简单的二元运算的表达式解析，涉及的语法分析技术反而是比较复杂的。所以，从循序渐进的角度来说，我们要把它们放在后面。
表达式的解析复杂在哪里呢？是这样，我们在解析二元表达式的时候，会遇到递归下降算法最大的短板，也就是不支持左递归的文法。如果遇到左递归的文法，会出现无限循环的情况。
在这一节里，我会给你分析这种左递归的困境，借此加深你对递归下降算法运算过程的理解。
同时，我也要给出避免左递归问题的方法。这里，我没有采用教科书上经常推荐的改写文法的方法，而是使用了业界实际编译器中更常用的算法：运算符优先级解析器（Operator-precedence parser）。JDK的Java编译器、V8的JaveScript编译器和Go语言的GC编译器，都毫无例外地采用了这个算法，所以这个算法非常值得我们掌握。
好了，那我们首先来了解一下用递归下降算法解析算术表达式会出现的这个左递归问题。
左递归问题我们先给出一种简化的加法表达式的语法规则：
add : add '+' IntLiteral | IntLiteral ; 对这个规则的解读是这样的：一个加法表达式，它要么是一个整型字面量，要么是另一个加法表达式再加上一个整型字面量。在这个规则下，2、2+3、2+3+4都是合格的加法表达式。
那如果用递归下降算法去解析2+3，我们会采用“add ‘+’ IntLiteral”的规则。而这个规则呢，又要求匹配出一个add来，从而算法又会递归地再次调用“add ‘+’ IntLiteral”规则，导致无限递归下去。
2+3是不是一个add表达式？ -&amp;gt;先匹配出一个add表达式来，再是+号，再是整型字面量 -&amp;gt;先匹配出一个add表达式来，再是+号，再是整型字面量 -&amp;gt;先匹配出一个add表达式来，再是+号，再是整型字面量 -&amp;gt;无限递归... 这就是著名的左递归问题，是递归下降算法或者LL算法都无法解决的。
你可能会问，如果把产生式的写法换一下，把add放在后面，不就会避免左递归了吗？
add : IntLiteral '+' add | IntLiteral ; 这个也是不行的，因为这样会导致运算的结合性出错。如果执意按照这个语法解析，解析2+3+4这个表达式所形成的AST会是右结合的：
你会看到，基于使用右递归文法生成的AST，实际是先计算3+4，再跟2相加。这违背了加法运算的结合性的规定。正确的运算顺序，应该是先计算2+3，然后再加上4，是左结合，对应的AST应该是右边的那个。这种结合性的错误，看上去对于加法影响不大，但如果换成减法或者除法，那计算结果就完全错误了。
好了，现在你已经理解了左递归问题了。那我们要如何解决这个问题呢？一个可行的解决方法就是改写文法，并且要在解析算法上做一些特殊的处理，你可以参考《编译原理之美》课程04讲。除了改写文法的方法以外，还有一些研究者提出了其他一些算法，也能解决左递归问题。
不过，针对二元表达式的解析，今天我要采用的是被实际编译器广泛采用的运算符优先级算法。
运算符优先级算法这是个怎么样的算法呢？我想先用简单的方式帮你理解运算符优先级算法的原理，然后再一步步深化。
在01讲介绍递归下降算法的时候，我提到，它对应的是人类的一种思维方式，也就是从顶向下逐步分解。但人类还有另一种思维方式：自底向上逐步归纳。而运算符优先级算法，对应的就是自底向上的一种思维方式。
首先我们来看2+3+4这个表达式，如果我们用自底向上归纳的思路做语法分析是怎么样一个思考过程呢？
第1步，首先看到2。你心里想，这里有一个整数了，那它是不是一个算术表达式的组成部分呀？是一个加法表达式的，还是乘法表达式的一部分呢？我们再往下看一看就知道。
第2步，看到一个+号。噢，你说，原来是一个加法表达式呀。这时候，我们知道，2肯定是要参与加法运算的，所以是加法的左子树。但加法后面可以跟很多东西的，比如另一个整数，或者是一个乘法表达式什么的，都有可能。那我们继续向下看。
第3步，看到整数3。奥，你心里想，原来是2+3呀。那我现在根据这三个Token是不是可以先凑出一棵AST的子树来呢？先等一等，我们现在还不知道3后面跟的是什么。
如果3后面跟的是+号或者-号，那没问题，3是先参与前面这个+号的计算，再把2+3的结果一起，去参与后面的计算的。
但如果3后面遇到的是 * 号呢？那么3就要先参与乘法运算，计算完的才参与前面的加法的。这两个不同的计算顺序，导致AST的结构是不一样的，而影响AST结构的，其实就是3前后的两个运算符的优先级。
第4步，看到第2个+号。这个时候，你心里知道了，原来3后面的运算符的优先级跟前面的是一样的呀，那么按照结合性的规定，应该先算前面的加法，再算后面的加法，所以3应该跟前面的2和+号一起凑成一个AST子树。并且，这棵子树会作为一个稳定的单元，参与后面的AST的构建。
第5步，看到整数4。现在的情况跟第3步是一样的，我们不知道4后面跟着的是什么。如果4后面跟着一个 * 号，那么4还要先参与后面的计算，然后再跟前面这一堆做加法。如果4后面也是一个加法运算符，那4就要先参与前面的计算，4在AST中的位置也就会变得确定。
第6步，再往下看，发现后面的Token既不是+号，也不是 * 号，而是EOF，也就是Token串的结尾。这样的话，整个AST就可以确定下来了。
好了，这是一个比较简单的算法运行的场景。你可以多读几遍，借此找找自底向上分析的直观感觉。
接下来，我们再换一个任务，分析一下2+3*5。你会发现，跟前一个例子相比，一直到第5步的时候，也就是读入了5以后，仍然没有形成一棵稳定的AST子树：
这是为什么呢？
因为根据5后面读入的Token的不同，形成的AST的结构会有很大的区别。这里我们展示3种情形：
情形1，第6个Token是+号：它的优先级不高于最后一个运算符 * 号，所以3 * 5这棵子树的结构就是确定的；进一步看，它也不高于第一个运算符的优先级，所以整个2+3 * 5这棵子树的结构都可以确定下来，并且肯定是最后一个+号的左子树。</description></item><item><title>04｜如何让我们的语言支持变量和类型？</title><link>https://artisanbox.github.io/3/6/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/6/</guid><description>你好，我是宫文学。
到目前为止，我们的语言已经能够处理语句，也能够处理表达式，并且都能够解释执行了。不过，我们目前程序能够处理的数据，还都只是字面量而已。接下来，我们要增加一个重要的能力：支持变量。
在程序中声明变量、对变量赋值、基于变量进行计算，是计算机语言的基本功能。只有支持了变量，我们才能实现那些更加强大的功能，比如，你可以用程序写一个计算物体下落的速度和位置，如何随时间变化的公式。这里的时间就是变量，通过给时间变量赋予不同的值，我们可以知道任意时间的物体速度和位置。
这一节，我就带你让我们手头上的语言能够支持变量。在这个过程中，你还会掌握语义分析的更多技能，比如类型处理等。
好了，我们已经知道了这一节的任务。那么第一步要做什么呢？你可以想到，我们首先要了解与处理变量声明和初始化有关的语法规则。
与变量有关的语法分析功能在TypeScript中，我们在声明变量的时候，可以指定类型，这样有助于在编译期做类型检查：
let myAge : number = 18; 如果编译成JavaScript，那么类型信息就会被抹掉：
var myAge = 18; 不过，因为我们的目标是教给你做类型分析的方法，以后还要静态编译成二进制的机器码，所以我们选择的是TypeScript的语法。
此外，在上面的例子中，变量在声明的时候就已经做了初始化。你还可以把这个过程拆成两步。第一步的时候，只是声明变量，之后再给它赋值：
let myAge : number; myAge = 18; 知道了如何声明变量以后，你就可以试着写出相关的语法规则。我这里给出一个示范的版本：
variableDecl : 'let' Identifier typeAnnotation？ ('=' singleExpression)?; typeAnnotation : ':' typeName; 学完了前面3节课，我相信你现在应该对阅读语法规则越来越熟悉了。接下来，就要修改我们的语法分析程序，让它能够处理变量声明语句。这里有什么关键点呢？
这里你要注意的是，我们采用的语法分析的算法是LL算法。而在02讲中，我们知道LL算法的关键是计算First和Follow集合。
首先是First集合。在变量声明语句的上一级语法规则（也就是statement）中，要通过First集合中的不同元素，准确地确定应该采用哪一条语法规则。由于变量声明语句是用let开头的，这就使它非常容易辨别。只要预读的Token是let，那就按照变量声明的语法规则来做解析就对了。
接下来是Follow集合。在上面的语法规则中你能看出，变量的类型注解和初始化部分都是可选的，它们都使用了?号。
由于类型注解是可选的，那么解析器在处理了变量名称后，就要看一下后面的Token是什么。如果是冒号，由于冒号是在typeAnnotation的First集合中，那就去解析一个类型注解；如果这个Token不是冒号，而是typeAnnotation的Follow集合中的元素，就说明当前语句里没有typeAnnotation，所以可以直接略过。
那typeAnnotation的Follow集合有哪些元素呢？我就不直说了，你自己来分析一下吧。
再往后，由于变量的初始化部分也是可选的，还要计算一下它的Follow集合。你能看出，这个Follow集合只有;号这一个元素。所以，在解析到变量声明部分的时候，我们可以通过预读准确地判断接下来该采取什么动作：
如果预读的Token是=号，那就是继续做变量初始化部分的解析； 如果预读的Token是;号，那就证明该语句没有变量初始化部分，因此可以结束变量声明语句的解析了； 如果读到的是=号和;号之外的任何Token呢，那就触发语法错误了。 相关的实现很简单，你参考一下这个示例代码：
let t1 = this.scanner.peek(); //可选的类型标注 if (t1.text == ':'){ this.scanner.next(); t1 = this.scanner.peek(); if (t1.kind == TokenKind.Identifier){ this.scanner.next(); varType = t1.</description></item><item><title>05｜函数实现：是时候让我们的语言支持函数和返回值了</title><link>https://artisanbox.github.io/3/7/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/7/</guid><description>你好，我是宫文学。
不知道你还记不记得，我们在第一节课就支持了函数功能。不过那个版本的函数功能是被高度简化了的，比如，它不支持声明函数的参数，也不支持函数的返回值。
在上一节课实现了对变量的支持以后，我们终于可以进一步升级我们的函数功能了。为什么要等到这个时候呢？因为其实函数的参数的实现机制跟变量是很类似的。
为了升级我们的函数功能，我们需要完成几项任务：
参考变量的机制实现函数的参数机制； 支持在函数内部声明和使用本地变量，这个时候，我们需要能够区分函数作用域和全局作用域，还要能够在退出函数的时候，让本地变量的生命期随之结束； 要支持函数的返回值。 你可以想象到，在实现了这节课的功能以后，我们的语言就越来像样了。你甚至可以用这个语言来实现一点复杂的功能了，比如设计个函数，用来计算圆的周长、面积什么的。
好吧，让我们赶紧动手吧。首先，像上节课一样，我们还是要增强一下语法分析功能，以便解析函数的参数和返回值，并支持在函数内部声明本地变量。
增强语法分析功能我们原来的函数声明的语法比较简陋，现在我们采用一下TypeScript完整的函数声明语法。采用这个语法，函数可以有0到多个参数，每个参数都可以指定类型，就像变量一样，还可以指定函数返回值的类型。
//函数声明，由'function'关键字、函数名、函数签名和函数体构成。 functionDeclaration : 'function' Identifier callSignature '{' functionBody '}'; //函数签名，也就是参数数量和类型正确，以及函数的返回值类型正确 callSignature : &amp;lsquo;(&amp;rsquo; parameterList? &amp;lsquo;)&amp;rsquo; typeAnnotation? ;
//参数列表，由1到多个参数声明构成。 parameterList : parameter (&amp;rsquo;,&amp;rsquo; parameter)* ;
//参数，由参数名称和可选的类型标注构成 parameter : Identifier typeAnnotation? ;
//返回语句 returnStatement: &amp;lsquo;return&amp;rsquo; expression? &amp;lsquo;;&amp;rsquo; ; 采用该规则以后，你可以声明一个像下面的函数，比如，你给这个函数传入圆的半径的值，它会给你计算出圆的面积：
//计算圆的面积 function circleArea(r : number):number{ let area : number = 3.14rr; return area; } let r:number =4; println(&amp;ldquo;r=&amp;rdquo; + r +&amp;quot;, area=&amp;quot;+circleArea(r)); r = 5; println(&amp;ldquo;r=&amp;rdquo; + r +&amp;quot;, area=&amp;quot;+circleArea(r)); 好了，修改好语法规则以后，我们就按照该语法规则来升级一下语法分析程序，跟04讲一样，我们同样需要计算一下相关元素的First和Follow集合。在这里，我就不再演示计算First集合和Follow集合了，而是把它们留到了思考题的部分，让你自己来计算一个语法成分的Follow集合，这样能让你对LL算法理解得更加深入。</description></item><item><title>06｜怎么支持条件语句和循环语句？</title><link>https://artisanbox.github.io/3/8/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/8/</guid><description>你好，我是宫文学。
我们现在的语言已经支持表达式、变量和函数了。可是你发现没有，到现在为止，我们还没有支持流程控制类的语句，比如条件语句和循环语句。如果再加上这两类语句的话，我们的语言就能做很复杂的事情了，甚至你会觉得它已经是一门比较完整的语言了。
那么今天，我们就来加上条件语句和循环语句。在这个过程中，我们会加深对作用域和栈桢的理解，包括跨作用域的变量引用、词法作用域的概念，以及如何在运行时访问其他作用域的变量。这些知识点会帮助你加深对计算机语言的运行机制的理解。
而这些理解和认知，会有助于我们后面把基于AST的解释器升级成基于字节码的解释器，也有助于我们理解编译成机器码后的运行时机制。
好了，首先我们先从语法层面支持一下这两种语句。
语法分析：支持一元表达式按照惯例，我们首先要写下新的语法规则，然后使用LL算法来升级语法分析程序。新的语法规则如下：
ifStatement &amp;nbsp; &amp;nbsp; : If '(' expression ')' statement (Else statement)? &amp;nbsp; &amp;nbsp; ; forStatement :For '(' expression? ';' expression? ';' expression? ')' statement ; statement: : block | functionDecl | varaibleStatement | expressionStatement | returnStatement | ifStatement | forStatement | emptyStatement ; 你从上面的语法可以得到这几个信息：
首先，if语句中，else部分是可选的。这样，我们在解析完if条件后面的语句以后，要去看看后面跟着的是不是’else’关键字，从而决定是否解析else后面的语句块。更具体的你可以参见parseIfStatement函数的代码。
第二，在for循环语句中，for括号里用分号分割的三个表达式都是可选的，在解析的时候也要根据Follow集合来判断是否需要解析这三个表达式。这点你具体可以参见parseForStatement函数的代码。
最后，从statement的语法规则中，我们也可以发现，我们的语言所支持的语句越来越多了，这也使得语言特性越来越丰富了。
现在，升级我们的语法解析程序，对你来说已经没有太大的困难了，你可以参照我的参考实现动手自己做一下。
不过，为了实现for语句，我们还有一个语言特性需要升级一下，这就是对一元运算的支持。
哪些是一元运算呢？比如，在for语句中，我们经常会使用下面的写法：
for(i = 0; i&amp;lt; 10; i++) 其中i++就是使用了一元运算。在这里，为了方便，我们干脆就让程序支持所有的一元运算！
一元运算符除了++以外，还有–、~、!等。甚至还有更复杂一点的情况，+号和-号除了作为二元运算符以外，还可以作为一元运算符使用，比如下面这个例子：
myAge = +myAge + -10; 你甚至可以将多个一元运算符叠加使用，比如我们把上面的例子修改一下，仍然和原来的计算结果相同：</description></item><item><title>07｜怎么设计属于我们自己的虚拟机和字节码？</title><link>https://artisanbox.github.io/3/9/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/9/</guid><description>你好，我是宫文学。
到目前为止，我们的语言看上去已经有点像模像样了。但是有一个地方，我还一直是用比较凑合的方式来实现的，这就是解释器，这节课我想带你把它升级一下。
在之前的内容中，我们用的解释器都是基于AST执行的，而实际上，你所能见到的大多数解释执行的脚本语言，比如Python、PHP、JavaScript等，内部都是采用了一个虚拟机，用字节码解释执行的。像Java这样的语言，虽然是编译执行，但编译的结果也是字节码，JVM虚拟机也能够解释执行它。
为什么这些语言都广泛采用虚拟机呢？这主要是由基于AST的解释器的不足导致的。今天这节课，我就带你先来分析一下AST解释器的缺陷，然后了解一下像JVM这样的虚拟机的运行原理，特别是栈机和寄存器机的差别，以便确定我们自己的虚拟机的设计思路。
看上去任务有点多，没关系，我们一步一步来，我们先来分析一下基于AST的解释器。
基于AST的解释器的缺陷其实，我们目前采用的解释器，是一种最简单的解释器。它有时被称为“树遍历解释器”(Tree-walking Interpreter)，或者更简单一点，也被叫做“AST解释器”。
为什么我刚刚会说我们这个基于AST的解释器有点凑合呢？你可能会想通过遍历AST来执行程序不是挺好的吗？
确实，AST解释器虽然简单，但很有用。比如，最常见的就是对一个表达式做求值，实现类似公式计算的功能，这在电子表格等系统里很常见。甚至在MySQL中，也是基于AST做表达式的计算，还有一些计算机语言的早期版本（如Ruby），以及一些产品中自带的脚本功能，也是用AST解释器就足够了！
不过，虽然AST解释器很有用，但它仍然有明显的缺陷。最主要的问题，就是性能差，在运行时需要消耗更多的CPU时间和内存。在上一节课里，你可能使用过我们的函数特性计算过斐波那契数列，在参数值比较大的情况下（比如n大于30以后），你会看到程序的运行速度确实比较慢。
为什么会这样呢？你再来看我们的解释器，会发现它哪怕只是做一个表达式求值，也要层层做很多次的函数调用。比如，简单的计算2+3*5，需要做的调用包括：
visitBlock() visitStatement() visitExpressionStatement() visitBinary() //+号 visitIntegerLiteral() //2 visitBinary() //*号 visitIntegerLiteral() //3 visitIntegerLiteral() //5 从表面上看起来，这只是做了8次的函数调用。其实，如果你仔细看我们代码的细节，就会发现，由于我们的程序采用了Visitor模式，每一次调用还都有一个Visitor.visit(AstNode)和AstNode.accept(Visitor)来回握手的过程，所以加起来一共做了24次函数调用。
这样的函数调用的开销是很大的。在上一节课，你已经知道了，每次函数调用都需要创建一个栈桢，这会导致内存的消耗。调用函数和从函数返回，也都需要耗费额外的CPU时间。在后面的课程里，等我们对程序的运行时机制的细节了解得更清楚以后，你会更加理解这些额外的开销发生在什么地方。
除了性能问题，AST解释器还有其他的问题。比如，我们已经看到，在实现Return语句的时候，需要额外的冗余处理，以便跳过Return后面的语句，类似的情况还发生在Break、Continue等语句中。总的来说，在控制流的跳转方面，用AST都不方便。
还有，我们执行函数调用的时候，需要从函数调用的AST节点跳到函数声明的节点，这让人有点眼花缭乱。如果我们后面支持类、Lambda等更加丰富的特性，需要运行类的构造函数、进行类成员的初始化，查找并执行正确的父类或子类的方法，那么程序的执行过程会更加让人难以理解。
而且，从根本上来说，AST这种数据结构，比较忠实地体现了高级语言的语法特征。而高级语言呢，是设计用来方便人类理解的，并不是适合机器执行的。把计算机语言从适合人类阅读，变成适合机器执行，本来就是编译器要做的事情。不过，把高级语言变成AST，我们叫做解析（Parse），还不能称上是编译（Compile）。要称得上编译，要对程序的表示方式做更多的变换才行。
那接下来呢，我们就探讨一下如何把程序编译成对机器更友好的方式。按照循序渐进的学习原则，我们不会一下子就编译成机器码，而是先编译成字节码，并试着实现一个虚拟机。
初步了解虚拟机说到虚拟机，我们大多数人都不陌生。比如Java语言最显著的特征之一，就是运行在虚拟机上，而不是像C语言或Go语言那样，编译成可执行文件直接运行；.NET也是用了类似的架构。就算现在Java支持AOT（Ahead of Time）编译方式了，它的可执行文件中仍然打包了一个小型的虚拟机，以便支持某些特别的语言特性。
至于其他语言，如Python、JavaScript等，虽然我们不怎么提及它们的虚拟机，但它们通常都是基于虚拟机来运行的。
虚拟机如此流行，不是偶然现象，因为它提供了一些明显的优点。其中最值得注意的，就是程序可以独立于具体的计算机硬件和操作系统而运行。所以，我们在任何设备上，无论是Mac电脑、Windows电脑、安卓手机还是iPad，都可以用浏览器打开一个页面，并运行里面的JavaScript。而如果采用C语言那样的运行方式，那么针对每种不同的CPU和操作系统的组合，都要生成不同的可执行文件，这对于像浏览器一样的很多应用场景，显然都是很麻烦的。
虚拟机还能提供其他好处，比如通过托管运行提供更高的安全性，还有通过标准的方式使用不同计算机上的文件资源、网络资源、线程资源和图形资源等等。
实际上，虚拟化是计算机领域的一个基本思路。比如，云计算平台能够虚拟出很多不同的操作系统，在基于ARM芯的Mac上可以仿真运行基于X86的Windows等等，都是不同角度的虚拟化。
所以说，要实现一门现代计算机语言，就不能忽视虚拟机方面的知识。
那语言的虚拟机都要包含哪些功能呢？又是由哪些部分构成的呢？
介绍虚拟机的文章很多，特别是针对像JVM和安卓的ART这样广泛使用的平台，有专门的书籍和课程来深入剖析。在我们的课程里，由于我们自己要实现一下虚拟机，因此我也会简单介绍一下虚拟机的原理和构成，当然更多的就要靠你动手实践来掌握虚拟机的精髓了。
总的来说，虚拟机可以看做是一台虚拟的计算机，它能像物理计算机一样，给程序提供一个完整的运行环境。
首先，虚拟机像物理计算机一样，会支持一个指令集。我们的程序按照这个指令集编译成目标代码后，就可以在虚拟机上执行了。
第二，虚拟机也像物理计算机一样，提供内存资源。比如在JVM中，你可以使用栈和堆两种内存。根据不同语言的内存管理机制的不同，在虚拟机里通常还要集成垃圾收集机制。
第三，虚拟机要像物理计算机一样，能够加载程序的代码并执行。程序的目标代码文件中，除了可执行的代码（也就是虚拟机指令），还会包含一些静态的数据，比如程序的符号表，这会让你的程序支持元编程功能，比如运行时的类型判断、基于反射来运行代码等等。静态数据还包括程序中使用的一些常量，比如字符串常量、整数常量等等。对于代码和静态数据，会被虚拟机放在特定的区域，并且能够被指令访问。
此外，虚拟机还要在IO、并发等方面提供相应的支持。这样，我们才可以实现像在终端打印字符这样的功能。
好了，我们已经大概了解了虚拟机相关的概念。不过，不同的虚拟机在运行代码的机制方面是有所区别的，这也会影响到字节码的设计和算法的实现，所以我们现在展开介绍一下。
你可能听说过寄存器机和栈机，这就是比较流行两种程序运行机制。
栈机和寄存器机使用栈机的典型代表，就是JVM，它能够运行Java的字节码。Web Assembly是为浏览器设计的字节码，它的设计也是栈机的架构。
使用寄存器机的典型代表是能够运行JavaScript的V8，V8里面有一个基于寄存器机的字节码解释器。而Lua和Erlang内部也是采用了寄存器机作为程序的运行机制，其实我们现在使用物理计算机，也是寄存器机。
栈机和寄存器机的主要区别，是获取操作数的方式不同：栈机是从操作数栈里获取操作数，而寄存器机是从寄存器里获取。比如要计算“a+3”这个表达式，虚拟机通常都提供了一个指令用来做加法。a和3呢，则是加法指令的操作数，其中a是一个本地变量，其值为2，另一个操作数是常量3。那怎么完成这个加法操作呢？
栈机的运行方式，是先把a的值从内存取出来，压到一个叫做操作栈的区域（使用load指令），然后把常量3压到操作数栈里（使用push指令），接着执行add指令。在执行add指令的时候，就从操作数栈里弹出a和3，做完加法以后，再把结果5压到栈里。
而寄存器机的运行方式，是先把a的值加载到寄存器，在执行add指令的时候，从这寄存器取数，加上常量3以后，再把结果5放回到寄存器。
总结起来，栈机和寄存器机的区别有这三个方面：
第一，操作数的存储机制不同。栈机的操作数放在操作栈，操作数栈的大小几乎不受限制；而寄存器机的操作数是放在寄存器里，寄存器的数量是有限的。需要说明的是，对于物理机来说，寄存器指的是物理寄存器；而对于虚拟机来说，寄存器通常只是几个本地变量。但因为这些变量被频繁访问，根据寄存器分配算法，它们有比较大的概率被映射成物理寄存器，从而大大提高运行性能。
第二，指令的格式不同。寄存器机的指令，需要在操作数里指定运算所需的源和目的操作数。而栈机的运算性的指令，比如加减乘除等，是不需要带操作数的，因为操作数就在栈顶；而像push、load这样的指令，是把数据压到栈里，也不需要指定目的地，因为这个数据也一定是存到栈顶的。
第三，生成字节码的难度不同。从AST生成栈机的代码是比较容易的，你在后面就可以体会到。而生成寄存器机的代码的难度就更高一些，因为寄存器的数量是有限的，我们必须要添加寄存器分配算法。
了解了栈机和寄存器机的这些差别以后，我们就可以根据自己的需求做取舍。比如，如果要更关注运行性能，就选用寄存器机；而如果想实现起来简单一点，并且指令数量更少，便于通过网络传输，我们就可以用栈机。
好了，现在我们已经初步了解了两种运行机制和两类指令集的特点了，是时候设计我们自己的虚拟机和字节码了！
设计我们自己的虚拟机设计一个虚拟机是一项挺有挑战的工作，不过，如果我们仍然采取先迈出一小步，然后慢慢迭代的思路，就没那么复杂了。
在实现一个虚拟机之前，有些关键的技术决策是要确定一下的，这些决策影响到虚拟机的特性和我们所采用的技术。
决策1：选择栈机还是寄存器机？
其实，栈机和寄存器都能满足我们对于程序运行的核心需求，因为我们目前对性能、字节码的大小都没有什么特别的要求。不过，经过思考，我最终选择了栈机，主要有这几个考虑：
首先，Java的JVM用的就是栈机，而且讲述JVM的资料也很多，方便我们借鉴和学习它成熟的设计思路。
第二，由于我们最后是要生成面向物理机的机器码，而物理机就是寄存器机，所以我们肯定会学到这方面的知识。从扩大知识面的角度，我们在虚拟机层面熟悉一下栈机就更好了。
第三，Web Assembly是一个很有前途的技术领域，目前各门语言都在添加编译成Web Assembly的工作。而自己动手实现一个栈机的经验，有助于我们理解Web Assembly，为未来支持Web Assembly打下基础。</description></item><item><title>08｜基于TypeScript的虚拟机（一）：实现一个简单的栈机</title><link>https://artisanbox.github.io/3/10/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/10/</guid><description>你好，我是宫文学。
上一节课，我们已经探讨了设计一个虚拟机所要考虑的那些因素，并做出了一些设计决策。那么今天这一节课，我们就来实现一个初级的虚拟机。
要实现这个初级虚拟机，具体来说，我们要完成下面三方面的工作：
首先，我们要设计一些字节码，来支持第一批语言特性，包括支持函数、变量和整型数据的运算。也就是说，我们的虚拟机要能够支持下面程序的正确运行：
//一个简单的函数，把输入的参数加10，然后返回 function foo(x:number):number{ return x + 10; } //调用foo，并输出结果 println(foo(18)); 第二，我们要做一个字节码生成程序，基于当前的AST生成正确的字节码。
第三，使用TypeScript，实现一个虚拟机的原型系统，验证相关设计概念。
话不多说，开搞，让我们先设计一下字节码吧！
“设计”字节码说是设计，其实我比较懒，更愿意抄袭现成的设计，比如Java的字节码设计。因为Java字节码的资料最充分，比较容易研究，不像V8等的字节码，只有很少的文档资料，探讨的人也很少。另外，学会手工生成Java字节码还有潜在的实用价值，比如你可以把自己的语言编译后直接在JVM上运行。那么我们就先来研究一下Java字节码的特点。
上面的用TypeScript编写的示例代码，如果用Java改写，会变成下面的程序：
//实现同样功能的Java程序。 public class A{ public static int foo(int a){ return a + 10; } public static void main(String args[]){ System.out.println(foo(8)); } } 我们首先把这个Java程序编译成字节码。
javac A.java 这个文件是一个二进制文件。我们可以用hexdump命令查看它的内容。
hexdump -C A.class 从hexdump显示的信息中，你能看到一些可以阅读的字符，比如“java/lang/Object”、"java/lang/System"等等，这些是常量表中的内容。还有一些内容显然不是字符，没法在屏幕上显示，所以hexdump就用一个.号来表示。其中某些字节，代表的是指令，我在图中把代表foo函数、main函数和构造函数的指令标注了出来，这些都是。用于运行的字节码指令，其他都是一些符号表等描述性的信息。
通过上图，你还能得到一个直观的印象：字节码文件并不都是由指令构成的。
没错，指令只是一个程序文件的一部分。除了指令以外，在字节码文件中还要存储不少其他内容，才能保证程序的正常运行，比如类和方法的符号信息、字符串和数字常量，等等。至于字节码文件的格式，是由字节码的规范来规定的，你有兴趣的话，可以按照规范生成这样的字节码文件。这样的话，我们的程序就可以在JVM上运行了。
不过，我现在不想陷入字节码文件格式的细节里，而是想用自己的方式生成字节码文件，够支持现在的语言特性，能够在我们自己的虚拟机上运行就行了。
上面这张图显示的字节码文件不是很容易阅读和理解。所以，我们用javap命令把它转化成文本格式来看看。
javap -v A.class &amp;gt; A.bc 在这个新生成的文件里，我们可以清晰地看到每个函数的定义以及指令，我也在图里标注了主要的指令的含义。
看到这个字节码文件的内容，你可能会直观地觉得：这看上去跟我们的高级语言也没有那么大的区别嘛。程序照样划分成几个函数，只不过每个函数里的语句变成了栈机的指令而已，函数之间照样需要互相调用。
实际上也确实没错。字节码文件里本来就存储了各个类和方法的符号信息，相当于保存了高级语言里的主体框架。当然，每个方法体里的代码就看不出if语句、循环语句这样的结构了，而是变成了字节码的指令。
通过研究这些指令，加上查阅JVM规则中对于字节码的规定，你会发现为了实现上面示例代码中的功能，我们目前只需要这几个指令就够了：
你先花一两分钟看一下这些指令，看上去挺多，其实可以分为几组。
首先是iload系列，这是把指定下标的本地变量入栈。注意，变量的下标是由声明的顺序决定的，参数也算本地变量，并且排在最前面。所以，iload 0的意思，就是把第一个参数入栈。如果没有参数，就是把第一个本地变量入栈。
iload后面的那几个指令，是压缩格式的指令，也就是利用指令末尾富余的位，把操作数和指令压缩在了一起，这样可以少一个字节码，能够缩小最后生成的字节码文件的大小。从这里面，你能借鉴到字节码设计的一些好的实践。所以你看，学习成熟的设计是有好处的吧？
第二组是istore系列，它做的工作刚好跟iload相反，是把栈顶的值存到指定下标的变量里去。
第三组，是对常数做入栈的操作。对于0~5这几个数字，Java字节码也是提供了压缩格式的指令。对于8位整数（-128~127），使用bipush指令。对于16位整数（-32768~32767），使用sipush指令。而对于更大的常数，则要使用ldc指令，从常量池里去取。
第四组，是几个二元运算的指令。它们都是从栈里取两个操作数，计算完毕之后，再压回栈里。</description></item><item><title>09｜基于TypeScript的虚拟机（二）：丰富特性，支持跳转语句</title><link>https://artisanbox.github.io/3/11/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/11/</guid><description>你好，我是宫文学。
在上一节课里，我们已经实现了一个简单的虚拟机。不过，这个虚拟机也太简单了，实在是不够实用啊。
那么，今天这节课，我们就来增强一下当前的虚拟机，让它的特性更丰富一些，也为我们后续的工作做好铺垫，比如用C语言实现一个更强的虚拟机。
我们在这一节课有两项任务要完成：
首先，要支持if语句和for循环语句。这样，我们就能熟悉与程序分支有关的指令，并且还能让虚拟机支持复杂一点的程序，比如我们之前写过的生成斐波那契数列的程序。
第二，做一下性能比拼。既然我们已经完成了字节码虚拟机的开发，那就跟AST解释器做一些性能测试，看看性能到底差多少。
话不多说，开干！首先，我们来实现一下if语句和for循环语句。而实现这两个语句的核心，就是要支持跳转指令。
了解跳转指令if语句和for循环语句，有一个特点，就是让程序根据一定的条件执行不同的代码。这样一个语法，比较适合我们人类阅读，但是对于机器执行并不方便。机器执行的代码，都是一条条指令排成的直线型的代码，但是可以根据需要跳转到不同的指令去执行。
针对这样的差异，编译器就需要把if和for这样结构化编程的代码，转变成通过跳转指令跳转的代码，其中的关键是计算出正确的跳转地址。
我们举个例子来说明一下，下面是我用Java写的一个示例程序，它有一个if语句。
public static int foo3(int a){ int b; if (a &amp;gt; 10){ b = a + 8; } else{ b = a - 8; } return b; } 我们先用javac命令编译成.class文件，然后再用javap命令以文本方式显示生成的字节码：
我主要是想通过这个示例程序，给你展现两条跳转指令。
一条是if_icmple，它是一条有条件的跳转指令。它给栈顶的两个元素做&amp;lt;=（less equal，缩写为le）运算。如果计算结果为真，那么就跳转到分支地址14。
你可能会发现一个问题，为什么我们的源代码是&amp;gt;号，翻译成字节码却变成了&amp;lt;=号了呢？没错，虽然符号变了，但其实我们的语义并没有发生变化。
我给你分析一下，在源代码里面，程序用&amp;gt;号计算为真，就执行if下面的块；那就意味着如果&amp;gt;号计算为假，或者说&amp;lt;=号为真，则跳转到else下面的那个块，这两种说法是等价的。
但现在我们要生成的是跳转指令，所以用&amp;lt;=做判断，然后再跳转，就是比较自然了。具体你可以看看我们下文中为if语句生成代码的逻辑和相关的图，就更容易理解了。
你在字节码中还会看到另一个跳转指令，是goto指令，它是一个无条件跳转指令。
在计算机语言发展的早期，人们用高级语言写程序的时候，也会用很多goto语句，导致程序非常难以阅读，程序的控制流理解起来困难。虽然直到今天，C和C++语言里还保留了goto语句。不过，一般不到迫不得已，你不应该使用goto语句。
这种迫不得已的情况，我指的是使用goto语句实现一些奇特的效果，这些效果是用结构化编程方式（也就是不用goto语句，而是用条件语句和循环语句表达程序分支）无法完成的。比如，采用goto语句能够从一个嵌套很深的语句块，一下子跳到外面，然后还能再跳进去，接着继续执行！这相当于能够暂停一个执行到一半的程序，然后需要时再恢复上下文，接着执行。
我在说什么呢？这可以跟协程的实现机制关联起来，协程要求在应用层把一个程序停止下来，然后在需要的时候再继续执行。那么利用C/C++的goto语句的无条件跳转能力，你其实就可以实现一个协程库，如果你想了解得更具体一些，可以看看我之前的《编译原理实战课》。
总结起来，goto的这种跳转方式，是更加底层的一种机制。所以，在编译程序的过程中，我们会多次变换程序的表达方式，让它越来越接近计算机容易理解的形式，这个过程叫做Lower过程。而Lower到一定程度，就会形成线性代码加跳转语句的代码格式，我们有时候就会把这种格式的IR叫做“goto格式（goto form）”。
好了，刚才聊的关于goto语句的这些知识点，是为了加深大家对它的认识，希望能够对你的编程思想有所启发。
回到正题，现在我们已经对跳转指令有了基本的认识，那么我就把接下来要用到的跳转指令列出来，你可以看看下面这两张表：
如果后面要增加对浮点数和对象引用的比较功能，我们可以再增加一些指令。但由于目前我们还是只处理整数，所以这些指令就够了。
接着，我们就修改一下字节码生成程序和虚拟机中的执行引擎，让它们能够支持if语句和for语句。
为if语句和for循环语句生成字节码让if语句生成字节码的代码你可以参考visitIfStatement方法。在这个方法里，我们首先为if条件、if后面的块、else块分别生成了字节码。
//条件表达式的代码 let code_condition:number[] = this.visit(ifstmt.condition); //if块的代码 let code_ifBlock:number[] = this.visit(ifstmt.stmt); //else块的代码 let code_elseBlock:number[] = (ifstmt.</description></item><item><title>10｜基于C语言的虚拟机（一）：实现一个简单的栈机</title><link>https://artisanbox.github.io/3/12/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/12/</guid><description>你好，我是宫文学。
到目前为止，我们已经用TypeScript实现了一个小而全的虚拟机，也在这个过程中稍微体会了一下虚拟机设计的一些要点，比如字节码的设计、指令的生成和栈机的运行机理等等，而且我们还通过性能测试，也看到了栈机确实比AST解释器的性能更高。
虽然，上面这些工作我们都是用TypeScript实现的，但既然我们已经生成了字节码，我不由地产生了一个想法：我们能不能用C语言这样的更基础的语言来实现一个虚拟机，同样来运行这些字节码呢？
我这样的想法可不是凭空产生的。你看，字节码最大的好处，就是和平台无关的能力。不管什么平台，只要有个虚拟机，就可以运行字节码，这也是安卓平台一开始选择字节码作为运行机制的原因。你甚至也可以来试一试，假设现在时间回到智能手机刚出现的时代，你是否也能够快速设计一个虚拟机，来运行手机上的应用呢？
那么进一步，在这种移动设备上运行的应用，很重要的功能就是去调用底层操作系统的API。用C和C++实现的虚拟机，显然在这方面有优势，能够尽量降低由于ABI转换所带来的性能损失。
所以，这一节课，我就带你用C语言重新实现一遍虚拟机。在这个过程中，你会对字节码文件的设计有更细致的体会，对于符号表的作用的理解也会加深，也会掌握如何用C语言设计栈桢的知识点。
好了，我们首先实现第一步的目标，把程序保存成字节码文件，再把字节码文件加载到内存。
读写字节码文件在TypeScript版的虚拟机中，我们用了模块（BCModule）来保存程序的相关信息，有了这样一个模块，程序就可以生成一个独立的字节码文件，就像Java语言里，每个.java文件会编译生成一个.class文件那样。
首先，我们要先来定字节码的文件格式。
我们也说过，Java语言的字节码文件，是依据了专门的技术规范。其实我们仍然可以采用Java字节码文件的格式，你查阅相应的技术规格就可以。这样的话，我们编译后的结果，就直接可以用Java虚拟机来运行了！
有时间的同学可以做一下这个尝试。这项工作在某些场景下会很有意义。你可以定义自己的DSL，直接生成字节码，跟Java编写的程序一起混合运行。我认识的一位极客朋友就做了类似的使用，用低代码的编程界面直接生成了.NET的字节码，形成了一个基于Unity的游戏开发平台。
不过，我们目前的语言比较简单，所以不用遵循那么复杂的规范，我们就设计自己的文件格式就好了。
第二，我们需要考虑：保存什么信息到字节码文件里，才足够用于程序的运行？
从我们目前实现的虚拟机来看，其实不需要太多的信息。你可以回忆一下，其实要保证程序的运行，只需要能够从常量表里查找到函数的一些基本信息即可，最重要的信息包括：
这个函数的字节码； 这个函数有几个本地变量？我们需要在栈桢里保留存储位置； 这个函数的操作数栈的最大尺寸是多少？也就是最多的时候，需要在栈里保存几个操作数，以便我们预留存储空间。 除了这些信息外，再就是我们的代码里用到了的部分数字常量，也需要从常量表里加载，就像ldc指令那样。
所以说，只要把函数常量、数字常量存成字节码文件，就足够我们现在的虚拟机使用了。你也可以看到，我们现在甚至连函数名称、函数的签名都不需要，如果需要的话，也是为了在运行期来显示错误信息而已。
不过，如果把函数名称和函数签名的信息加进去，会有利于我们实现多模块的运行机制。也就是说，如果一个模块中的函数要调用另一个模块中的函数，那么我们可以创造一种机制，实现模块之间的代码查找。
这其实就是Java的类加载机制和多个.class文件之间互相调用的机制，我们仍然可以借鉴。而且，即使像C语言那样的编译成本地代码的语言，也是通过暴露出函数签名的信息，来实现多个模块之间的静态链接和动态链接机制的。
那再进一步，既然需要函数签名，那么我们就需要知道一些类型信息，比如往函数里要传递什么类型的参数，返回的是什么类型的数据，这样调用者和被调用者之间才能无缝衔接到一起。
像C语言这样的系统语言，以及在操作系统的ABI里，支持的都是一些基础的数据类型的信息，比如整数、浮点数、整数指针、字符串指针之类的。而像Java等语言，它们建立了具有较高抽象度的类型体系，还可以包含这些高级的类型信息，从而实现像运行时的类型判断、通过反省的方式动态运行程序等高级功能。
上面这几段的分析总结起来，就是我们需要往目标文件里或多或少地保存一些类型信息。
那么现在就清楚了，我们需要把常量信息和类型信息写到字节码里，就足够程序运行了。
现在，我们来到了第三个步骤：序列化。
具体来说，序列化就是把这些信息以一定的格式写到文件里，再从文件里恢复的过程，是一个比较啰嗦的、充满细节的过程。也就是说，我们在内存里是一种比较结构化的数据，而在文件里保存，或者通过网络传输，都是采用一个线性的数据结构。
在我的编程经验里，所有这些序列化的工作都比较繁琐，但大致的实现方式都是一样的。无论是保存成二进制格式、XML格式、json格式，还是基于一种网络协议在网络上传输，都是一个把内存中的数据结构变成线性的数据结构，然后再从线性的数据结构中恢复的过程。
你可以看看BCModuleWriter和BCModuleReader中的代码，实现的技巧也很简单，最重要的就是你要知道每个数据占了多少个字节。比如，当你向文件里写一个字符串的时候，你先要写下字符串的长度，再写字符串的实际数据，用这样的方法，当你读文件的时候，就能把相关信息顺利还原了。
这类程序中稍微有点难的地方，是保证对象之间正确的引用关系。比如，函数引用了变量和类型，而高级的类型之间也是互相有引用关系的，比如子类型的关系等等，这样就构成了一张网状的数据结构，相互之间有引用。
当你写入文件的时候，要注意，这个网的每个节点只能写一次，不能因为两个函数的返回值都引用了某个类型，就把这个类型写了两次。在读的时候呢，则要重新建立起对象之间正确的引用关系。
好了，了解了实现思路以后，再阅读相应的示例代码就很容易了。在TypeScript中，我用BCModuleWriter把斐波那契数列程序的字节码写成了文件，然后用hexdump命令来显示一下看看：
乍一看，这个跟Java的字节码文件还挺像的，不过我们用的是自己的简单格式。我在图中做了标注，标明了字节是什么含义。其中_main函数和fibonacci函数的字节码指令，我也标了出来。
之后，我可以用BCModuleReader把这个字节码文件再读入内存，重建BCModule，包括里面的符号信息。如果基于这个新的BCModule，程序同样可以顺畅地运行，那就说明我们的字节码文件里面确实包含了足够的运行信息。
好了，现在我们的字节码文件以及相应的读写机制已经设计成功，也用TypeScript做完了所有的设计验证。在这个基础上，重新用C语言实现一个虚拟机，就是一个比较简单的事情了。你可以发现，虽然我们的语言换了，但虚拟机的实现机制没有变。
接下来，我们就需要用C语言把字节码文件读到内存，并在内存重建BCModule相关的各种对象结构。
用C语言读入字节码文件关于C语言版本的字节码读取程序，你可以参考一下readBCModule函数的代码。在读取了字节码文件以后，我还写了一个dumpBCModule的函数，可以在控制台显示BCModule的信息，如下图所示：
你可能会注意到，我们最后的模型里的类型信息和函数都比字节码文件里的要多。不要担心，多出来的其实是系统内置的类型（比如number类型）和内置函数（比如println），它们不需要被保存在字节码文件里，但是会被我们的程序引用到，所以我们要在内存的数据结构中体现。
在这里，我重新梳理一下内存里的对象模型，这个对象模型就是我们运行时所需要的所有信息。我们读取了字节码文件以后，会在内存里形成这个结构化的对象模型，来代表一个程序的信息。
这里我再讲一个小技术点，看着上面的类图，你可能会问：C语言不是不支持面向对象吗？你为什么还能用面向对象的方式来保存这些信息？
其实，用C语言也能模拟类似面向对象的机制。以符号为例，我们是这样声明Symbol和FunctionSymbol的，让FunctionSymbol包含基类Symbol中的数据：
typedef struct _Symbol{ char* name; //符号名称 Type* theType; //类型 SymKind kind; //符号种类 } Symbol; typedef struct _FunctionSymbol{ Symbol symbol; //基类数据 int numVars; //本地变量数量 VarSymbol ** vars; //本地变量信息 int opStackSize; //操作数栈大小 int numByteCodes; //字节码数量 unsigned char* byteCode; //字节码指令 } FunctionSymbol; 在内存里，FunctionSymbol最前面的字段，就是Symbol的字段，因此你可以把FunctionSymbol的指针强制转换成Symbol的指针，从而访问Symbol的字段。这种编程方式在一些用C语言编写的系统软件里非常普遍，包括其他作者写的一些编译器的代码，以及Linux操作系统内核中的代码中都有体现。</description></item><item><title>11｜基于C语言的虚拟机（二）：性能增长10倍的秘密</title><link>https://artisanbox.github.io/3/13/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/13/</guid><description>你好，我是宫文学。
上一节课，我们初步实现了一个C语言版本的虚拟机，让它顺利地跑起来了。你想想看，用TypeScript生成字节码文件，然后在一个C语言实现的虚拟机上去运行，这个设计，其实和Java应用、Andorid应用、Erlang应用、Lua应用等的运行机制是一样的。也就是说，如果退回到智能手机刚诞生的年代，你完全可以像Android的发明人一样，用这种方式提供一个移动应用开发工具。
其实，我国最新的自主操作系统HarmonyOS，也是采用了像我们这门课一样的虚拟机设计机制，而且用的就是TypeScript语言，这也是我这门课采用TypeScript作为教学语言的原因之一。虽然我还没有看到HarmonyOS的虚拟机代码，但并不妨碍我去理解它的实现原理。当然了，你在学完这门课以后，也会更容易理解HarmonyOS的开发方式，而且也有助于你阅读它的虚拟机的代码。
好了，对于我们当前成果的吹捧到此打住。让我们回到现实，现实有点残酷：我们当前实现的基于C语言的虚拟机，在上一节课的性能测试中，竟然排名倒数第一。这显然不正常，这也说明了在虚拟机的设计中，我们还有一些重要的设计考虑被忽视了。
那这一节课呢，我们就来分析一下导致我们虚拟机性能不高的原因，并且针对性地解决掉这个问题。在这个过程中，你会加深对计算机语言的运行时技术的理解，特别是对内存管理的理解。
那首先，让我们把产生性能问题的可能原因分析一下。
性能问题的分析首先，我们应该了解到一点，现代的JavaScript引擎，性能确实挺高的。
在我们TypeScript版本的虚拟机中，TypeScript被编译成了JavaScript，并在Node.js中运行，而Node.js又是基于V8引擎的。
在互联网的早期，JavaScript的运行效率比较低。但是后来，以V8为代表的JavaScript引擎，性能有了大幅度的提升，使得现在的Web前端可以实现很复杂的功能。
V8在运行JavaScript的时候，会做即时编译（JIT）。V8的即时编译器，能够根据运行时收集的信息对类型做推测，这也就避免了由于运行时的类型判断而产生的额外开销，从而生成了跟提前编译（AOT）差不多的代码。如果你想了解更多细节，你可以去看看我在《编译原理实战课》中对V8的剖析。
从原理上来说，运行时的推测机制，甚至会生成比提前编译（AOT）更高效的代码。因为它拥有运行时的统计信息，并通过某些优化算法（参考JVM的局部逃逸分析算法）实现了更好的编译优化。
换一句话说，V8也是编译生成了机器码，甚至有时候会生成更高效的机器码。仅从这一点看，它并不会比C语言的提前编译差。
不过，JavaScript毕竟是动态类型的语言，它的编译和运行过程会有一些额外的开销。
比如，编译后的目标代码总要留出一些口子，用来处理类型预测失效的情况。这个时候，它会从运行本地代码的状态退回到解释器去执行。
所以，平均来说，JavaScript编写的程序，性能不会比C/C++更高。它在某些场景下能接近C/C++的性能，已经相当惊人了。
可是，在上一节中TypeScript版本虚拟机的性能居然是C语言版本的2倍半，这就太不正常了。一定还有别的因素在起作用。
所以，我们来看看第二方面的因素，就是运行时的设计。
在前面的讨论中，我们比较关注的是编译技术与性能的关系。不过，在一个虚拟机中，还会有其他影响性能的因素，这就是语言的运行时。运行时就是支撑我们的应用程序运行所需要的一些软件功能，最常见的运行时功能就是内存管理机制和并发机制。
在这里，我们重点要看一下内存管理机制。通常我们提到内存管理的时候，一下子就想到垃圾收集机制去了。其实，这只是内存管理的一半工作，完整的内存管理功能还要包括内存的申请机制。
在像Java、JavaScript这样的语言中，语言的运行时需要根据程序的指令，随时在内存中创建对象，然后在程序用不到这些对象的时候，再使用垃圾收集机制，把这些对象所占据的内存释放掉。
那么重点就来了：申请和释放内存，有时会导致巨大的性能开销。一个好的运行时，必须想办法降低这些开销。
我们初版的C语言虚拟机可能就存在这方面的问题。不过，计算机语言的运行时，都是从堆里申请和管理内存的。为了让你理解内存管理和性能的关系，更好地排查出影响C语言虚拟机性能的原因，我们首先回顾一下栈和堆这两种基础的内存管理机制。
两种内存管理机制：栈和堆在现代的操作系统中，为了支持应用的运行，通常会提供栈和堆这两种内存管理机制。当我们在一个C语言的函数里使用本地变量时，这些本地变量所需的内存是在栈里申请的，这也就是这个函数所使用的栈桢。而当我们用C语言的malloc函数申请一块内存的时候，这块内存就是从堆里申请的。
不过，只有像C/C++这样直接编译成本地代码的语言，才可以使用操作系统的栈来保存栈桢。在后面的课程中，我们也会生成与栈桢管理有关的汇编代码，管理栈桢通常需要修改特定寄存器的值，以及使用push、pop等辅助的指令。
在我们的解释器所使用的栈桢是自己管理的，本质都是从堆里申请的。从栈里和堆里申请内存的开销是不一样的。
从栈里申请内存很简单，基本上只需要修改栈顶指针，也就是某个特定寄存器的值就行了，栈就会自动地伸缩，整个栈的地址空间始终是连续的一整块内存。
而堆就不是了。从堆里申请的内存，由于每个对象的生存期是不一样的，所以就会形成很多的“空洞”，导致内存碎片化。这样，再次申请内存的时候，操作系统需要找到一块大小合适的自由内存空间。这个过程，就需要消耗一定的计算量。在内存碎片化越来越严重的情况下，找到一块可用内存空间的开销会越来越大。
另外，程序的并发也会为堆的内存申请带来额外的开销。在现代操作系统中，每个线程都有自己独享的栈，相互之间不会干扰，但堆却是各个线程所共享的。所以，在分配内存的时候，操作系统会进行线程间的同步，每次只能为一个线程分配内存，避免同一块内存被分配给多个线程。这显然也会降低系统的性能。
现在你再回头来看看我们的C语言虚拟机的实现。在栈桢和操作数栈这两个数据结构中，有好几个地方都是指针，比如本地变量的数组、操作数栈，以及操作数栈中的数据区。按照常规的编程方法，我们为每个指针都单独申请了内存。
typedef struct _StackFrame{ //本栈桢对应的函数，用来找到代码 FunctionSymbol* functionSym; //返回地址 int returnIndex; //本地变量数组 NUMBER* localVars; //操作数栈 OprandStack* oprandStack; //指向前一个栈桢的链接 struct _StackFrame * prev; }StackFrame; /**
操作数栈 当栈为空的时候，top = -1; */ typedef struct _OprandStack{ NUMBER * data; //数组 int top; //栈顶的索引值 }OprandStack; 这样就导致我们一个栈桢的内存布局被切成了4小块：</description></item><item><title>12｜物理机上程序运行的硬件环境是怎么样的？</title><link>https://artisanbox.github.io/3/14/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/14/</guid><description>你好，我是宫文学。
在经过了几节课的努力以后，我们的语言运行引擎，从AST解释器升级成了TypeScript版的虚拟机，又升级成了C语言版的虚拟机。这个过程中，我们的语言的性能在不断地提升。并且，我们的关注点，也越来越从高层的语法语义处理层面，往底层技术方向靠拢了。
虽然我们现在的语言特性还不够丰富，但我还是想先带你继续往下钻。我们的目标是先把技术栈钻透，然后再在各个层次上扩大战果。
所以，在接下来的几节课里，我们会把程序编译成汇编代码，然后再生成二进制的可执行程序。在这个过程中，你会把很多过去比较模糊的底层机制搞清楚，我也会带你去除一些知识点的神秘面纱，让你不再畏惧它们。
在此之前，为了让你编译后的程序能够在计算机上跑起来，你必须把物理计算机上程序的运行机制搞清楚，特别是要搞清楚应用程序、操作系统和底层硬件的互动关系。这里面的一些知识点，通常很多程序员都理解得似是而非，不是太透彻。而理解了这些程序运行机制，除了能够让我们的语言在计算机上顺利地运行，还能够帮助你胜任一些系统级软件的开发任务。
今天这节课，我想先带你透彻了解程序运行的硬件环境，以及硬件架构跟我们实现计算机语言的关系。在下节课，我则会带你透彻了解程序运行的软件环境。
硬件环境和程序的运行机制其实，我们现在用的计算机、手机、物联网等大部分智能设备，它们的硬件架构都是差不多的，基本遵循下面这张图所展示的架构。而这张图上画出来的部分，都是需要我们在实现一门计算机语言的时候需要了解的。
首先我们从整体向部分逐个击破，先来看看计算机的总体架构和程序运行的原理。
对于计算机，我们最关心的是两个硬件，一个是CPU，一个是内存。它们通过计算机的总线连接在一起，这样CPU就可以读取内存中的数据和程序，并把数据写回内存。而CPU内部还会细分成更多的成分，包括高速缓存、寄存器和各种处理单元。
那在这种硬件环境下，程序是怎么运行起来的呢？通常，CPU上会有个寄存器，叫做PC计数器。通过PC计数器的值，CPU能够计算出下一条需要执行的代码的地址，然后读取这个代码并执行（根据不同的CPU架构，PC计数器中的值可能不是直接的内存地址，而需要进行一点转换和计算）。通常情况下，程序都是顺序执行的。但当遇到跳转指令时，PC计数器就会指向新的代码地址，从新的地址开始执行代码。
除了跳转指令会改变PC计数器的值，CPU的异常机制也会改变PC计数器的值，跳转到异常处理程序，处理完毕之后再回来。CPU的异常机制是CPU架构设计的一个重要组成部分。典型的异常是由硬件触发的中断。我们每次敲打键盘，都会触发一个中断，处理完毕以后会再接着运行原来的程序。也有的时候，中断可以由软件触发，比如当你Debug程序的时候，你可以控制着程序一条一条代码的执行，这也是利用了中断机制。
了解了程序总体的运行原理后，我们再通过一段代码的执行过程，深入了解一下其中的机理，并了解各个硬件成分是如何协同工作的。
一段代码的执行过程这段示例代码是三条汇编代码，你先看一下：
movl -4(%rbp), %eax addl $10, %eax movl %eax, -r(%rbp) 这三条代码都采用了统一的格式：操作码的助记符、源操作数和目标操作数。注意，不同CPU的指令集和不同的汇编器，会采用不同的格式，我这里只是举个例子。
这三条代码的意思也很简单，我来解释一下：
第1条是一个movl指令，movl能够把一个整数从一个地方拷贝到另一个地方。这里是从一个内存地址取出一个值，放到%eax寄存器，而这个内存地址是%rpb寄存器的值减去4； 第2条是一个addl指令，它把常数10加到%eax寄存器上； 第3条又是一个movl指令，这次是把%eax寄存器的值又写回第一行的那个内存地址。 理解了这三条代码的意思以后，我们来看看具体执行的时候都发生了些什么。
第一步，CPU读入第一行代码。
我们这三条代码都是存在内存里的。CPU会根据PC计数器的值，从内存里把第一条代码读进CPU里。
这里你要注意，我们刚才使用了汇编代码来表示程序，但内存里保存的，实际上是机器码。汇编代码通过汇编器可以转换成机器码。
在设计CPU的指令集的时候，我们会设计机器码的格式。比如，下图是我在RISC-V手册中找到的一张图，描述了RISC-V指令的几种编码方式。你能看到，每条指令占用32位，也就是一个整数的长度。其中opcode的意思是操作码，占用低7位，rs是源寄存器器，rd的意思是目的寄存器，imm是立即数，也就是常数。
这些指令被读入内存以后，会有一个解码的过程，也就是把操作码、源操作数、目标操作数这些信息从一条指令里拆解出来，用于后续的处理。这个解码的功能，是由CPU内部的一个功能单元完成的。
那么CPU是直接从内存中读入代码的吗？
不是的，其实CPU是从高速缓存中读入代码和数据的。通常代码和数据的高速缓存是分开的，分别叫做Instruction Cache和Data Cache。只有高速缓存中没有这些代码或数据的时候，才会从内存中读取。
高速缓存是内存和CPU之间的缓冲区。高速缓存的读写速度比内存快，能够减少CPU在读写内存过程中的等待时间。当CPU从内存里读一个数据的时候，它其实是从高速缓存中读到的；如果在高速缓存里没有，术语叫做没有命中，CPU会把这个数据旁白的一批数据都读到高速缓存，这样再读下一个数据的时候，又可以直接从高速缓存中读取了。
高速缓存可能分多级，比如叫做L1~L3，速度从高到底，容量则反过来，从低到高。并且，一般较低速的缓存是多个核共享的，而更高速的是每个核独享的。
那高速缓存的相关知识对我们实现计算机语言有什么帮助呢？
有一类优化技术，是提高程序数据的局部性，也就是把代码前后需要用到的数据，尽量都聚集在一起，这样便于一次性地加载到高速缓存。在读取下一个数据的时候，就不需要访问内存了，直接从高速缓存就可以获得了，从而提高了系统的性能。这就是数据局部性的好处。
从这个角度看，你回想一下，上一节课我们就是把栈桢的数据都放在一个连续的内存块里，也是在不经意间提高了数据的局部性。
不过，高速缓存也会带来一些麻烦。比如，当两个内核都去读写同一个内存数据的时候，它们各自使用自己的高速缓存，可能就会出现数据不一致的情况。所以，如果我们在语言层面上支持并发编程的特性，就像Java那样，那么在生成指令时就要保证数据的一致性。如果你想具体了解一下这些技术，可以再去看一下《编译原理实战课》。
理解了高速缓存以后，我们接着继续看第一条指令的执行过程。在这条指令里，目标操作数，也就是数据加载的目的地是一个寄存器。那我们再了解一下寄存器。
寄存器是CPU做运算的操作区。在典型的情况下，CPU都是把数据加载到寄存器，然后再在寄存器里做各种运算。
相比高速缓存来说，寄存器的读写速度更高，大约是内存的100倍。整体来说，寄存器、高速缓存和内存的读写速度是寄存器&amp;gt;高速缓存&amp;gt;内存。
在CPU的设计中，有些寄存器是有特定用途的，比如PC计数器用于计算代码地址，EFlags寄存器用于保存一些运算结果产生的状态等。
还有一些寄存器叫做通用寄存器，它们可以被我们的代码所使用，进行加减乘除等各种计算。在把程序编译成汇编代码的时候，我们要尽量去利用这些通用寄存器来运算。但如果寄存器不够用，就需要临时保存到内存中，把寄存器的空间腾出来。
好，现在我们对寄存器也有了基本的了解了，我们接着往下分析。在第一条指令里，还有一个源操作数，是-4(%rbp)，这代表了一个内存地址。CPU需要从内存地址里获取数据。
那CPU是如何从内存里获取数据的呢？这个过程其实比较复杂，是由多个步骤构成的，并不是一蹴而就的。
首先，CPU需要计算出内存地址。也就是从%rbp寄存器中取出现在的值，再减去4，得到要访问的数据的内存地址。这个地址计算的过程，通常也是由CPU内部一个单独的功能模块负责的。
那是不是从这个地址读取数据就行了呢？还不行，因为这个地址可能是个逻辑地址。现代CPU一般都有一个MMU单元。MMU是Memory Management Unit的缩写，也就是内存管理单元。它提供了虚拟内存管理的功能。也就是说，我们刚才计算出来的地址可能只是个逻辑地址，要经过MMU的翻译，才能获得物理的内存地址。
要实现完整的虚拟内存管理功能，还需要操作系统的支持，这个我们在下一节课还会探讨。
那现在，CPU终于得到了物理内存的地址。那么它会先从高速缓存中读数据，如果高速缓存中没有这个数据，才从内存加载。
你看，一个简单的内存访问功能，竟然涉及到这么多的细节。
解析完毕第一条指令之后，你大致也能理解第二条、第三条指令是如何执行的了。其中第二条指令，是做了一个加法运算，在这个过程中，会用到CPU内部的另一个功能单元：ALU，也就是算术逻辑运算单元。
到这里为止，我们已经提到了计算机内部的多个功能单元了，所以我们再把CPU内部的功能单元和流水线功能给总结一下。
CPU内部的功能单元和流水线对于CPU内部的结构，我们已经了解了高速缓存和寄存器。除此之外，CPU内部还包含了很多的功能单元，每个单元负责不同的功能。比如，有的单元负责获取指令，有的单元负责对指令译码，有的单元负责真正的运算，有的单元负责读取数据，有的单元负责写入数据，等等。
在阅读CPU的手册的时候，你会看到关于这个CPU的内部结构的一些信息，这个内部结构也被叫做微架构。你可以多看看这些图，即使你不能完全理解其中每个单元的含义，这也会有助于你理解CPU到底是如何运作的。下面这张图是我从Intel的手册中看到的Ice Lake型号的CPU的微架构的示意图：
我稍微解释一下这个微架构。你会看到，在图的左上角，指令高速缓存中的指令会被解码，解码后变成微指令。这里就涉及到了X86设计上的一些细节。X86使用的指令属于复杂指令集（CISC），CISC会针对特定的功能来设计一些指令，所以指令的执行效率会比较高，就像我们为了某个应用目的专门写一个程序来处理那样。
但复杂指令集也有坏处，就是指令的条数太多了，导致硬件设计会变得复杂，也不容易利用我们下面将要讲到的流水线的优势。所以，其实现代使用CISC的CPU，在内部设计上也借鉴了RISC的优点，把复杂的指令拆解成了简单的指令，或者叫做微指令，也就是图中的uop。
微指令会排成队列去执行任务，它们会到达一个调度器，由调度器调度不同的处理单元去完成不同的任务。调度器通过不同的端口（Port）来调度任务，不同的功能单元则在端口上接收任务。有的单元负责保存数据，有的单元负责加载数据，这些单元都会接到高速缓存上。还有几个端口是专门做计算的。不同的计算任务又分别由不同的计算单元承担，比如ALU是做算术运算的，LEA是做地址运算的，FMA是做浮点数运算的，等等。
不过，不同的CPU，其内部功能单元的划分是不同的。但总的来说，在执行一条指令的时候，CPU内部实际是多个单元按顺序去处理的，这被叫做指令流水线。不同CPU的流水线设计是不同的，有的分5个步骤，有的分成8个、10个甚至更多个步骤。
采用流水线技术最大的好处，就是我们不用等一条指令完全执行完毕，才去执行第二条指令。假设每条指令需要用到5个功能单元，分成5个步骤。那么在第一条指令的第一个步骤执行完毕以后，第一个功能单元就空出来了，就可以处理第二条指令了。总的来说，相当于有5条指令在并行运行。
当然了，实际上的执行过程并没有这么理想，因为不同的指令会用到不同的功能单元。比如上面示例程序的三条指令中，addl指令用到了ALU单元，而其他两条指令就没用到。而且，每个功能单元所需要的时钟周期也是不同的。所以，各条指令在执行过程中就会出现等待的情况。</description></item><item><title>13｜物理机上程序运行的软件环境是怎么样的？</title><link>https://artisanbox.github.io/3/15/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/15/</guid><description>你好，我是宫文学。
上一节课，我们主要讨论了程序运行的硬件环境。在某些编程场景下（比如嵌入式编程），我们的语言需要直接跑在裸设备上。所以，你要能够理解在裸设备上运行某个语言的程序所需要的技术。
不过，现代语言大部分情况下都运行在某个操作系统里，操作系统为语言提供了基础的运行环境，比如定义了可执行文件的格式、程序在内存中的布局、内存管理机制，还有并发机制等等。计算机语言需要跟操作系统紧密配合，才能更好地运行。
今天这节课，我们就来讨论一下操作系统中与计算机语言有关的那些知识点，包括内存管理、任务管理和ABI，为进一步实现我们的计算机语言打下良好的基础。
首先我们来看看操作系统的内存管理功能和程序的关系。
内存管理操作系统的一个重要功能就是管理内存，它会把内存虚拟化，并进行内存访问的权限管理。
那什么是虚拟化呢？
虚拟化就是让每个进程都有一个自己可以用的寻址空间，不过这些地址是假的地址。但就这些假地址，我们通过指令发给CPU，CPU也是认的。因为CPU中有一个内存管理单元，缩写是MMU，它能够根据这个逻辑地址，计算出在内存里真实的物理地址。MMU还可以跟操作系统配合，设置每个内存页面的权限，包括是否可读、可写和可执行。
这种逻辑地址与物理地址转换的功能，对我们做编译很有用。我们的程序编译成目标代码的时候，里面的每个函数、常量和全局变量的地址，都是确定的。这样，在操作系统加载了可执行程序以后，就可以正确地调用每个函数，访问每个数据了。
如果没有这个逻辑地址的功能，那运行多个程序就困难了。我们要保证每个程序使用的地址都互相不冲突才行，否则大家就乱了套了。在不使用操作系统的编程领域（比如某些嵌入式编程），重点就要解决好这些问题。
在虚拟化机制下，只有你用到某个地址，操作系统才会为这个地址分配真实的物理内存。这些物理内存一般划分成页来管理，MMU会根据这些分页信息把逻辑地址转换成物理地址。
这里我们横向延展一下，我们在第11节课说过，在栈里申请内存的时候很简单，只需要移动一下栈顶指针就行了，其实这个内部机制和我们上面说的虚拟化也是有关的。
在X64架构下，栈顶指针使用的是rsp寄存器。但其实，这时候并没有真正分配内存，你只是改变了寄存器的值而已。但如果你访问栈里的某个地址，而且这个地址又没有被分配物理的内存页，那么CPU在访问内存的时候就会知道这里出错了。它就会触发一个缺页中断，跳转到中断处理程序，去分配页面。分配完毕以后，又跳回原来的程序接着执行，我们的程序并不知道背后发生了这么多的事情。
说到中断，我再额外跟你补充一点。CPU在处理中断的时候，要保护当前的现场，比如各个寄存器的状态。否则，如果各个寄存器的值被弄乱了，原来的程序就没法执行了。然后在返回原来的程序的时候，CPU要恢复现场。整个过程对我们的程序是透明的。
所以说，这个rsp只是起到一个标记作用，是我们的程序跟操作系统之间的一个约定。我们只要修改了rsp里的值，操作系统就要保证给我们提供足够的内存。如果你违背了这个约定去乱访问一些地址，在MMU和操作系统的配合下，也会被识别出来，就会报内存访问的错误。
既然这只是个约定，那么有的操作系统就比较为程序着想了，它规定你可以访问栈顶之外的一定范围内的内存。比如，Linux和大多数类Unix的系统都遵循System V AMD64 ABI，它规定可以访问栈顶之外的128个字节范围内的内存。
这有什么好处呢？好处是，对于程序中的叶子函数，也就是这个函数没有调用其他函数，并且它所使用的数据不会超过128个字节的情况，我们根本不需要去建立栈桢，也就省去了把栈顶指针的值保存到内存，修改栈顶指针，最后再从内存中恢复栈顶指针这一系列操作，这样就节省了大量的内存读写时间，让系统性能得到优化。
在堆中申请内存也是一样，也不是真实的分配，只是提供了一些标记信息，之后可供MMU使用而已。
好了，关于从栈和堆里申请内存的延伸就到这里，我们回归主线，继续来看虚拟化机制带来的结果。简单的说，虚拟化机制，可以让运行中的各种程序，使用相同的逻辑地址，但实际上对应的是不同的物理地址。这样各个程序加载到内存后，就都可以使用标准的内存布局。
那一个可执行程序在内存中的布局情况是怎样的呢？我们用一个C语言的程序的例子来分析一下。
在Linux或macOS系统中，一个C语言的程序加载到内存以后，它的内存布局大概是下面的样子：
你可以看到，其中代码段（.text）和数据段（包括.data和.bss）是从可执行文件直接加载进内存的。可执行文件中提前计算好的函数、常量和全局变量的地址，也就变成了内存中的地址。
另外两个重要的区域是栈和堆。栈是从高地址向低地址延伸的，而堆则是从低地址向高地址延伸的。
但是，在不同的操作系统中，上图中每个部分的具体地址都是不大相同的，比如，macOS和Linux的就不同。不过，你可以写个程序，打印出不同区域中的地址。我写了个示例程序address.c，你可以参考一下，这里你要好好琢磨一下示例代码中每个地址是如何获取的。
另外，我是在macOS上运行的，如果你用的是不同的操作系统，也可以运行一下，看看打印出来的地址跟我的有什么区别。
这个程序是这样的：
#include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; //全局变量 int global_a = 10; char * global_b = &amp;quot;hello&amp;quot;;
int main(int argc, char** argv){ printf(&amp;quot;命令行参数/&amp;amp;quot;address&amp;amp;quot;的地址:\t0x%12lX\n&amp;quot;, (size_t)argv[0]); printf(&amp;quot;命令行参数/argv数组的地址: \t0x%12lX\n&amp;quot;, (size_t)argv);
printf(&amp;amp;quot;栈/参数argc的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;argc); printf(&amp;amp;quot;栈/参数argv的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;argv); int local_a = 20; printf(&amp;amp;quot;栈/local_a的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;local_a); int * local_b = (int*)malloc(sizeof(int)); printf(&amp;amp;quot;栈/local_b的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;local_b); printf(&amp;amp;quot;堆/local_b指向的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)local_b); free(local_b); printf(&amp;amp;quot;data段/global_b的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;global_b); printf(&amp;amp;quot;data段/global_a的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)&amp;amp;amp;global_a); printf(&amp;amp;quot;text段/\&amp;amp;quot;hello\&amp;amp;quot;的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)global_b); printf(&amp;amp;quot;text段/main函数的地址: \t0x%12lX\n&amp;amp;quot;, (size_t)main); }</description></item><item><title>14｜汇编代码学习（一）：熟悉CPU架构和指令集</title><link>https://artisanbox.github.io/3/16/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/16/</guid><description>你好，我是宫文学。
经过了上一节课的学习，你已经对物理机的运行期机制有了一定的了解。其中最重要的知识点就是，为了让一个程序运行起来，硬件架构、操作系统和计算机语言分别起到了什么作用？对这些知识的深入理解，是让你进入高手行列的关键。
接下来，就让我们把程序编译成汇编代码，从而生成在物理机上运行的可执行程序吧！
慢着，不要太着急。为了让你打下更好的基础，我决定再拿出一节课来，带你了解一下CPU架构和指令集，特别是ARM和X86这两种使用最广泛的CPU架构，为你学习汇编语言打下良好的基础。
首先，我们讨论一下什么是CPU架构，以及它对学习汇编语言的作用。
掌握汇编语言的关键，是了解CPU架构提到汇编语言，很多同学都会觉得很高深、很难学。其实这是个误解，汇编语言并不难掌握。
为什么这么说呢？其实前面在实现虚拟机的时候，我们已经接触了栈机的字节码。你觉得它难吗？JVM的字节码理论上不会超过128条，而我们通过前面几节课已经了解了其中的好几十条指令，并且已经让他们顺利地运转起来了。
而且，汇编代码作为物理机的指令，也不可能有多么复杂。因为CPU的设计，就是要去快速地执行一条条简单的指令，所以这些指令不可能像高级语言那样充满复杂的语义。
我们可以把学习汇编语言跟学习高级语言做一下类比。如果你接触过多门计算机语言，很快就能找到这些计算机语言的相似性，比如都有基础数据类型、都支持加减乘除等各种运算、都支持各种表达式和语句等等。抓住这些基本规律以后，学习一门新语言的速度会很快。
汇编语言也是一样的。不同的CPU有不同的指令集，但它们的指令的格式有一些共性，比如都包含操作码的助记符和操作数，而操作数通常也都包含立即数、寄存器和内存地址这三个类别。它们也都包含数据处理、内存读写、跳转、子过程调用等几种大类的指令。所以，你也可以很快掌握这些规律或模式，做到触类旁通，游刃有余。
说了那么多，那么学习汇编语言的关键是什么呢？
由于汇编语言是跟具体的CPU打交道的，所以不同的CPU架构，它们的汇编语言就会有所差别。如果你能够深刻了解某款CPU的架构，自然也就会为它编写汇编代码了。
这里提到了一个词，架构。所谓架构，是指一个处理器的功能规范，定义了CPU在什么情况下会产生什么行为。你也可以把它理解成软件和硬件之间的一个桥梁，规定了硬件如何提供功能被软件所调用。所以，如果你要搞编译技术，就必须要了解目标CPU的架构。
我把CPU架构里的内容整合在这张表里，你可以保存起来：
看上去，要深入了解一个CPU架构，涉及的知识还蛮多的。不过，作为初学者，我们最重要的是关注两个方面就行了：指令集和寄存器集，因为它们跟汇编代码的关系最密切。
那么如何了解一个CPU的架构呢？正如我在第12节课说的那样，其实最重要的方式，就是阅读CPU的手册。
那么这节课我们就分析两种主流的CPU架构，看看能获得哪些知识点。首先我们就来看一下ARM架构的CPU的特点，它是目前大多数智能手机所采用的CPU。
了解ARM架构ARM处理器是ARM公司推出的一系列处理器的名称。ARMv8是它比较新的架构，当前大多数高端智能手机都是采用这个架构。了解这个架构的方法呢，当然是下载ARMv8的手册。
不过这本手册比较厚，有8000多页。为了加速你的理解，我挑其中最有用、跟编写汇编代码最相关的几个知识点跟你聊聊。
首先，ARMv8支持32位和64位运行模式，分别叫做AArch32和AArch64。在64位模式下，它的指令集叫做A64。
接着，我们看看ARMv8的寄存器。在AArch64架构下，它的寄存器有下面这几个（参见手册的B1.2.1部分）。
R0-R30：是31个通用寄存器。当它们被用于64位计算或32位计算的时候，分别被叫做X0-X30（X表示64位），以及W0-W30（W是Word的意思，表示32位）。这31个处理器是我们用做数据处理的主力。 SP寄存器：64位的栈指针寄存器，用于指向栈顶的地址。 PC寄存器：64位的程序代码寄存器，PC是Program Code的意思。这个寄存器记录了内存中当前指令的地址，CPU会从这个地址读取指令并执行。当程序执行跳转指令、进入异常或退出异常的时候，这个寄存器的值会被自动修改。 另外，还有一组寄存器是用于处理浮点数运算和矢量计算的，你可以去官方手册看看。 这些就是我们的汇编代码中会涉及到的寄存器，还有一些寄存器是系统级的寄存器，我们平常的应用代码用不上，就先不管了。
谈到寄存器，我插个话题。我注意到，你如果在网上搜索某个CPU架构的文章，往往得到的是模棱两可的、甚至是错误的信息，你千万要注意不要被它们误导了。
比如，我看到有的文章说在某个架构的CPU中，哪些寄存器是用来放返回值的，哪些寄存器是用来传参数的，而哪些寄存器又分别是由调用者或被调用者保护的，等等，还配了图做说明。
但如果你对调用约定或ABI的概念有所了解的话马上就会知道，这些其实都是软件层面上的一些约定，不是CPU架构层面上的规定。如果你还想了解得更具体一些，可以参考涉及到ARM架构的一些ABI规范文档，特别是其中的“Procedure Call Standard for the Arm® 64-bit”，这篇文档就规定了如何使用这些通用寄存器等信息。但作为语言的作者，你其实可以设计自己的ABI，你拥有更大的自由度。
与寄存器相关的一个概念，叫做Process State，或者PSTATE，它是CPU在执行指令时形成的一些状态信息，这些状态信息在物理层面是保存在一些特殊目的寄存器里。
PSTATE有什么用呢？比如，它的用途之一是辅助跳转指令的运行。当我们执行一个条件跳转指令之前，会先执行一个比较指令，这个比较指令就会设置某个状态信息，而后续的跳转指令就可以基于这个状态信息进行正确的跳转了。
此外，PSTATE还可以用于判断算术运算是否溢出、是否需要进位等等。
最后，我们终于谈到CPU架构中的主角，指令集了。你先看一下A64指令集中的一些常见的指令：
你看这些指令，是不是跟前面学过的Java字节码的指令集有很多相似之处？我们来比较一下看，上面的指令大概可以分为四组。
第一组指令，是加减乘除等算术运算的指令。
回忆一下，在我们之前学栈机的时候，是不是也有这些运算指令？但栈机和寄存器机的指令有一些差别。栈机的运算指令，是不需要带操作数的，因为操作数已经在操作数栈里。这几个指令会从栈顶取出两个操作数，做完加减乘除运算后，再放回栈顶。这样，下一条指令就可以把这个值作为操作数，继续进行计算。
但寄存器机上没有操作数栈，典型的寄存器机，所有运算都发生在寄存器里。我们来看看下面这个示例程序：
int foo(int a){ return a + 10; } 你可以用下面这个命令生成ARM64指令集的汇编代码：
clang -arch arm64 -S&amp;nbsp; foo.c -o foo_arm64.s -O2 汇编代码的主要部分是下面这几行：
_foo: ; @foo add w0, w0, #10 ; =10 ret 其中“add w0, w0, #10”的意思，是把w0寄存器的值加上10，结果仍然放到w0。</description></item><item><title>15｜汇编语言学习（二）：熟悉X86汇编代码</title><link>https://artisanbox.github.io/3/17/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/17/</guid><description>你好，我是宫文学。
上一节课，在开始写汇编代码之前，我先带着你在CPU架构方面做了一些基础的铺垫工作。我希望能让你有个正确的认知：其实汇编语言的语法等层面的知识是很容易掌握的。但要真正学懂汇编语言，关键还是要深入了解CPU架构。
今天这一节课，我们会再进一步，特别针对X86汇编代码来近距离分析一下。我会带你吃透一个汇编程序的例子，在这个过程中，你会获得关于汇编程序构成、指令构成、内存访问方式、栈桢维护，以及汇编代码优化等方面的知识点。掌握这些知识点之后，我们后面生成汇编代码的工作就会顺畅很多了！
好了，我们开始第一步，通过实际的示例程序，看看X86的汇编代码是什么样子的。
学习编译器生成的汇编代码按我个人的经验来说，学习汇编最快的方法，就是让别的编译器生成汇编代码给我们看。
比如，你可以用C语言写出表达式计算、函数调用、条件分支等不同的逻辑，然后让C语言的编译器编译一下，就知道这些逻辑对应的汇编代码是什么样子了，而且你还可以分析每条代码的作用。这样看多了、分析多了以后，你自然就会对汇编语言越来越熟悉，也敢自己上手写了。
我们还是采用上一节课那个用C语言写的示例函数foo，我们让这个函数接受一个整型的参数，把它加上10以后返回：
int foo(int a){ return a+10; } 接着，再输入下面的clang或gcc命令：
clang -S foo.c -o foo.s 或 gcc -S foo.c -o foo.s 然后我们用一个文本编辑器打开foo.s，你就会看到下面这些汇编代码：
.section __TEXT,__text,regular,pure_instructions .build_version macos, 11, 0 sdk_version 11, 3 .globl _foo ## -- Begin function foo .p2align 4, 0x90 _foo: ## @foo .cfi_startproc ## %bb.0: pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset %rbp, -16 movq %rsp, %rbp .cfi_def_cfa_register %rbp movl %edi, -4(%rbp) movl -4(%rbp), %eax addl $10, %eax popq %rbp retq .</description></item><item><title>16｜生成本地代码第1关：先把基础搭好</title><link>https://artisanbox.github.io/3/18/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/18/</guid><description>你好，我是宫文学。
到目前为止，我们已经初步了解了CPU架构和X86汇编代码的相关知识点，为我们接下来的让编译器生成汇编代码的工作打下了不错的基础。
不过，我总是相信最好的学习方法就是实践。因为，只有你自己动手尝试过用编译器生成汇编代码，你才会对CPU架构和汇编的知识有更深刻的了解，总之，遇到问题，解决问题就好了。
所以呢，今天这节课，我们就开始着手生成X86汇编代码。我会带你分析生成汇编代码的算法思路，理解寄存器机与栈机在生成代码上的差别，以及了解如何在内存里表示汇编代码。
看上去工作有点多，不着急，我们一步步来。那首先，我们就通过一个实例，让你对生成汇编代码的算法思路有一个直觉上的认知。
生成汇编代码的算法思路在前面的课里，我们已经学会了如何生成字节码。你也知道了，基本上，我们只需要通过遍历AST就能生成栈机的字节码。
但当时我们也说过，为栈机生成代码是比较简单的，比寄存器机要简单，这具体是为什么呢？
你可以保留这个疑问，先来跟我分析一个例子，看看我们要怎么把它转化成汇编代码，以及在这个过程中会遇到什么问题：
function foo(a:number, b:number):number{ let c = a+b+10; return a+c; } 你可以看到，这个函数有两个参数。为了提高程序的运行效率，在参数数量不多的情况下，参数通常都是通过寄存器传递的，我们暂且把传递这两个参数的两个寄存器叫做r1和r2。
接下来，我们要执行运算，也就是a+b+10。这该怎么做呢？这里你要注意的是，在生成指令的时候，我们通常不能直接把b的值加到a上，也就是从r2加到r1上。因为这样就破坏了r1原来的值，而这个值后面的代码有可能用到。
所以呢，我们这里就要生成两条指令。第一条指令，是把a的值从r1拷贝到一个新的寄存器r3；第2条指令，是把b的值从r2加到r3上，最终结果也就保存到了r3。
mov r1, r3 add r2, r3 之后，我们要再加10。这个时候，我们可以放心地把10加到r3上。因为r3是我们自己生成的一个临时变量，我们可以确保其他代码不会用到它，所以我们可以放心地改变它的值。
add 10, r3 接着，我们要把表达式a+b+10的值赋给本地变量c。对于本地变量，我们也是尽可能地把它放到寄存器里。不过呢，由于r3作为临时变量的任务已经圆满完成了，所以这个时候，我们可以用r3来表示c的值，这下我们就节省了一个寄存器。因此，这里我们不需要添加任何新的指令。
再接着，我们要计算a+c的值。为了不影响已有寄存器的值，我们又使用了一个新的寄存器r4，用来保存计算结果：
mov r1, r4 add r3, r4 最后，我们要把计算结果返回。通常，根据调用约定，返回值也是放在某个寄存器里的。我们这里假设这个寄存器是r0。所以，我们可以用这两条指令返回：
mov r4, r0 ret 到此为止，我们就已经成功地为foo函数生成了汇编代码。当然，这个汇编代码只是示意性的、逻辑性的，如果要让它成为真正可用的汇编代码，还要做一些调整，比如把寄存器的名称换成正式的物理寄存器的名称，如rax等。我这样叙述，是为了尽量保持简洁，避免你过早陷入到具体CPU架构的细节中去，增加认知负担。
好了，回顾我们的工作成果，你可能很快会发现一个问题：这么小的一个程序就占据了4个寄存器，如果我再多加点参数或者本地变量，那寄存器岂不会很快就会被用光？
这个担心是很有道理的，你可以先看看下面的例子：
function foo(a:number, b:number, d:number, f:number):number{ let c = a+b+10; let g = ... let h = ... return g+h; } 在这个例子中，参数a、b、d、f和本地变量c、g、h，都会额外占用一个寄存器，并且每个变量的计算过程都有可能消耗额外的寄存器来保存临时变量，所以寄存器很快就会被用光。
到这里，你可能已经体会到了为什么给寄存器机生成代码会更难了。在栈机里，根本没有这样的问题，因为我们可以用操作数栈来保存中间结果，而操作数栈的大小是没有限制的。</description></item><item><title>17｜生成本地代码第2关：变量存储、函数调用和栈帧维护</title><link>https://artisanbox.github.io/3/19/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/19/</guid><description>你好，我是宫文学。
在上一节课里，我们已经初步生成了汇编代码和可执行文件。不过，很多技术细节我还没有来得及给你介绍，而且我们支持的语言特性也比较简单。
那么，这一节课，我就来给你补上这些技术细节。比如，我们要如何把逻辑寄存器映射到物理寄存器或内存地址、如何管理栈桢，以及如何让程序符合调用约定等等。
好了，我们开始吧。先让我们解决逻辑寄存器的映射问题，这其中涉及一个简单的寄存器分配算法。
给变量分配物理寄存器或内存在上一节课，我们在生成汇编代码的时候，给参数、本地变量和临时变量使用的都是逻辑寄存器，也就是只保存了变量的下标。那么我们要怎么把这些逻辑寄存器对应到物理的存储方式上来呢？
我们还是先来梳理一下实现思路吧。
其实，我们接下来要实现的寄存器分配算法，是一个比较初级的算法。你如果用clang或gcc把一个C语言的文件编译成汇编代码，并且不带-O1、-O2这样的优化选项，生成出来的汇编代码就是采用了类似的寄存器分配算法。现在我们就来看看这种汇编代码在实际存储变量上的特点。
首先，程序的参数都被保存到了内存里。具体是怎么来保存的呢？你可以先看看示例程序param.c：
void println(int a); int foo(int p1, int p2, int p3, int p4, int p5, int p6, int p7, int p8){ int x1 = p1p2; int x2 = p3p4; return x1 + x2 + p5p6 + p7p8; }
int main(){ int a = 10; int b = 12; int c = ab + foo(a,b,1,2,3,4,5,6) + foo(b,a,7,8,9,10,11,12); println(c); return 0; } &amp;lt;!&amp;ndash; [[[read_end]]] &amp;ndash;&amp;gt;这个示例程序所对应的汇编代码是param.</description></item><item><title>18｜生成本地代码第3关：实现完整的功能</title><link>https://artisanbox.github.io/3/20/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/20/</guid><description>你好，我是宫文学。
到目前为止，我们已经把挑战生成本地代码的过程中会遇到的各种难点都解决了，也就是说，我们已经实现基本的寄存器分配算法，并维护好了栈桢。在这个基础上，我们只需要再实现其他的语法特性就行了。
所以，在今天这节课，我们要让编译器支持条件语句和循环语句。这样的话，我们就可以为前面一直在使用的一些例子，比如生成斐波那契数列的程序，生成本地代码了。然后，我们可以再比较一次不同运行时机制下的性能表现。
还记得吗？我们在前面已经分别使用了AST解释器、基于JavaScript的虚拟机和基于C语言的虚拟机来生成斐波那契数列。现在我们就看看用我们自己生成的本地代码，性能上是否会有巨大的变化。
在这个过程中，我们还会再次认识CFG这种数据结构，也会考察一下如何支持一元运算，让我们的语言特性更加丰富。
那首先我们来看一下，如何实现if语句和for循环语句。
支持if语句和for循环语句在前面的课程中，我们曾经练习过为if语句和for循环语句生成字节码。不知道你还记不记得，其中的难点就是生成跳转指令。在今天这节课，我们会完成类似的任务，但采用的是一个稍微不同的方法。
我们还是先来研究一下if语句，看看针对if语句，编译器需要生成什么代码。我们采用下面一个C语言的示例程序，更详细的代码你可以参见代码库中的if.c：
int foo(int a){ if (a &amp;gt; 10) return a + 8; else return a - 8; } C语言的编译器针对这段示例程序，会生成下面的汇编代码（参见代码库中的if.s），我对汇编代码进行了整理，并添加了注释。
这段汇编代码是未经优化的。不过，我相信你经过前面课程的训练，应该可以看出来很多可以用手工优化的地方。不过现在我们关注的重点是跳转指令，所以你可以重点看一下代码中的cmpl指令、jle指令和jmp指令。
我们现在来分析一下。第一个cmpl指令的作用是比较两个整数的大小。在这个例子中，是比较a和10的大小，计算结果会设置到eflags寄存器中相应的标志位。
第二个jle指令，它的作用是根据eflags寄存器中标志位决定是否进行跳转，如果发现是小于等于的结果，那么就进行跳转，这里是跳转到else块。如果是大于呢，就会顺着执行下面的指令，也就是if块的内容。
最后我们来看jmp指令，这是无条件跳转指令，相当于我们前面学过的字节码中的goto指令。
认识了这三个指令以后，我们就知道程序的跳转逻辑了。在这个C语言的示例程序中，一共有四个基本块，我把它们之间的跳转关系画成了图，可以更加直观一些：
在分析清楚了整个思路以后，为if语句生成本地代码的逻辑也就很清楚了，我们现在就动手吧。完整的代码你可以查看代码库里的visitIfStmt方法，我这里挑重点和你分析一下。
首先，我们要生成4个基本块：
//条件 let bbCondition = this.getCurrentBB(); let compOprand = this.visit(ifStmt.condition) as Oprand; //if块 let bbIfBlcok = this.newBlock(); this.visit(ifStmt.stmt);
//else块 let bbElseBlock:BasicBlock|null = null if (ifStmt.elseStmt != null){ bbElseBlock = this.newBlock(); this.visit(ifStmt.elseStmt); }
//最后，要新建一个基本块,用于If后面的语句。 let bbFollowing = this.newBlock(); 接着，我们要添加跳转指令，在4个基本块之间建立正确的跳转关系。这其中，最关键的就是我们怎么来为基本块0，也就是if条件所在的基本块生成跳转指令。</description></item><item><title>19｜怎么实现一个更好的寄存器分配算法：原理篇</title><link>https://artisanbox.github.io/3/21/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/21/</guid><description>你好，我是宫文学。
到目前为止，我们的语言已经能够生成机器码了，并且性能确实还挺高的。不过我们也知道，现在我们采用的寄存器分配算法呀，还是很初级的。
那这个初级的寄存器分配算法会遇到什么问题呢？我们还有更优化的分配寄存器的思路吗？
当然是有的。接下来的这两节课，我们就会来回答这两个问题，我会带你从原理到实操，理解和实现一个更好的算法，叫做线性扫描算法，让寄存器的分配获得更好的优化效果。
首先，我们来分析一下当前寄存器分配算法的局限性。
初级算法的不足在前两节课中，我们实现了一个初级的寄存器分配算法。这个算法的特点呢，是主要的数据都保存在内存的栈桢中，包括参数和本地变量。而临时变量，则是映射到寄存器，从而保证各类运算指令的合法性，因为像加减乘数这种运算，不能两个操作数都是内存地址。
这个算法有什么不足呢？你可以暂停一会儿，先自己想一下，大概有两点。
我们现在来揭晓答案。
第一点不足在生成的代码性能上。
你知道，我们做编译的目标，是要让生成的代码的性能最高，但这个算法在这方面显然是不合格的。因为参数和本地变量都是从内存中访问的，这会导致代码的性能大大降低。
第二点不足就在对需要Caller保护的寄存器的处理上。
在上一节课后面的性能比拼中，我们发现，其实我们自己的语言编译生成的可执行程序，它的性能还略低于C语言生成的、同样未经优化的版本，按理说它们的性能应该是一样的才对。
深究原因，还是在调用函数的时候，程序需要保存那些需要Caller保护的寄存器。而我们的算法，多保护了一些其实已经不需要被保护的寄存器，从而拖累了性能。
不过，这两个方面的局限性，我们通过今天的算法，都可以很好地解决。我们现在就通过一个示例程序来找一下更好的寄存器分配算法的思路。
寄存器分配算法的改进思路你先看看我们下面这个示例程序：
function foo(p1:number,p2:number,p3:number,p4:number,p5:number,p6:number){ let x7 = p1; let x8 = p2; let x9 = p3; let x10 = p4; let x11 = p5; let x12 = p6 + x7 + x8 + x9 + x10 + x11; let sum = x12; for (let i:number = 0; i&amp;amp;lt; 10000; i++){ sum += i; } return sum; } 你看这里有p1~p6共6个参数，还有x7~x12这6个本地变量。但在变量x12的计算过程中，我们还需要用到1个临时变量t1。接下来是一个循环语句，这个语句又涉及到sum和i两个本地变量。</description></item><item><title>20｜怎么实现一个更好的寄存器分配算法：实现篇</title><link>https://artisanbox.github.io/3/22/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/22/</guid><description>你好，我是宫文学。
在上一节课，我们已经介绍了寄存器分配算法的原理。不过呢，我们这门课，不是停留在对原理的理解上就够了，还要把它具体实现出来才行。在实现的过程中，你会发现有不少实际的具体问题要去解决。而你一旦解决好了它们，你对寄存器分配相关原理的理解也会变得更加通透和深入。
所以，今天这一节课，我就会带你具体实现寄存器分配算法。在这个过程中，你会解决这些具体的技术问题：
首先，我们会了解如何基于我们现在的LIR来具体实现变量活跃性分析。特别是，当程序中存在多个基本块的时候，分析算法该如何设计。 第二，我们也会学习到在实现线性扫描算法中的一些技术点，包括如何分配寄存器、在调用函数时如何保存Caller需要保护的寄存器，以及如何正确的维护栈桢。 解决了这些问题之后，我们会对我们的语言再做一次性能测试，看看这次性能的提升有多大。那么接下来，就让我们先看看实现变量活跃性分析，需要考虑哪些技术细节吧。
实现变量活跃性分析我们先来总结一下，在实现变量活跃性分析的时候，我们会遇到哪几个技术点。我们一般要考虑如何保存变量活跃性分析的结果、如何表达变量的定义，以及如何基于CFG来做变量活跃性分析这三个方面。
现在我们就一一来分析一下。
首先，我们要设计一个数据结构，把活跃性分析的结果保存下来，方便我们后面在寄存器分配算法中使用。
这个数据结构很简单，我们使用一个Map即可。这个Map的key是指令，而value是一个数组，也就是执行当前指令时，活跃变量的集合。
liveVars:Map&amp;lt;Inst, number[]&amp;gt; = new Map(); 确定了数据结构以后，我们再讨论一下算法的实现。在算法的执行过程中呢，我们倒着扫描一条条指令。对于每条指令，我们要分析它的操作数。如果操作数是一个变量下标，那我们就把这个变量加到活跃变量的集合中。所以，往集合里加变量实现起来很简单。
可是，从集合里减变量就不那么简单了。为什么呢？根据我们上一节课讲过的算法，我们需要在变量声明的时候，把这个变量从集合里去掉。可是，我们当前的LIR中并没有记录哪个变量是在什么时候声明的，也就没办法知道变量的生存期是从什么时候开始的了。
那怎么来解决这个问题呢？我的办法是，向LIR里再加一条指令，这条指令专门用来指示变量的声明。我把这条指令的OpCode叫做declVar。
由于这条指令并不能转化成具体的可执行的指令，所以你可以把它叫做伪指令。它仅用于我们的寄存器分配算法。
好了，在加入了这条指令以后，我们就能对一个基本块进行变量活跃性分析了。具体实现你可以参考代码LivenessAnalyzer，其中的核心逻辑我放在下面了：
//为每一条指令计算活跃变量集合 for (let i = bb.insts.length - 1; i &amp;gt;=0; i--){ let inst = bb.insts[i]; if (inst.numOprands == 1){ let inst_1 = inst as Inst_1; //变量声明伪指令，从liveVars集合中去掉该变量 if (inst_1.op == OpCode.declVar){ let varIndex = inst_1.oprand.value as number; let indexInArray = vars.indexOf(varIndex); if (indexInArray != -1){ vars.splice(indexInArray,1); } } //查看指令中引用了哪个变量，就加到liveVars集合中去 else{ this.</description></item><item><title>21｜加深对栈的理解：实现尾递归和尾调用优化</title><link>https://artisanbox.github.io/3/23/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/23/</guid><description>你好，我是宫文学。
前面几节课，我们在实现生成本地代码的过程中，对汇编语言、栈和栈桢有关的知识点都进行了比较深入的了解。通过这些学习，你应该对程序的运行机制有了更加透彻的理解。
那么今天这节课，作为第一部分起步篇的结尾，我们就来检验一下自己的学习成果吧！具体一点，我们就是要运用我们前面已经学过的知识点，特别是关于栈和栈桢的知识点，来实现两个有用的优化功能，也就是尾递归和尾调用的优化。
这两个优化有助于我们更好地利用栈里的内存空间，也能够提高程序的性能，对于我们后面实现函数式编程特性也具有很重要的意义。另外，这样的练习，也会加深我们对栈和栈桢、对程序的控制流，还有对程序的运行机制的理解。
好了，我们先从尾递归入手吧，说说尾递归是怎么回事，还有它有怎样的运行特点，看看我们为什么需要去优化它。
递归函数和尾递归学习编程的同学都应该知道，递归是一种重要的思维方式。我们现实世界的很多事物，用递归来表达是非常自然的。在递归的思维里，解决整体的问题和解决局部问题的思路是相同的。
在我们这个课程里，我们学习的语法分析的方法，也采用了递归的思维：我们给一个大程序做语法分析，会分解成给每一个函数、每一条语句做语法分析。不管在哪个颗粒度上，算法的思路都是相同的。
递归思想的一个更具体的使用方式，就是递归函数。当前的各种高级语言，都会支持递归函数，也就是允许在一个函数内部调用自身。
你可以看看下面这个例子，这个例子是用来实现阶乘的计算的。
function factorial (n:number):number{ if (n &amp;lt; 1) return 1; else return n * factorial(n-1); } 在这里，n的阶乘f(n)，就等于n * f(n-1)。这是典型的递归思维，解决一个整体问题f(n)，能够被转化为解决其局部问题f(n-1)。n的值变化了，但解决问题的思路是一致的。
最近几年，函数式编程的思想又重新流行起来。在一些纯函数式的编程语言中，递归是其核心编程机制，被大量使用。
不过，递归函数的大量使用，对程序的运行时机制是一个挑战。因为我们已经知道，在标准的程序运行模式下，每一次函数调用，都要为这个函数创建一个栈桢。如果递归的层次很深，那么栈桢的数量就会非常多，最终引起“stack overflow”，也就是栈溢出的错误，这是我们在使用栈的时候最怕遇到的问题。
另外，我们还知道，当我们在进行函数调用的时候，还会产生比较大的性能开销。这些开销包括：设置参数、设置返回地址、移动栈顶指针、保护相关的寄存器，等等。特别是，在这个过程中，一般都会产生内存读写的动作，这会对性能产生比较大的影响。
所以说，虽然递归函数很有用，但你在学习编程的时候，可能你的老师会告诉你，如果对性能和内存占用有较高的要求，那么我们尽量不用递归算法实现，而是把递归算法改成等价的非递归算法。
不过，现代编译器也在努力帮助解决这个问题。比如在上一节课中，我们就已经见到了C语言编译器的一个功能，它在编译斐波那契数列的过程中，能够把其中一半的递归调用转变成一个循环语句，从而减少了递归调用导致的开销。
但在这一节课呢，我们不会试图一下子就实现这么复杂的编译优化功能，而是先针对递归调用中的一个特殊情况而进行优化，这个特殊情况就是尾递归。
那什么是尾递归呢？尾递归就是在return语句中，return后面只跟了一个递归调用的情况。在上面的例子中，你会看到return后面跟着的是n * factorial(n-1)，这种情况不是尾递归。不过，我们可以把示例程序改写成尾递归的情形，我写在了下面：
function factorial(n:number, total:number):number{ if (n &amp;lt;= 1) return total; else return factorial(n-1, n*total); } 这个新的阶乘函数使用了两个参数，其中第二个参数保存的是阶乘的累积值。如果要计算10的阶乘，那么我们需要函数factorial(10, 1)。你可以仔细看一下factorial函数的两个不同的版本，它们确实是等价的。但第二个版本中的第二个return语句呢，就是一个标准的尾递归调用。
我们为什么要谈论尾递归呢？这是因为尾递归在栈桢的使用上有其独特的特点，使得我们可以用很简单的方法就能实现优化。
那么接下来，我们就分析一下递归函数在栈的使用上的特点，这有利于我们制定优化策略。
递归函数对栈的使用你可以用我们上一节课的PlayScript版本，使用make example_fact命令来生成上面示例程序的汇编代码和可执行文件。
这个汇编文件是没有做尾递归优化的，你可以看一下它的内容，看看它的栈桢是什么结构。
_factorial: .cfi_startproc ## bb.0 pushq %rbp movq %rsp, %rbp cmpl $1, %edi # cmpl $1, var0 jg LBB0_2 ## bb.</description></item><item><title>22｜增强编译器前端功能第1步：再识数据流分析技术</title><link>https://artisanbox.github.io/3/24/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/24/</guid><description>你好，我是宫文学。
到目前为止，实现一门计算机语言的流程，我已经带你完整地走了一遍：从编译器前端的技术，到AST解释器，再到字节码虚拟机，最后生成了汇编代码并编译成了可执行文件。在这个过程中，我们领略了沿途的风光，初步了解了实现一门计算机语言的各种关键技术。
可是，我们在第一部分起步篇里，都是顾着奋力攀爬，去开出一条路来。可是这条路实在有点窄，是条羊肠小道，现在我们就需要把它拓宽一下。也就是把我们PlayScript语言的特性增强一下，拓宽我们的知识面。
这个拓宽的方式呢，我选择的是围绕数据类型这条主线进行。这是因为，现代计算机语言的很多特性，都是借助类型体系来呈现的。
不知道你注意到没有，到目前为止，除了最早的AST解释器以外，我们的后几个运行机制都只支持整型。所以，我们要在第二部分进阶篇中让PlayScript支持浮点型、字符串和自定义对象等数据类型。做这些工作的目的，不仅仅是增加我们语言支持的数据类型，而且，随着你对字符串类型、和自定义对象等类型的学习，你也会对对象的处理能力，包括对象的属性、方法、对象内存的自动管理等知识有更深刻的理解。
为了降低工作量，我后面的课程主要实现的是实现静态编译的版本。因为这种运行机制涉及的知识点比较广，并且我的目标之一就是要实现一个高效的、静态编译的TypeScript版本，到这里我的目标也算达到了。如果你有兴趣，你也可以把字节码虚拟机版本扩展一下，用于支持对象特性等高级特性。
不过，在我们开启第二段征程之时，我们需要回到编译器的前端部分，把词法分析、语法分析和语义分析等功能都增强一下，以便支持后面的语法特性。在这个过程中，你会学习到前端的数据流分析技术、前端的优化技术和类型计算方面的知识点，让你的编译器前端的知识得到迭代提升。
那么，首先我们就来看看，我们语言在编译器前端功能方面的现状，找找增强这些功能的办法。
编译器前端功能上的现状编译器的前端，也就是词法分析、语法分析和语义分析功能。我们逐个回顾一下，看看我们现在做到怎么样了。
首先来看我们的词法分析功能，跟语法分析和语义分析功能相比，它应该算是最完善的了。为什么这么说呢？因为我们目前的语言特性已经涉及到了大部分种类的Token，这些词法分析器都能提供。但相对来说，我们支持的语法规则还比较有限，所需要的语义分析功能也有很多缺失。不过，词法分析仍然有一些功能不够充分，比如数字字面量和字符串字面量等。
在数字字面量这边，我们目前虽然已经支持比较简单的整数和浮点数的字面量。但还有二进制、八进制和十六进制的数字、科学计数法表达的数字，我们都还没去支持。而且，字符串字面量上，我们也不支持Unicode和转义字符，并且字符串只能用双引号，还没使用单引号的版本。
接着，我们再来看语法分析功能。我们目前使用的都是一些比较高频的语法规则，忽略了一些比较低频的语法。比如，目前函数的参数只支持固定的参数数量，不支持变动数量的参数，也不支持参数的缺省值。再比如，我们目前的循环语句只支持for循环，并且不支持对集合的枚举，等等。
所以说，我们的词法分析和语法分析都还有不少功课需要去补呢。不过，我目前并不着急补这两方面。我的计划是，随着课程的推进，每当我们需要增加新特性的时候，就扩展一下这方面所需的词法和语法分析功能就好了。这样能够让你见证到像计算机语言这样的高难度软件一步步迭代成熟的过程，增强你自己驾驭类似的软件的信心。
既然词法和语法分析功能都不是我们这节课的重点，那语义分析功能自然就是重点了。
这是因为，实际上，在我们实现编译器的前端功能的时候，语义分析的工作量是最大的，但我们目前实现的功能确实有限。如果你有兴趣，可以参考我在《编译原理实战课》中对Java前端编译器的分析。在把编译工作分成的多个阶段中，大部分阶段都是去做语义分析相关的工作。
那我们现在的语义分析功能做到哪一步了呢？
在前面的课程中，我们已经实现了一些必要的语义分析功能，比如建立符号表、进行引用消解、分析哪个表达式是左值，以及进行简单的类型检查等等。不过这些功能其实还远远不够，因为还有很多潜在的语义错误没有被检查出来，因此需要我们逐步把这些工作补上。
在这个过程中，你会学习如何把数据流分析技术、类型计算技术用于语义分析工作。今天这节课，我们就先主要聚焦在数据流分析技术上。接下来，我们就举几个典型的场景，来学习如何在语义分析中使用数据流分析技术。
场景一：代码活跃性分析之程序是否return了？我们在写函数的时候，如果这个函数需要返回值，那么在编译时，编译器会检查一下，是不是你所有的程序分支都以return语句结尾了。如果没有，编译器就会报错。我们举个例子：
function foo(a:number):number{ if (a &amp;gt; 10){ let b:number = a+5; return b; b = a + 10; //这段代码不可到达。 } } 你可以看一下，这段代码有什么问题呢？
首先，你会发现，这段代码里只有在if语句块有return语句。所以，当不满足if条件的时候，程序的执行流程就不会遇到这个return语句。那根据TypeScript的语义，此时的返回值是undefined。而函数的返回值类型里呢，又不包含undefined。所以这时，如果你用“tsc --strict example_return.ts”命令去编译它，tsc会报下面的错误：
当然，如果函数的前面是下面的样子，在返回值里包含undefined，那就是正确的。
function foo(a:number):number|undefined 好，这是我们从示例代码中发现的第一个问题。那么第二个问题是什么呢？
你会看到，在return语句的下面还有一行代码“b = a + 10”，这一行代码其实是永远也不会被执行的。当然，这并不是一个错误，用tsc来编译也不会报错。但是，编译器或IDE工具最好要能够检查出这些问题，给程序员以提示。在编译生成代码的时候，编译器也可以直接把这些代码优化掉。
那如何检查出上面这些语义问题呢？那又需要用到数据流分析技术了。
到目前为止，我们已经多次接触到数据流分析技术了。在进行变量引用分析的时候，我们就曾实现过一个功能，检查出“变量是否在声明前就被引用”的错误。
它的处理逻辑是：语义分析程序遍历整个AST，相当于自上而下地分析每一条代码。当程序遇到变量声明节点的时候，就会标记该变量已经被声明了。而当程序遇到变量引用节点时，如果它发现该变量虽然属于某个作用域，但它当前还没有被声明，那么它就会报语义分析错误。具体的实现，你可以参考RefResolver类中的代码。
另外，在实现寄存器分配算法时，我们也曾经使用过数据流分析技术，来计算每个变量的生存期，从而确定多个变量如何共享寄存器。在那个时候，我们是在CFG上进行数据流分析的，并且分析方向是自下而上的顺序。
针对我们前面实操过的这两个例子，你可以总结出来数据流分析的几个特点：
首先，数据流分析技术可以用在像AST和CFG等多种数据结构上，未来你还会见到我们把它用到其他的数据结构上；
第二，针对不同的分析任务，数据流分析方向是不同的，有的是自上而下，有的是自下而上，你需要确定清楚；
第三，数据流分析的过程，都会针对一个分析变量，并会不断改变这个变量的值。分析变量可能是一个单个的值，或者叫做标量，也可能是一组数值，比如向量和集合。在我们的前面的两个例子中，这个变量都是集合。第一个例子的分析变量是“已声明的变量的集合”，第二个例子的分析变量是“活跃变量集合”。
第四，我们需要有一个规则或函数，基于这个规则来处理每行代码，从而计算新的变量值。比如，在变量活跃性分析中，这个规则是只要遇到变量使用的语句，就往集合里添加该变量，遇到变量声明的语句，就从集合中去掉该变量。
第五，要确定变量的初始值。在第一个例子中，初始值是一个空集。在第二个例子中，每个基本块可能会有一个活跃变量的初始值，这些初始值是由CFG中的其他基本块决定的。
还有最后一个共性，它们都有交汇函数。交汇函数是用来在多个控制流交汇的时候，计算出交汇的值。在第二个例子中，当两个基本块交汇的时候，活跃变量集合是取两个集合的并集。
好了，上面这些就是数据流分析技术的核心特点。抓住这些核心特点，我们可以把这个技术用于更多的场景。比如说，我们就可以用这些特性解决上面这个程序是否正确return的问题。
在开始解决这个问题之前，我们先来梳理一个分析框架，看看我们具体要从哪些方面着手。
我们可以把一个程序在执行过程中是否遇到了return语句，用一个变量来描述，就是当前执行流程是不是alive的。我们从程序的开头，一行行代码的往下分析。在一开始，alive的初始值是true。当遇到return语句以后，alive就变成了false。
对于分支语句，比如if分支语句，则需要每个分支都要遇到一个return语句。如果一个分支的alive值是alive1，另一个分支的alive值是alive2，那么合起来的alive值是什么呢？是alive1 || alive2。也就是说，必须每个分支都遇到return语句后，总的alive才是false。这就是我们的交汇函数。</description></item><item><title>23｜增强编译器前端功能第2步：增强类型体系</title><link>https://artisanbox.github.io/3/25/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/25/</guid><description>你好，我是宫文学。
你可能也注意到了，我们在第二部分的主要任务，是要让PlayScript扩展到支持更多的类型。在这个任务中，对类型的处理能力就是一个很重要的功能。
其实在第一部分，我们已经实现了一定的类型处理功能，包括类型检查、类型自动推断等，但其实还有更多的类型处理能力需要支持。
对于一门语言来说，类型系统是它的核心。语言之间的差别很多时候都体现在类型系统的设计上，程序员们通常也会对类型处理的内部机制很感兴趣。而TypeScript比JavaScript语言增强的部分，恰恰就是一个强大而又灵活的类型系统，所以我们就更有必要讨论一下与类型有关的话题了。
那么通过今天这节课，我们就来增强一下PlayScript的类型处理能力，在这过程中，我们也能学习到更多与类型系统有关的知识点，特别是能对类型计算的数学实质有所认知。
首先，我们来看看TypeScript的类型系统有什么特点。
TypeScript的类型系统从TypeScript的名字上，你就可以看出来，这门语言在类型系统的设计上，一定是下了功夫的。也确实是这样，TypeScript在设计之初，就想弥补JavaScript弱类型、动态类型所带来的缺点。特别是，当程序规模变大的时候，弱类型、动态类型很容易不经意地引入一些错误，而且还比较难以发现。
所以TypeScript的设计者，希望通过提供一个强类型体系，让编译器能够检查出程序中潜在的错误，这也有助于IDE工具提供更友好的特性，比如准确提示类的属性和方法，从而帮助程序员编写更高质量的程序。
而TypeScript也确实实现了这个设计目标。它的类型系统功能很强大，表达能力很强，既有利于提高程序的正确性，同时又没有削弱程序员自由表达各种设计思想的能力。
那么我们现在就来看一看TypeScript的类型系统到底有什么特点。
首先，TypeScript继承了JavaScript的几个预定义的类型，比如number、string和boolean等。
在JavaScript中，我们不需要声明类型，比如下面两句代码就是。在程序运行的时候，系统会自动给age和name1分别关联一个number和string类型的值。
var age = 18; var name1 = "richard"; 而在TypeScript中呢，你需要用let关键字来声明变量。在下面的示例程序中，age和number被我们用let关键字分别赋予了number和string类型。
let age = 18; let name1 = "richard"; 这两行代码里的类型是被推导出来的，它们跟显式声明类型的方式是等价的。
let age:number = 18; let name1:string = "richard"; 第二，TypeScript禁止了变量类型的动态修改。
在JavaScript中，我们可以动态地修改变量的类型。比如在下面两行代码中，age一开头是number型的，后来被改成了string型，也是允许的：
var age = 18; age = "eighteen"; 但在TypeScript中，如果你一开头给age赋一个number的值，后面再赋一个string类型的值，编译器就会报错：
let age = 18; age = "eighteen"; //错误！ 这是因为，上面的第一行代码等价于显式声明age为number类型，因为TypeScript会根据变量初始化的部分，来推断出age的类型。而这个类型一旦确定，后面就不允许再修改了。
let age:number = 18; age = "eighteen"; 不过，如果完全不允许类型动态变化，可能会失去JavaScript灵活性这个优点，会让某些程序员觉得用起来不舒服。所以，TypeScript还留了一个口子，就是any类型。
第三，只有any类型允许动态修改变量的类型。
在TypeScript中，如果你声明变量的时候不指定任何类型，或者显式地指定变量类型为any，那变量的类型都是any，程序也就可以动态地修改变量的类型，我们可以看看下面这个例子：
let age; //等价于 let age:any; age = 18; console.</description></item><item><title>24｜增强编译器前端功能第3步：全面的集合运算</title><link>https://artisanbox.github.io/3/26/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/26/</guid><description>你好，我是宫文学。
在上一节课，我们扩展了我们语言的类型体系，还测试了几个简单的例子。从中，我们已经能体会出一些TypeScript类型体系的特点了。
不过，TypeScript的类型体系其实比我们前面测试的还要强大得多，能够在多种场景下进行复杂的类型处理。
今天这节课，我们会通过多个实际的例子，来探索TypeScript的类型处理能力。并且，在这个过程中，你还会进一步印证我们上一节课的一个知识点，就是类型计算实际上就是集合运算。在我们今天的这些例子中，你会见到多种集合运算，包括子集判断、重叠判断，以及交集、并集和补集的计算。
首先，让我们看几个例子，来理解一下类型计算的使用场景。
类型计算的场景我们先看第一个例子：
function foo1(age : number|null){ let age1 : string|number; age1 = age; //编译器在这里会检查出错误。 console.log(age1); } 在这个例子中，我们用到了age和age1两个变量，它们都采用了联合类型。一个是number|null，一个是string|number。
如果你用–strict选项来编译这个程序，那么tsc会报错：
这个错误信息的意思是：类型number|null不能赋给类型string|number。具体来说，null是不能赋给string|number的。
这说明什么呢？这说明对于赋值语句，比如x = y来说，它会有一个默认要求，要求y的类型要么跟x一样，要么是x的子集才可以。我们把这个关系记做y.type &amp;lt;= x.type。
那么，其他的二元运算，是不是也像赋值运算那样，需要一个类型是另一个类型的子集呢？
不是的。不同的运算，做类型检查的规则是不同的。比如，对于“==”和“!=”这两个运算符，只需要两个类型有交集就可以。你可以用tsc编译一下这个例子：
function foo2(age1 : number|null, age2:string|number){ if (age1 == age2){ //OK。只要两个类型有交集就可以。 console.log("same age!"); } } 你会看到，编译器并不会报错。这说明，两个不同的类型，只要它们有交集，就可以进行等值和不等值比较。并且，即使age1的值是null，age2的值是一个字符串，等值比较仍然是有意义的，比较的结果是不相等。
那如果两个类型没有交集，会发生什么情况呢？我们看看下面的例子，参数x和y属于不同的类型，它们之间没有交集。
function foo3(x : number|null, y:string|boolean){ if (x == y){ //编译器报错：两个类型没有交集 console.log("x and y is the same"); } } 这次，如果你用tsc去编译，即使不加–strict选项，编译器也会报错：
编译器会说，这个条件表达式会永远返回false，因为这两个类型没有交集。
到此为止，我们就了解清楚等值比较的规则了，也就是要求两个类型有交集才可以，或者说两个类型要存在重叠。
那其他的比较运算符，比如&amp;gt;，&amp;gt;=，&amp;lt;，&amp;lt;=，也遵循相同的规则吗？
我们把foo2中的==运算符改为&amp;gt;=运算符，得到一个新的示例程序：</description></item><item><title>25｜增强编译器前端功能第4步：综合运用多种语义分析技术</title><link>https://artisanbox.github.io/3/27/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/27/</guid><description>你好，我是宫文学。
在上一节课，我们比较全面地分析了怎么用集合运算的算法思路实现类型计算。不过，在实际的语义分析过程中，我们往往需要综合运用多种技术。
不知道你还记不记得，我们上一节课举了一个例子，里面涉及了数据流分析和类型计算技术。不过这还不够，今天这节课，我们还要多举几个例子，来看看如何综合运用各种技术来达到语义分析的目的。在这个过程中，你还会加深对类型计算的理解、了解常量折叠和常量传播技术，以及实现更精准的类型推导。
好，我们首先接着上一节课的思路，看一看怎么把数据流分析与类型计算结合起来。
在类型计算中使用数据流分析技术我们再用一下上节课的示例程序foo7。在这个程序中，age的类型是number|null，age1的类型是string|number。我们先让age=18，这时候把age赋给age1是合法的。之后又给age赋值为null，然后再把age赋给age1，这时编译器就会报错。
function foo7(age : number|null){ let age1 : string|number; age = 18; //age的值域现在变成了一个值类型：18 age1 = age; //OK age = null; //age的值域现在变成了null age1 = age; //错误！ console.log(age1); } 在这个过程中，age的值域是动态变化的。在这里，我用了“值域”这个词。它其实跟类型是同一个意思。我这里用值域这个词，是强调动态变化的特征。毕竟，如果说到类型，你通常会觉得变量的类型是不变的。如果你愿意，也可以直接把它叫做类型。
你马上就会想到，数据流分析技术很擅长处理这种情况。具体来说，就是在扫描程序代码的过程中，某个值会不断地变化。
提到数据流分析，那自然我们就要先来识别它的5大关键要素了。我们来分析一下。
首先是分析方向。这个场景中，分析方向显然是自上而下的。
第二，是数据流分析针对的变量。在这个场景中，我们需要分析的是变量的值域。所以，我用了一个varRanges变量，来保存每个变量的值域。varRanges是一个map，每个变量在里面有一个key。
varRanges:Map&amp;lt;VarSymbol, Type&amp;gt; = new Map(); 第三，我们要确定varRanges的初始值。在这个例子中，每个变量的值域的初始值就是它原来的类型。比如age一开始的值域就是number|null。
第四，我们要确定转换函数，也就是在什么情况下，变量的值域会发生变化。在当前的例子中，我们只需要搞清楚变量赋值的情况就可以了。如果我们要在变量声明中进行初始化，那也可以看做是变量赋值。
在变量赋值时，如果=号右边的值是一个常量，那么变量的值域都会变成一个值对象，这种情况我们已经在前一节课分析过了。
那如果=号右边的值不是常量，而是另一个变量呢？比如下面一个例子foo10，x的类型是number|string，y的类型是string。然后把y赋给x。我相信你也看出来，现在x的值域就应该跟y的一样了，都是string。
function foo10(x : number|string, y : string){ x = y; //x的值域变成了string if (typeof x == 'string'){ //其实这个条件一定为true println("x is string"); } } 研究一下这个例子，你会发现通过赋值操作，我们把x的值域收窄了。在TypeScript的文档中，这被叫做"Narrowing"。翻译成汉语的话，我们姑且称之为“窄化”吧。
不过，除了赋值语句，还有其他情况可以让变量的值域窄化，包括使用typeof运算符、真值判断、等值判断、instanceof运算符，以及使用类型断言等等。其中最后两种方法，涉及到对象，我们目前还没有支持对象特性，所以先不讨论了。我们就讨论一下typeof运算符、真值判断和等值判断这三种情况。</description></item><item><title>26｜增强更丰富的类型第1步：如何支持浮点数？</title><link>https://artisanbox.github.io/3/28/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/28/</guid><description>你好，我是宫文学。
我们前面几节课，讲的都是编译器前端的功能。虽然，要实现完善的前端功能，我们要做的工作还有很多。不过，我们现在已经不“虚”了！因为我们已经把编译器前端部分的主要知识点都讲得差不多了，其他的我们可以慢慢完善。
所以，现在我们重新把精力放回到编译器后端功能和运行时上来，这部分的功能我们还有待加强。在第一部分起步篇中，为了尽量简化实现过程，我们的语言只支持了整数的运算，甚至都没区分整型的长度，统一使用了32位的整型。
但这在实用级的语言中可行不通，我们还需要在里面添加各种丰富的数据类型。所以，接下来，我们会花几节课的时间，丰富一下我们语言支持的数据类型。首先我们会添加一些内置的基础类型，比如浮点型、字符串和数组。之后，我们还要通过对面向对象编程特性，支持用户自定义自己的类型。
在这一节课，我们先来看一下如何让我们的语言支持浮点型数据。为实现这个目的，我们需要先了解CPU为了支持浮点数有哪些特别的设计，ABI方面又有一些什么规定，以及如何修改汇编代码生成逻辑。而且，为了正确地在汇编代码中表示浮点型字面量，你还会学到浮点数编码方面的国际标准。
首先，让我们了解一下CPU硬件和ABI对浮点数运算提供的支持。
CPU和ABI对浮点数运算的支持我们先来回顾一下起步篇中关于整数运算的知识。已经有些日子没见到它们了，不知道你还记不记得？你可以和下面我们重点讲解的浮点数的处理模式对比着来看，看看它们有怎样的不同，这也能加强你对这些重点知识的记忆。
X86架构的CPU在64位模式下对整数运算的支持，最重要的就是这两个知识点：
寄存器。整数运算可以使用16个通用寄存器； 指令。对整数进行加减乘除的指令分别是addl、subl、imull和idivl。 另外，ABI也针对整数运算做了一些规定，比如：
参数传递。根据ABI，参数传递过程中会使用6个寄存器。超过6个参数，则放在调用者的栈桢里； 寄存器保护。有一些寄存器要能够跨函数调用保存数据，也就是说函数调用者需要保护这些寄存器，而另一些寄存器则不需要保护； 返回值。根据ABI，从函数中返回整数值时，使用的是%eax寄存器； 栈桢结构。ABI对于栈桢里存放参数、返回地址做了规定，并且规定栈桢需要16字节内存对齐，还规定了如何使用栈桢外的红区等等。 那么，我们再来看看CPU对浮点数运算的支持是怎么样的。
其实，最早期的X86CPU只支持整数运算，并不支持浮点数运算。如果我们要进行浮点数运算，就要用整数运算来模拟。但是这样的话，浮点数运算的速度就会比较慢。
而现代CPU解决了这个问题，普遍从硬件层面进行浮点运算，所以编译器也要直接生成浮点运算的机器码，最大程度地发挥硬件的性能。
我们之前说过，一款CPU可能支持多个指令集。而某些指令集，就是用于支持浮点数计算的。在X86的历史上，CPU最早是通过一个协处理器来处理浮点数运算，这个协处理器叫做FPU（浮点处理单元），它采用的指令集叫做X87。后来这个协处理器就被整合到CPU中了。
再后来，为了提高对多媒体数据的处理能力，厂商往CPU里增加了新的指令集，叫做MMX指令集。MMX的具体含义，有人说是多媒体扩展（MultiMedia eXtension），有人说是矩阵数学扩展（Matrix Math eXtension）。不管缩写的含义是什么，MMX主要就是增强了对浮点数的处理能力，因为多媒体的处理主要就是浮点数运算。
并且，MMX还属于SIMD类型的指令集。SIMD（Single Instruction Multiple Data）是一条指令对多个数据完成加减乘数运算的意思，因此MMX指令能让CPU的处理效率更高。
MMX指令集后来又升级成为了SSE指令集，还形成了多个版本，每个版本都会增加一些新的指令和功能。最新的版本是SSE4.2。SSE是流式SIMD扩展（Streaming SIMD Extensions）的意思。到今天，X86计算机进行浮点数运算的时候，基本上都是采用SSE指令集，不再使用x87指令集，除非是使用那些特别早的型号的CPU。
不知道你还记不记得，我们之前提过，你可以查询自己电脑的CPU所支持的指令集。在macOS上，我用下面的命令就可以查到：
sysctl machdep.cpu.features machdep.cpu.leaf7_features 然后你会在命令行终端，得到关于CPU特性的信息。这些特性就对应着指令集。比如，出现在第一个的FPU，就对应着X87指令集。你也会从其中看到多个版本的SSE指令集。
如果你嫌上面的命令太长，那也可以使用一个短一点的命令。这个命令会打印出更多关于CPU的信息，比如CPU所支持的线程数，等等。其中也包括该CPU的指令集。
sysctl machdep.cpu 这里我插一个小知识点，不知道你会不会有这个疑惑，我们操作系统是怎么知道某CPU支持哪些指令集的呢？原来，X86架构的CPU提供了一个cpuid指令。你用这个指令就可以得到CPU类型、型号、制造商信息、商标信息、序列号、缓存，还有支持特性（也就是指令集）等一系列信息了。所以你看，要理解软件的功能，经常都需要底层硬件架构的知识。
好了，既然我们需要用到SSE指令集，那就需要了解一下SSE指令集的特点。并且，SSE其实不仅能处理浮点数，还能处理整数。不过现在我们主要关心与浮点数有关的特性。这些信息从哪里获得呢？当然是从Intel的手册。下面这些信息就来自于《Intel® 64 and IA-32 Architectures Software Developer’s Manual，Volume 1: Basic Architecture》，我给你稍微总结一下。
首先，我们看看SSE指令所使用的寄存器。
在64位模式下，SSE可以使用16个128位的寄存器，分别叫做xmm0~xmm15。
此外，SSE还会使用一个32位的MXCSR寄存器，用于保存浮点数运算时的控制信息和状态信息。比如，如果你做除法的时候，除数是0，那么就会触发一个异常。而MXCSR寄存器上的某个标志位会决定如何处理该异常：是采用内置的标准方法来处理呢，还是触发一个软件异常来处理。关于MXCSR的详细信息，你可以按需要查看一下手册。
第二，我们看一下SSE对数据类型的支持。
SSE指令支持32位的单精度数，也支持64位的双精度数。不过，单精度数和双精度数的格式，都遵循IEEE 754标准。
在SSE指令中，寄存器里可以只放一个浮点数，这个时候我们把它叫做标量（Scalar）。还可以把多个浮点数打包放在一个寄存器里，这种数据格式叫做打包格式（&amp;nbsp;Packed Data Types），或者叫做向量格式。下图就显示了在一个128位寄存器里存放4个单精度浮点数的情况。
打包格式是用于SIMD类型的指令的，这样一条指令就能处理寄存器里的4个单精度浮点数的计算。不过，我们关注的还是对标量数据的处理，所以就先忽略向量数据处理的情况，有需要我们再补充。
第三，我们看看SSE指令的情况。
SSE对处理浮点数的指令，包括向量指令和标量指令。另外，在JavaScript中，number是以双精度数来表示的，所以我们的语言也就可以忽略与单精度浮点数有关的指令，直接关注双精度浮点数指令就好了。
我在下面这张表中，列出了SSE中与标量的、双精度浮点数处理有关的一些主要的指令：
你能看到，其实这些指令数量也并不太多，很容易掌握。当然，SSE完整的指令还是不少的。SSE针对向量数据处理、整型数据处理都有单独的指令，还有一些指令是用于管理MXCSR寄存器的状态，以及对高速缓存进行管理的。如果你想了解这些，可以阅读Intel手册的第二卷：《Intel® 64 and IA-32 architectures software developer’s manual combined volumes 2A, 2B, 2C, and&amp;nbsp; 2D: Instruction set reference, A- Z》</description></item><item><title>27｜增加更丰富的类型第2步：如何支持字符串？</title><link>https://artisanbox.github.io/3/29/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/29/</guid><description>你好，我是宫文学。
今天我们继续来丰富我们语言的类型体系，让它能够支持字符串。字符串是我们在程序里最常用的数据类型之一。每一门高级语言，都需要对字符串类型的数据提供充分的支持。
但是，跟我们前面讨论过的整型和浮点型数据不同，在CPU层面并没有直接支持字符串运算的指令。所以，相比我们前面讲过的这两类数据类型，要让语言支持字符串，我们需要做更多的工作才可以。
那么，在这一节课里，我们就看看要支持字符串类型的话，我们语言需要做哪些工作。在这个过程中，我们会接触到对象内存布局、内置函数（Intrinsics），以及字符串、字面量的表示等知识点。
首先，我们来分析一下，在这种情况下，我们的编译器和运行时需要完成哪些任务，然后我们再依次完成它们就可以了。
任务分析你可以看到，在一些强调易用性的脚本语言里，字符串常常作为内置的数据类型，并拥有更高优先级的支持。比如，在JavaScript里，你可以用+号连接字符串，并且，其他数据类型和字符串连接时，也会自动转换成字符串。这比在Java、C等语言使用字符串更方便。
为了支持字符串类型，实现最基础的字符串操作功能，我们就需要解决下面这几个技术问题：
第一，如何在语言内部表示一个字符串？
在像JavaScript、Java、Go和C#这样的高级语言中，所有的数据类型可以分为两大类。一类是CPU在底层就支持的，就像整数和浮点数，我们一般叫做基础类型（Primitive Type）或者叫做值类型（Value Type）。
这些类型可以直接表示为指令的操作数，在赋值、传参的时候，也是直接传递值。比如，当我们声明一个number类型的变量时，我们在语言内部用CPU支持的双精度浮点数来存储变量的值就可以了。当给变量赋值的时候，我们也是把这个double值用mov指令拷贝过去就行。
但对于基础类型之外的复杂数据类型来说，它们并不能受到CPU指令级别的直接支持。所以，我们就需要设计，当我们声明一个字符串，以及给字符串赋值的时候，它对应的确切操作是什么。
那么计算机语言的设计者，通常会怎么做呢？我们要把这些复杂数据类型在内部实现成一个内存对象，而变量赋值、传参这样的操作，实际上传递的是对象的引用，对象引用能够转换为对象的内存地址。
所以，从今天这节课开始，我们也将正式支持对象机制。其实，string也好，数组也好，还是后面的自定义类型也好，它们在内存里都是一个对象。当进行赋值操作的时候，传递的都是对象的引用。那这个时候，我们就需要设计对象的内存结构，以及确定什么是对象的引用。
第二，在运行时里提供一些内置函数，用于支持字符串的基本功能。
为了支持字符串类型的数据，我们要能够支持字符串对象的创建、字符串拼接、其他类型的数据转为字符串，还有字符串的比较，等等功能。这些功能是以内置函数（intrincics）的形式来实现的。编译成汇编代码的时候，我们要调用这些内置函数来完成相应的功能。
第三，我们还要处理一些编译器后端的工作。
在编译器的后端方面，我们要能生成对字符串进行访问和处理的汇编代码。这里面的重点就是，我们要知道如何在汇编代码里表示字符串字面量，以及如何获取字符串字面量的地址。
好了，任务安排妥当了，我们开始行动吧。首先我们来看第一个任务，如何在语言内部表示一个字符串类型的数据。
如何表示一个字符串这个问题其实又包含三个子问题：字符编码的问题、string对象的内存布局，以及如何来表示一个对象的引用。
首先，我们看看字符的编码问题。
我们知道，CPU只知道0101这些值，并不知道abcd这些概念。实际上，是我们人类给每个字符编了码，让CPU来理解的。比如规定65代表大写字母a，97代表小写字母a，而48代表字符0，这就是广为使用的ASCII编码标准。但要支持像中文这么多的字符，ASCII标准还不够用，就需要Unicode这样的编码标准。
不过，在我们当前的实现中，我们还是先做一些简化吧，先不支持Unicode，只支持ASCII码就好了。这样，在内存里，我们只需要用一个字节来表示字符就行了，这跟C语言是一样的。至于Unicode，我们后面再支持。毕竟我们的语言PlayScript，是一个开源项目，会继续扩展功能。你也可以走在我前面，自己先去思考并实现一下怎么支持Unicode编码。
第二，我们看看string的内存布局。
如何在内存里表示一个字符串呢？
我们站在巨人的肩膀上，看看C语言是怎么做的。在C语言中，字符串在内存里就相当于一个char的数组，这个数组以0结尾。所以，“Hello”在内存里大概是这样保存的，加起来一共是6个字节：
我们也可以借鉴C语言的做法，用一个数组来表示字符串。不过，C语言需要程序员自己去处理字符串使用的内存：要么通过声明一个数组，在栈里申请内存；要么在堆里申请一块内存，使用完毕以后再手工释放掉。
而JavaScript是不需要程序员来手工管理内存的，而是采用了自动内存管理机制。自动内存管理机制管理的是一个个内存对象。当对象不再被使用以后，就可以被回收。
那么我们的设计，也必须实现自动的内存管理，因为TypeScript并没有底层的内存管理能力。
说到内存对象，我们还有一个设计目标，就是在语言内部，对各种类型的对象都有统一的管理机制，包括统一的内存管理机制、统一的运行时类型查询机制等等。这样，才能铺垫好TypeScript对象化的基础，并在后面实现更丰富的语言特性。所以，我们就需要对如何在内存里表示一个对象进行一下设计。
这方面，我们又可以参考一下其他语言是怎么做的。比如，在Java等语言里，对象都有一些统一的内存布局设计。其典型特征，就是每个对象都有一个固定的对象头，对象头之后才是对象的实际数据。
对象头里面保存了一些信息，用来对这个对象进行管理。进行哪些管理呢？首先是自动内存管理。对象头里有一些标志位，是用于垃圾收集程序的。比如，通过算法来标记某个对象是否是垃圾。我们在后面会具体实现一个垃圾收集算法，那个时候就会用到这些标志位。
标志位还有一个用途就是并发管理。你可以用一些特殊的指令，锁住一个对象，使得该对象在同一时间只可以被一个线程访问。在锁住对象的时候，也要在对象头做标识。此外，对象头里还有引用了类的定义，这样我们就可以在运行时知道这个对象属于哪个类，甚至通过反射等元编程机制去动态地调用对象的方法。
我们可以参考一下Java对象头的设计。它包含类指针和标志位两个部分。类指针指向类定义的地址。标志位就是内部分割成多个部分，用来存放与锁、垃圾收集等标记，还会存放对象的哈希值。
当然，其他语言的对象，也都有类似的内存布局设计。我在《编译原理实战课》中，对Java、Python和Julia等语言的对象内存布局都做了讨论，如果你感兴趣可以去看看。
参考这些设计，我们也可以做出自己的设计。在PlayScript中，我们首先设计一个Object对象，里面有一个标志位的字段和一个指向对象的类定义的指针。我们后面再探讨它们的用途。
//所有对象的对象头。目前的设计占用16个字节。 typedef struct _Object{ //指向类的指针 struct _Object * ptrKlass; //与并发、垃圾收集有关的标志位。 unsigned long flags; }Object; 所有对象都要继承自Object对象，字符串对象也不例外。我们把字符串对象叫做PlayString，其数据结构中包含了字符串的长度。真实的字符串数据是接在PlayString之后的。而且，我们基于PlayString的地址，就能计算出字符串的存储位置，所以并不需要一个单独的指针，这样也就节省了内存空间。
typedef struct _PlayString{ Object object; //字符串的长度 size_t length;
//后面跟以0结尾的字符串，以便复用C语言的一些功能。实际占用内存是length+1。 //我们不需要保存这个指针，只需要在PlayString对象地址的基础上增加一个偏移量就行。 //char* data; }PlayString; 采用这个结构后，实际上PlayString的内存布局如下。对象头占16个字节，字符串长度占4个字节，其余的才是字符串数据，占用空间的大小是字符串的长度再加1个字节：
不过，在这里，我们还有一个技术细节需要做一下决策。</description></item><item><title>28｜增加更丰富的类型第3步：支持数组</title><link>https://artisanbox.github.io/3/30/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/30/</guid><description>你好，我是宫文学。
前面我们已经给我们的语言，增加了两种数据类型：浮点数和字符串。那么，今天这一节课，我们再继续增加一种典型的数据类型：数组。
数组也是计算机语言中最重要的基础类型之一。像C、Java和JavaScript等各种语言，都提供了对数组的原生支持。
数组跟我们之前已经实现过的number、string类型的数据类型相比，有明显的差异。所以在这里，你也能学到一些新的知识点，包括，如何对数组做类型处理、如何设计数组的内存布局，如何正确访问数组元素，等等。
在完成这节课的任务后，我们的语言将支持在数组中保存number和string类型的数据，甚至还可以支持多维数组。是不是感觉很强大呢？那就赶紧动手试一试吧！
那么这实现的第一步，我们需要修改编译器前端的代码，来支持与数组处理有关的语法。
修改编译器前端在编译器前端，我们首先要增加与数组有关的语法规则。要增加哪些语法规则呢？我们来看看一个最常见的使用数组的例子中，都会涉及哪些语法特性。
let names:string[] = ["richard", "sam", "john"]; let ages:number[] = [8, 18, 28]; let a2:number[][] = [[1,2,3],[4,5]]; for (let i = 0; i&amp;lt; names.length; i++){ println(names[i]); } 在这个例子中，我们首先声明了一个字符串类型的数组，然后用一个数组字面量来初始化它。你还可以用同样的方法，声明并初始化一个number数组。最后，我们用names[i]这样的表达式来访问数组元素。
在这个例子中，你会发现三个与数组有关的语法现象，分别是数组类型、数组字面量和下标表达式。
首先是数组类型。在声明变量的时候，我们可以用string[]、number[]来表示一个数组类型。这个数组类型是一个基础类型再加上一对方括号[]。在这里，我们甚至还声明了一个二维数组。
所以，我们还需要扩展与类型有关的语法规则。你看看下面的语法规则，你可以这样表示数组类型：“primaryType ‘[’ ‘]’”。而primaryType本身也可以是一个数组类型，这样就能表达多维数组了，比如a[][]。
primaryType : predefinedType | literal | typeReference | '(' type_ ')' | primaryType '[' ']' ; 不过，这是一个左递归的文法，就会遇到我们之前学过的左递归问题。我们可以改写一下，变成下面的文法：
primaryType : primaryTypeLeft ('[' ']')* ; primaryTypeLeft : predefinedType | literal | typeReference | '(' type_ ')' | primaryType ; 这样的话，我们每次解析完毕一个primaryTypeLeft以后，再看看后面有没有跟着一对方括号就行了。如果出现多对方括号，就表示这是一个多维数组。</description></item><item><title>29｜面向对象编程第1步：先把基础搭好</title><link>https://artisanbox.github.io/3/31/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/31/</guid><description>你好，我是宫文学。
到目前为止，我们的语言已经简单支持了number类型、string类型和数组。现在，我们终于要来实现期待已久的面向对象功能了。
在我们的课程中，为了实现编译器的功能，我们使用了大量自定义的类。最典型的就是各种AST节点，它们都有共同的基类，然后各自又有自己属性或方法。这就是TypeScript面向对象特性最直观的体现。
面向对象特性是一个比较大的体系，涉及了很多知识点。我们会花两节课的时间，实现其中最关键的那些技术点，比如声明自定义类、创建对象、访问对象的属性和方法，以及对象的继承和多态，等等，让你理解面向对象的基础原理。
首先，我们仍然从编译器的前端部分改起，让它支持面向对象特性的语法和语义处理工作。
修改编译器前端首先是对语法的增强。我们还是先来看一个例子，通过这个例子看看，我们到底需要增加哪些语法特性：
class Mammal{ weight:number; color:string; constructor(weight:number, color:string){ this.weight = weight; this.color = color; } speak(){ println("Hello!"); } } let mammal = new Mammal(20,&amp;ldquo;white&amp;rdquo;); println(mammal.color); println(mammal.weight); println(mammal.speak); &amp;lt;!&amp;ndash; [[[read_end]]] &amp;ndash;&amp;gt;在这个例子中，我们声明了一个class，Mammal。这个类描述了哺乳动物的一些基础属性，包括它的体重weight、颜色color。它还提供了哺乳动物的一些行为特征，比如提供了一个speak方法。
Mammal类还有一个特殊的方法，叫做构造方法。通过调用构造方法，可以创建类的实例，也就是对象。然后，我们可以访问对象的属性和方法。
其实TypeScript的类还有很多特性，包括私有成员、静态成员等等。这里我们还是先考虑一个最小的特性集合，先让语言支持最基础的类和对象特性。
看看这个示例程序，我们能总结出多个需要增强的语法点，包括类的声明、调用类的构造方法，this关键字，以及通过点符号来引用对象的属性和方法。
我们首先看看类的声明。我们提供了下面这些语法规则，来支持类的声明：
classDecl : Class Identifier classTail ; classTail : &amp;lsquo;{&amp;rsquo; classElement* &amp;lsquo;}&amp;rsquo; ; classElement : constructorDecl| propertyMemberDecl; constructorDecl : Constructor &amp;lsquo;(&amp;rsquo; parameterList? &amp;lsquo;)&amp;rsquo; &amp;lsquo;{&amp;rsquo; functionBody &amp;lsquo;}&amp;rsquo; ; propertyMemberDecl : Identifier typeAnnotation? (&amp;rsquo;=&amp;rsquo; expression)?</description></item><item><title>30｜面向对象编程第2步：剖析一些技术细节</title><link>https://artisanbox.github.io/3/32/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/32/</guid><description>你好，我是宫文学。
在上一节课里，我们实现了基本的面向对象特性，包括声明类、创建对象、访问对象的属性和方法等等。
本来，我想马上进入对象的继承和多态的环节。但在准备示例程序的过程中，我发现有一些技术细节还是值得单独拿出来，和你剖析一下的，以免你在看代码的时候可能会抓不住关键点，不好消化。俗话说，魔鬼都在细节中。搞技术的时候，经常一个小细节就会成为拦路虎。
我想给你剖析的技术细节呢，主要是语义分析和AST解释器方面的。通过研究这些技术细节，你会对面向对象的底层实现技术有更加细致的了解。
技术细节：语义分析语义分析方面的技术细节包括：如何设计和保存class的符号、如何设计class对应的类型、如何给This表达式做引用消解、如何消解点符号表达式中变量等等。
首先看看第一个问题，就是如何在符号表里保存class的符号。
我们知道，符号表里存储的是我们自己在程序里声明出来的那些符号。在上一节课之前，我们在符号表里主要保存了两类数据：变量和函数。而class也是我们用程序声明出来的，所以也可以被纳入到符号表里保存。
你应该还记得，我们的符号表采用的是一种层次化的数据结构，也就是Scope的层层嵌套。而且，TypeScript只允许在顶层的作用域中声明class，不允许在class内部或函数内部嵌套声明class，所以class的符号总是被保存在顶层的Scope中。
其实在TypeScript中，我们还可以在一个文件（或模块）里引用另一个文件里定义的类，这样你就能在当前文件里使用这些外部的类了。但我们其实并不是把外部类的全部代码都导入进来，而是只需要引入它们的符号就行了。在class符号里有这些类的描述信息，这些信息叫做元数据。元数据里会包括它都有哪些属性、哪些方法，分别都是什么类型的，等等。这些保存在符号里的这些信息，其实足够我们使用这个类了，我们不用去管这个类的实现细节。
你也可以对比一下FunctionSymbol的设计。FunctionSymbol里会记录函数的名称、参数个数、参数类型和返回值类型。你通过这些信息就可以调用一个函数，完全不用管这个函数的实现细节，也不用区分它是内置函数，还是你自己写的函数，调用方式都是一样的。
说完了class的符号设计和保存，我们再进入第二个技术点，讨论一下class的类型问题。
我们说过，class给我们提供了一个自定义类型的能力。那这个自定义的类型如何表达呢？
在前面的课程中，我们已经形成了自己的一套类型体系，用于进行类型计算。而在这个类型体系中，有一种类型叫做NamedType。这些类型都有名称，并且还有父类型。我们用NamedType首先表示了Number、String、Boolean这些TypeScript官方规定的类型，还用它来表示了Integer和Decimal这两个Number类型的子类型，这两个类型是我们自己设计的。
那其实NamedType就可以用来表示一个class的类型信息，以便参与类型计算。
这里你可能会提出一个问题：class本身不就是类型吗？我们在ClassSymbol里已经保存了类的各种描述信息，为什么还要用到NamedType呢？
采用这样的设计有几个原因。首先，并不是所有的类型都是用class定义出来的。比如系统里有一些内置的类型。再比如，如果你用TypeScript调用其他语言编写的库，比如一些AI库，你可以把其他语言的类型映射成TypeScript语言的类型。所以说，类型的来源并不只有自定义的class。
第二个原因是由类型计算的性质导致的。在我们目前的类型计算中，我们基本只用到了类型的名称和父子类型关系这两个信息，其他信息都没有用到，所以就不需要在类型体系中涉及。
不过，使用NamedType这种设计其实有个潜台词，就是我们类型系统是Norminal的类型系统。这是什么意思呢？Norminal的意思是说，我们在做类型比较的时候，仅仅是通过类型的名称来确定两个类型是否相同，或者是否存在父子关系。与之对应的另一种类型系统是structural的，也就是只要两个类型拥有的方法是一致的，那就认为它们是相同的类型。像Java、C++这些语言，采用的是Nominal的类型系统，而TypeScript和Go等语言，采用的是Structural的类型系统。这个话题我们就不展开了，有兴趣你可以多查阅这方面的资料。
不过，为了简单，我们目前的实现暂且采用Norminal的类型，只通过名称来区分相互之间的关系。
在分析完了class的符号和类型之后，我们再来看看它的用途。这就进入了第三个技术点，也就是如何消解This表达式。
我们知道，this表达式的使用场景，是在类的方法中指代当前对象的数据。那么它的类型是什么呢？在做引用消解的时候，应该让它引用哪个符号呢？
this的类型，不用说，肯定就是指当前的这个class对应的类型，这个不会有疑问。
那它应该被关联到什么符号上呢？我们知道，当程序中出现某个变量名称或函数名称的时候，我们会把这些AST节点关联到符号表里的VarSymbol和FunctionSymbol上，this当然也不会例外。this在被用于程序中的时候，其用法跟普通的一个对象类型的变量是没有区别的。那我们是否应该在每个用到this的方法里，创建一个this变量呢？
这样当然可以，但其实也没有必要。因为每个函数都可能用到this关键字，所以如果在每个方法里都创建一个this变量有点啰嗦。我们只需要简单地把this变量跟ClassSymbol关联起来就行了，在使用的时候也没有什么不方便的。我们下面在讲AST解释器的实现机制里，会进一步看看如何通过this来访问对象数据。
接下来，我们再看看第四个技术点：对点符号表达式的引用消解。
在上一节课的示例程序中，我们可以通过“this.weight”、“mammal.color”、“mammal.speak()”这样的点符号表达式访问对象的属性和方法。
我们知道，在做引用消解的时候，需要把这里面的this、mammal、color、speak()都关联到相应的符号上，这样我们就知道这些标识符都是在哪里声明的了。
不过，之前我们不是已经都做过引用消解了吗？为什么这里又要把点符号的引用消解单独拎出来分析呢？
这是因为，之前我们做变量和函数的引用消解的时候，只需要利用变量和函数的名称信息就行了。但在点符号这边，只依赖名称是不行的，还必须依赖类型信息。
比如，对于mammal.color这个表达式。我们在上下文里，很容易找到mammal是在哪里声明的。但color就不一样了。这个color是在哪里声明的呢？这个时候，你就必须知道mammal的类型，然后再找到mammal的定义。这样，你才能知道mammal是否有一个叫做color的属性。
那你可能说，这很简单呀，我们只需要先计算出每个表达式的类型，然后再做引用消解就可以了呀。
没那么简单。为什么呢？因为类型计算的时候，也需要用到引用消解的结果。比如在mammal.color中，如果你不知道mammal是在哪里声明的，就不能知道它的类型，那也就更没有办法去消解color属性了。
所以，在语义分析中，我们需要把类型计算和引用消解交叉着进行才行，不能分成单独的两个阶段。在《编译原理实战课》中，我曾经分析过Java的前端编译器的特点。这种多个分析工作穿插执行的情况，是Java编译器代码中最难以阅读和跟踪的部分，但你要知道这背后的原因。
我还给你提供了一个更复杂一点的例子，你可以先看一下：
class Human{ swim(){ console.log("swim"); } } class Bird{ fly(){ console.log(&amp;ldquo;fly&amp;rdquo;); } }
function foo(animal:Human|Bird){ if (animal instanceof Human){ animal.swim(); } else{ animal.fly(); } } 这个例子里有Human和Bird两个类，Human有swim()方法，而Bird有fly()方法。不过，我们可以声明一个变量animal，是Human和Bird的联合类型。那么，你什么时候可以调用animal的swim()方法，什么时候可以调用它的fly()方法呢？这个时候你就要基于数据流分析方法，先进行类型的窄化，然后才能把swim()和fly()两个方法正确地消解。
好了，关于语义分析部分的一些技术点，我就先剖析到这里。接着我们看看AST解释器中的一些技术。
技术细节：Ast解释器实现Ast解释器的时候，我们也涉及了不少的技术细节，包括如何表示对象数据、对象数据在栈桢中的存储方式、如何以左值和右值的方式访问对象的属性等。
首先我们看看如何表示对象的数据。上一节课里，我们提到用一个Map&amp;lt;Symbol, any&amp;gt;来存储对象数据就行了。我们在类中声明的每一个属性，都对应着一个Symbol，所以我们就可以用Symbol作为key，来访问对象的数据。
其实，我们的栈桢也是这样设计的。每个栈桢也是一个Map&amp;lt;Symbol, any&amp;gt;。你如果想访问哪个变量的数据，就把变量的Symbol作为key，到Map里去查找就好了。
不过，如果只用一个Map来代表对象数据，数据的接收方可能不知道该数据是属于哪个类的，在实现一些功能的时候不方便。所以我们就专门设计了一个PlayObject对象，在对象里包含了ClassSymbol和对象数据两方面的信息，具体实现如下：
class PlayObject{ classSym:ClassSymbol; data:Map&amp;lt;Symbol,any&amp;gt; = new Map(); constructor(classSym:ClassSymbol){ this.</description></item><item><title>31｜面向对象编程第3步：支持继承和多态</title><link>https://artisanbox.github.io/3/33/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/33/</guid><description>你好，我是宫文学。
经过前面两节课对面向对象编程的学习，今天这节课，我们终于要来实现到面向对象中几个最核心的功能了。
面向对象编程是目前使用最广泛的编程范式之一。通常，我们说面向对象编程的核心特性有封装、继承和多态这几个方面。只要实现了这几点，就可以获得面向对象编程的各种优势，比如提高代码的可重用性、可扩展性、提高编程效率，等等。
这节课，我们就先探讨一下面向对象的这些核心特性是如何实现的，然后我会带着你动手实现一下，破解其中的技术秘密。了解了这些实现机制，能够帮助你深入理解现代计算机语言更深层次的机制。
首先，我们先来分析面向对象的几个核心特性，并梳理一下实现思路。
面向对象的核心特性及其实现机制第一，是封装特性。
封装是指我们可以把对象内部的数据和实现细节隐藏起来，只对外提供一些公共的接口。这样做的好处，是提高了代码的复用性和安全性，因为内部实现细节只有代码的作者才能够修改，并且这种修改不会影响到类的使用者。
其实封装特性，我们在上两节课已经差不多实现完了。因为我们提供了方法的机制，让方法可以访问对象的内部数据。之后，我们只需要给属性和方法添加访问权限的修饰成分就可以了。比如我们可以声明某些属性和方法是private的，这样，属性和方法就只能由内部的方法去访问了。而对访问权限的检查，我们在语义分析阶段就可以轻松做到。
上一节课，我们已经分析了如何处理点符号表达式。你在程序里可以分析出点号左边的表达式的类型信息，也可以获得对象的属性和方法。再进一步，我们可以给这些属性和方法添加上访问权限的信息，那么这些私有的属性就只可以在内部访问了，比如使用this.xxx表达式，等等。而公有的属性仍然可以在外部访问，跟现在的实现没有区别。
第二，我们看看继承。
用直白的话来说，继承指的是一个class，可以免费获得父类中的属性和方法，从而降低了开发工作量，提高了代码的复用度。
我写了一个示例程序，你可以看一下：
function println(data:any=&amp;quot;&amp;quot;){ console.log(data); } class Mammal{ weight:number = 0; // weight2; color:string; constructor(weight:number, color:string){ this.weight = weight;
this.color = color; } speak(){ println(&amp;quot;Hello, I&amp;rsquo;m a mammal, and my weight is &amp;quot; + this.weight + &amp;quot;.&amp;quot;); } }
class Human extends Mammal{ //新的语法要素：extends name:string; constructor(weight:number, color:string, name:string){ super(weight,color); //新的语法要素：super this.name = name; } swim(){ println(&amp;quot;My weight is &amp;quot; +this.</description></item><item><title>32｜函数式编程第1关：实现高阶函数</title><link>https://artisanbox.github.io/3/34/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/34/</guid><description>你好，我是宫文学。
前面三节课，我们探讨了怎么在现代语言中实现面向对象编程的特性。面向对象是一种重要的编程范式。还有另一种编程范式，也同样重要，并且近年来使用得很多，这就是函数式编程。从今天这节课开始，我们就来实现一下函数式编程。
函数式编程思想其实比面向对象编程思想的历史更长，早期的Lisp等语言都是函数式编程语言。像JavaScript等后来的语言，也继承了Lisp语言在函数式编程方面的思想，对函数式编程也有不错的支持。
近年，函数式编程思想得到了一定程度的复兴，部分原因是由于函数式编程能够更好地应对大规模的并发处理。我自己最近参与的项目，也在全面使用一门函数式编程语言，这也是对函数式编程的优势的认可。此外，像Erlang这种能够开发高可靠性系统的函数式编程语言，也一直是我感兴趣的研究对象。
对于函数式编程这个话题，很多书和文章都对它有过讲解。我在《编译原理实战课》的第39节，也对函数式编程特性的一些技术点做了分析。在我们的这门课里，因为要动手实现出来，所以目标不能太大，我们就挑几个最核心的技术点来实现一下，让你对函数式编程的底层机制有一次穿透性的了解。
今天这节课，我们主要来实现高阶函数的特性。对于函数式编程来说，高阶函数是实现其他功能的基础，属于最核心的技术点。那么，我们就先分析一下什么是高阶函数。
高阶函数的例子高阶函数的核心思想，是函数本身可以当做数据来使用，就像number数据和string数据那样。那既然可以当做数据使用，那自然可以用它来声明变量、作为参数传递给另一个函数，以及作为返回值从另一个函数中返回。如果一门计算机语言把函数和数据同等对待，这时候我们说函数是一等公民（First-class Citizen）。
我用TypeScript写了一个reduce函数的例子，带你来感受一下高阶函数的特性。这个函数能够遍历一个number数组，并且返回一个number值。
//reduce函数：遍历数组中的每个元素，最后返回一个值 function reduce(numbers:number[], fun:(prev:number,cur:number)=&amp;gt;number):number{ let prev:number = 0; for (let i = 0; i &amp;lt; numbers.length; i++){ prev = fun(prev, numbers[i]); } return prev; } //累计汇总值 function sum(prev:number, cur:number):number{ return prev + cur; }
//累计最大值 function max(prev:number, cur:number):number{ if (prev &amp;gt;= cur) return prev; else return cur; }
let numbers = [2,3,4,5,7,4,5,2];
println(reduce(numbers, sum)); println(reduce(numbers, max)); 这个reduce函数很有意思的一点，是它能接受一个函数作为参数。在每遍历一个数组元素的时候，都会调用这个传进来的函数。根据传入的函数不同，reduce函数能完成不同的功能。当传入max函数的时候，reduce函数能返回数组元素的最大值；而当传入sum函数的时候，则能返回数组元素的汇总值。
这个例子能够部分体现函数式编程的优势：把系统的功能拆解成函数，再灵活组合。
那这些高阶函数的特性具体怎么实现呢？按照惯例，我们还是先看看在编译器前端方面，我们要做什么工作。
修改编译器前端要实现上面的功能，编译器前端需要增加新的语法规则，并做一些与函数类型有关的语义处理工作。</description></item><item><title>33｜函数式编程第2关：实现闭包特性</title><link>https://artisanbox.github.io/3/35/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/35/</guid><description>你好，我是宫文学。
上节课，我们实现了函数式编程的一个重要特性：高阶函数。今天这节课，我们继续来实现函数式编程的另一个重要特性，也就是闭包。
闭包机制能实现信息的封装、缓存内部状态数据等等，所以被资深程序员所喜欢，并被用于实现各种框架、类库等等。相信很多程序员都了解过闭包的概念，但往往对它的内在机制不是十分清楚。
今天这节课，我会带你了解闭包的原理和实现机制。在这个过程中，你会了解到闭包数据的形成机制、词法作用域的概念、闭包和面向对象特性的相似性，以及如何访问位于其他栈桢中的数据。
首先，让我们了解一下闭包的技术实质，从而确定如何让我们的语言支持闭包特性。
理解闭包的实质我们先通过一个例子来了解闭包的特点。在下面的示例程序中有一个ID的生成器。这个生成器是一个函数，但它把一个内部函数作为返回值来返回。这个返回值被赋给了函数类型的变量id1，然后调用这个函数。
function idGenerator():number{//()=&amp;gt;number{ let nextId = 0; function getId(){ return nextId++; //访问了外部作用域的一个变量 } return getId; }
println(&amp;quot;\nid1:&amp;quot;); let id1 = idGenerator(); println(id1()); //0 println(id1()); //1
//新创建一个闭包，重新开始编号 println(&amp;quot;\nid2:&amp;quot;); let id2 = idGenerator(); println(id2()); //0 println(id2()); //1
//闭包可以通过赋值和参数传递，在没有任何变量引用它的时候，生命周期才会结束。 println(&amp;quot;\nid3:&amp;quot;); let id3 = id1; println(id3()); //2 &amp;lt;!&amp;ndash; [[[read_end]]] &amp;ndash;&amp;gt;然后神奇的事情就发生了。每次你调用id1()，它都会返回一个不同的值，依次是0、1、2……
为什么每次返回的值会不一样呢？
你看这个代码，内部函数getId()访问了外部函数的一个本地变量nextId。当外部函数退出以后，内部函数仍然可以使用这个本地变量，并且每次调用内部函数时，都让nextId的值加1。这个现象，就体现了闭包的特点。
总结起来，闭包是这么一种现象：一个函数可以返回一个内部函数，但这个内部函数使用了它的作用域之外的数据。这些作用域之外的数据会一直伴随着该内部函数的生命周期，内部函数一直可以访问它。
说得更直白一点，就是当内部函数被返回时，它把外部作用域中的一些数据打包带走了，随身携带，便于访问。
这样分析之后你就明白了。为了支持闭包，你需要让某些函数有一个私有的数据区，用于保存一些私有数据，供这个函数访问。在我们这门课里，我们可以把这个函数专有的数据，叫做闭包数据，或者叫做闭包对象。
然后我们再运行这个示例程序，并分析它的输出结果：
你会发现这样一个事实：id1和id2分别通过调用idGenerator()函数获得了一个内部函数，而它们各自拥有自己的闭包数据，是互不干扰的。
从这种角度看，闭包有点像面向对象特性。每次new一个对象的时候，都会生成不同的对象实例。实际上，在函数式语言里，我们确实可以用闭包来模拟某些面向对象编程特性。不过这里你要注意，并不是函数所引用的外部数据，都需要放到私有的数据区中的。我们可以再通过一个例子来看一下。
我把前面的示例程序做了一点修改。这一次，我们的内部函数可以访问两个变量了。
//编号的组成部分 let segment:number = 1000;
function idGenerator():()=&amp;gt;number{ let nextId = 0;</description></item><item><title>34｜内存管理第1关：Arena技术和元数据</title><link>https://artisanbox.github.io/3/36/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/36/</guid><description>你好，我是宫文学。
通过前面8节课的学习，我们实现了对浮点数、字符串、数组、自定义对象类型和函数类型的支持，涵盖了TypeScript的一些关键数据类型，也了解了实现这些语言特性所需要的一些关键技术。
在这些数据类型中，字符串、数组、class实例，还有闭包，都需要从堆中申请内存，但我们目前还没有实现内存回收机制。所以，如果用我们现在的版本，长时间运行某些需要在堆中申请内存的程序，可能很快会就把内存耗光。
所以，接下来的两节课，我们就来补上这个缺陷，实现一个简单的内存管理模块，支持内存的申请、内存垃圾的识别和回收功能。在这个过程中，你会对内存管理的原理产生更加清晰的认识，并且能够自己动手实现基本的内存管理功能。
那么，首先我们要分析一下内存管理涉及的技术点，以此来确定我们自己的技术方案。
内存管理中的技术点计算机语言中的内存管理模块，能够对内存从申请到回收进行全生命周期的管理。
内存的申请方面，一般不会为每个对象从操作系统申请内存资源，而是要提供自己的内存分配机制。
而垃圾回收技术则是内存管理中的难点。垃圾回收有很多个技术方案，包括标记-清除、标记-整理、停止-拷贝和自动引用计数这些基础的算法。在产品级的实现里，这些算法又被进一步复杂化。比如，你可以针对老的内存对象和新内存对象，使用不同的回收算法，从而形成分代管理的方案。又比如，为了充分减少由于垃圾收集所导致的程序停顿，发展出来了增量式回收和并行回收的技术。
关于这些算法的介绍，你可以参考《编译原理之美》的33节，里面介绍了各种垃圾收集算法。还有《编译原理实战课》的第32节，里面分析了Python、Java、JavaScript、Julia、Go、Swift、Objective-C等各种语言采用的内存管理技术的特点，也讨论了这些技术与语言特性的关系。在这节课里，我就不重复介绍这些内容了。
垃圾收集对语言运行的影响是很大的，因此我们希望垃圾回收导致的程序停顿越短越好，消耗的系统资源越少越好。这些苛刻的要求，导致在很多现代语言中，垃圾回收器（GC）成了运行时中技术挑战很高的一个模块。不过，再难的技术都是一口口吃下的。在这节课里，我们先不去挑战那些特别复杂的算法，而是选择一个最容易上手的、入门级的算法，标记-清除算法来做示范。
标记-清除算法的思路比较简单，只需要简单两步：
首先，我们要找出哪些内存对象不是垃圾，并进行标记； 第二，回收掉所有没做标记的对象，也就是垃圾对象。 我们通过一个例子来看一下。在下图中，x和y变量分别指向了两个内存对象，这两个内存对象可能是自定义类的实例，也有可能是闭包、字符串或数组。这些对象中的字段，又可能会引用另外的对象。
在图中，当变量x失效以后，它直接引用和间接引用的对象就会成为内存垃圾，你就可以回收掉它了。这就是标记-清除算法的原理，非常简单。
在这个图里，变量x和y叫做GC的根（GC root）。算法需要从这些根节点出发，去遍历它直接或间接引用的对象。这个过程，实际上就是图的遍历算法。
好了，算法上大的原理我们就搞清楚了。那接下来，我们需要讨论一些实现上的技术点，包括如何管理内存的申请和释放、如何遍历所有的栈帧和内存对象，等等。
首先说一下如何管理内存的申请和释放。
内存的申请和释放在我们前面实现的、C语言版本的字节码虚拟机中，我们就曾经讨论过如何高效申请内存的问题。我们发现，如果调用操作系统的接口频繁地申请和释放小的内存块，会大大降低系统的整体性能。所以，我们采用了Arena技术，也就是一次性地从操作系统中申请比较大块的内存，然后再自行把这块大内存划分成小块的内存，给自己的语言使用。
在今天这节课，我们仍然使用Arena技术来管理内存：当我们创建新的内存对象的时候，就从Arena中找一块未被占用的内容空间；而在回收内存对象的时候，就把内存对象占的内存区域标记成自由空间。
在这里你会发现，为了记住哪些内存是被分配出去的，那些内存是可用的，我们需要一个数据结构来保存这些信息。在我的参考实现里，我用了一个简单的链表来保存这些信息。每块被分配出去的内存，都是链表的一个节点。节点里保存了当前内存对象的大小，以及下一个节点的地址。
顺着这个链表，你可以查找出自由的内存。假设节点1的地址是80，对象大小是48字节，节点2地址是180，那么节点1和2之间就有52个字节的自由空间。
当我们要申请内存的时候，如果我们要申请的对象大小低于52个字节，那就可以把这块空间分配给它。这个时候，我们就要修改链表的指针，把新的节点插入到节点1和节点2之间。
如果要回收内存呢？也比较简单，我们就从链表中去掉这个节点就好了。
了解了内存申请和释放的内容后，接下来，我们就需要查找并标记哪些内存是仍然被使用的，从而识别出内存垃圾。这就需要程序遍历所有栈帧中的GC根引用的对象，以及这些对象引用的其他对象。而要完成这样的遍历，我们需要知道函数、类和闭包等的元数据信息才可以。
管理元数据我们前面说过，GC根就是那些引用了内存对象的变量。而我们知道，我们的程序中用到的变量，有可能是在栈中的，也有可能是在寄存器里的。那到底栈里的哪个位置是变量，哪个寄存器是变量呢？另外，如何遍历所有的栈帧呢？如何知道每个栈帧的开头和结尾位置？又如何知道哪个栈帧是第一个栈帧，从而结束遍历呢？这些都是需要解决的技术问题，我们一个一个来看。
首先，我们要确定栈帧和寄存器里，哪些是变量，也就是GC根。
这就需要我们保存变量在栈帧中的布局信息。对于每个函数来说，这些布局信息都是唯一的。这些信息可以看做是函数的元数据的一部分。其他元数据信息包括函数的名称，等等。
我们用一个例子来分析一下变量布局情况。下面的foo函数的栈帧里，包括几个本地变量和几个临时变量。基于我们的寄存器分配算法，这些变量有些会被Spill到栈帧中。比如，如果某个变量使用的寄存器是需要Caller保护的，那么在调用另一个函数的时候，这些变量就会被Spill到内存中。
function foo(b:number):number{ let a:number[] = [1,2,b]; let s:string = "Hello PlayScript!"; println(s); println(a[2]); return b*10; } println(foo(2)); 另外，如果一个函数用到了需要Callee保护的寄存器，那么这些寄存器的信息也会被写入到栈帧，这些寄存器的值也可能是调用者的某个变量。算法可以查询调用者的变量布局信息来确认这一点。
最终，对于foo函数来说，这些变量在栈帧中的布局如下：
那包含了变量布局的元数据信息，应该保存到哪里呢？你可能已经想到了，它们可以被保存在可执行文件的数据区呀，就像之前我们保存vtable那样。
在具体实现的时候，这个数据区可以分成多个组成部分。像vtable这样的数据，出于性能上的要求，我们最好能够比较快捷地访问，所以我们让程序通过“1跳”，也就是只做一次获取地址的操作，就能到查到方法的入口地址。而对于其他元数据信息，由于数据类型跟vtable的不一样，可以安排到另一个数据区中，并从第一个数据区链接过去。元数据在静态数据区的布局如下图所示：
它们在汇编代码中可以写成下面的样子：
.section __DATA,__const .globl _foo.meta ## can be accessed globally .p2align 3 ## 8 byte alignment _foo.meta: .</description></item><item><title>35｜内存管理第2关：实现垃圾回收</title><link>https://artisanbox.github.io/3/37/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/37/</guid><description>你好，我是宫文学。
今天这节课，我们继续上一节课未完成的内容，完成垃圾回收功能。
在上一节课，我们已经实现了一个基于Arena做内存分配的模块。并且，我们还在可执行程序里保存了函数、类和闭包相关的元数据信息。
有了上一节课的基础之后，我们这节课就能正式编写垃圾回收的算法了。算法思路是这样的：
首先，我们要有一个种机制来触发垃圾回收，进入垃圾回收的处理程序； 第二，我们要基于元数据信息来遍历栈帧，找到所有的GC根； 第三，从每个GC根出发，我们需要去标记GC根直接和间接引用的内存对象； 最后，我们再基于对象的标记信息，来回收内存垃圾。 在今天这节课，你不仅仅会掌握标记-清除算法，其中涉及的知识点，也会让你能够更容易地实现其他垃圾回收算法，并且让我们的程序能更好地与运行时功能相配合。
那接下来，我们就顺着算法实现思路，看看如何启动垃圾回收机制。
启动垃圾回收机制在现代的计算机语言中，我们可以有各种策略来启动垃圾回收机制。比如，在申请内存时，如果内存不足，就可以触发垃圾回收。甚至，你也可以每隔一段时间就触发一下垃圾收集。不过不论采取哪种机制，我们首先要有办法从程序的正常执行流程，进入垃圾回收程序才行。
进入垃圾回收程序，其实有一个经常使用的时机，就是在函数返回的时候。这个时候，我们可以不像平常那样，使用retq跳回调用者，而是先去检查是否需要做垃圾回收：如果需要做垃圾回收，那就先回收完垃圾，再返回到原来函数的调用者；如果不需要做垃圾回收，那就直接跳转到函数的调用者。
实现这个功能很简单，只需要在return语句之前调用frame_walker这个内置函数，并把当前%rbp寄存器的值作为参数传进去就好了：
visitReturnStatement(rtnStmt:ReturnStatement):any{ if (rtnStmt.exp!=null){ let ret = this.visit(rtnStmt.exp) as Oprand; //调用一个内置函数，来做垃圾回收 this.callBuiltIns(&amp;quot;frame_walker&amp;quot;,[Register.rbp]);//把当前%rbp的值传进去 //把返回值赋给相应的寄存器 let dataType = getCpuDataType(rtnStmt.exp.theType as Type); this.movIfNotSame(dataType, ret, Register.returnReg(dataType)); &amp;hellip; } } 这样，我们就能获得调用GC程序的时机。
在这段代码中，frame_walker内置函数的功能是遍历整个调用栈。这就是我们启动垃圾回收机制后，要进行的下一个任务。接下来我们就来分析一下具体怎么做。
遍历栈帧和对象遍历栈帧其实很简单，因为我们能够知道每个栈帧的起始地址。从哪里知道呢？就是rbp寄存器。rbp寄存器里保存的是每个栈帧的底部地址。
每次新建立一个栈帧的时候，我们总是把前一个栈帧的rbp值保护起来，这就是你在每个函数开头看到的第一行指令：pushq %rbp。因此，我们从栈帧里的第一个8字节区域，就可以读出前一个栈帧的%rbp值，这就意味着我们得到了前一个栈帧的栈底。然后你可以到这个位置，再继续获取更前一个栈帧的地址。具体你可以看下面这张图：
那这个思路真的有用吗？我们直接动手试一下！
首先，我写了一个简单的测试程序。在这个程序里，main函数调用了foo，foo又调用了bar。这样，在foo和bar返回前，我们都可以启动垃圾回收，但从main函数返回的时候就没有必要启动了，因为这个时候进程结束，进程从操作系统申请的所有内存，都会还给操作系统。
function foo(a:number):string{ let s:string = &amp;ldquo;PlayScript!&amp;rdquo; let b:number = bar(a+5); return s; }
function bar(b:number):number{ let a:number[] = [1,2,b];
let s:string = &amp;ldquo;Hello&amp;rdquo;; println(s); println(a[2]); b = b*10; return b; }</description></item><item><title>36｜节点之海：怎么生成基于图的IR？</title><link>https://artisanbox.github.io/3/38/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/38/</guid><description>你好，我是宫文学。
从今天这节课开始，我们就要学习我们这门课的最后一个主题，也就是优化篇。
在前面的起步篇和进阶篇，我们基本上把编译器前端、后端和运行时的主要技术点都过了一遍。虽然到现在，我们语言支持的特性还不够丰富，但基本上都是工作量的问题了。当然，每个技术点我们还可以继续深挖下去，比如我们可以在类型计算中增加泛型计算的内容，可以把上两节课的垃圾收集算法改成更实用的版本，等等。在这个过程中，你还需要不断克服新冒出来的各种技术挑战。不过，基本上，你已经算入了门了，已经把主要的知识脉络都打通了。
而第三部分的内容，是我们整个知识体系中相对独立、相对完整的一部分，也是我们之前屡次提起过，但一直没有真正深化的内容，这就是优化。
优化是现代语言的编译器最重要的工作之一。像V8和其他JavaScript虚拟机的速度，比早期的JavaScript引擎提升了上百倍，让运行在浏览器中的应用可以具备强大的处理能力，这都是优化技术的功劳。
所以，在这第三部分，我会带你涉猎优化技术中的一些基础话题，让你能够理解优化是怎么回事，并能够上手真正做一些优化。
那在这第一节课，我会带你总体了解优化技术的作用、相关算法和所采用的数据结构。接着，我会介绍本课程所采用的一个行业内前沿的数据结构，基于图的IR，又叫节点之海，从而为后面具体的优化任务奠定一个基础。
那首先，我们先简单介绍一下与优化有关的背景知识。
有关优化的背景知识如果我要把优化的内容和算法都大致介绍一下，可能也需要好几节课的篇幅。不过，我在《编译原理之美》的第27节和28节，对优化算法的场景和分类，做了一些通俗的介绍。对于优化算法，特别是基于数据流分析的优化算法，也做了一些介绍。
而在《编译原理实战课》中，我在第14节、15节、21节、23节、24节分别涉及了Java、JavaScript、Julia和Go语言的编译器中的优化技术。所以，我这里就不重复那些内容了，只提炼几个要点，重点和你说一下优化的目标、分类、算法，以及数据结构，让你做好讨论优化技术的知识准备。
优化的目标优化工作最常见的目标，是提高代码运行的性能。在有些场景下，我们还会关注降低目标代码的大小、优化IO次数等其他方面。
优化工作的分类优化技术的种类非常多，我们很难用一个分类标准把各种优化工作都涵盖进去。但通常，我们会按照几个不同的维度来进行分类。
从优化算法的作用范围（或者空间维度）来说，可以分为局部优化（针对基本块的优化）、全局优化（针对整个函数）和过程间优化（多个函数一起统筹优化）。
从优化的时机（也就是时间维度）来说，我们在编译和运行的各个阶段都可以做优化。所以llvm的主要发起人Chris Lattner曾经发表了一篇论文，主题就是全生命周期优化。在编译期呢，编译器的前端就可以做优化，比如我们已经做过一些常数折叠工作。在后端也可以做一些优化，比如我们前面讲过的尾递归和尾调用优化。
但大部分优化是发生在前端和后端中间的过渡阶段，这个阶段有时候也被叫做中端。除了这些，还有运行时的优化。对于V8这种JIT的引擎，在运行时还可以收集程序运行时的一些统计信息，对程序做进一步的优化编译，在某些场景下，甚至比静态编译的效果还好。
优化的算法优化涉及的算法也有很多。比如，前面我们做常量折叠的时候，基本上遍历一下AST，进行属性计算就行了 ，但在做尾递归和尾调用优化的时候，我们就需要基于栈桢的知识对生成的汇编代码做调整，这里面就涉及到了一些优化的算法。但其中最有用的，则是控制流和数据流分析。
对于数据流分析，我们已经讲过不少了。那控制流分析是怎么回事呢？控制流分析的重点是分析程序跳转的模式，比如识别出来哪些是循环语句、哪些是条件分支语句等等，从而找到可以优化的地方。
比如，如果一个循环内部的变量，是跟循环无关的。那我们就可以把它提到循环外面，避免重复计算该变量的值，这种优化叫做“循环无关变量外提”。比如下面的示例程序中，变量c的值跟循环是无关的，所以我们就没必要每次循环都去计算它了。而要实现这种优化，需要优化算法把程序的控制流分析清楚。
function foo(a:number):number{ let b = 0; for (let i = 0; i&amp;lt; a; i++){ let c = a*a; //变量c的值与循环无关，导致重复计算！ b = i + c; } return b; } 优化算法所依托的数据结构针对中端的优化工作，我们最经常采用的数据结构是控制流图，也就是CFG。在生成汇编代码的时候，我们已经接触过控制流图了。当时我们把代码划分成一个个的基本块，每个基本块都保存一些汇编代码，基本块之间形成控制流的跳转。控制流图的数据结构用得很广泛，比如llvm编译器就是基于CFG的，这也意味着像C、C++、Rust、Julia这些基于llvm的语言都受益于CFG数据结构。另外，虽然Go语言并不是基于llvm编译器的，但也采用了CFG。
控制流图最大的优点，当然是能够非常清楚地显示出控制流来，也就是程序的全局结构。而我们做数据流分析的时候，通常也要基于这样一个控制流的大框架来进行。比如，我们在做变量活跃性分析的时候，就是先分析了在单个的基本块里的变量活跃性，然后再扩展到基于CFG，在多个基本块之间做数据流分析。
不过，虽然CFG的应用很普遍，但它并不是唯一用于优化的数据结构。特别是，像Java编译器Graal和JavaScript的V8引擎，都采用了另一种基于图的IR。不过构成这个图的节点并不是基本块。我在这节课后面会重点介绍这个数据结构，并且说明为什么采用这个数据结构的原因。
刚才我挑重点介绍了与优化有关的背景知识。不过，我用短短的篇幅浓缩了太多的干货，你可能会觉得过于抽象。所以，我还是举几个例子更加直观地说明一下与优化有关的知识点，借此我们也可以继续讨论下面关于IR的话题。
一个优化的例子我们先来看这个代码片段，这段代码中，x和y都被赋值成了a+b。
x = a + b y = a + b z = y - x 你用肉眼就能看出来，第二行代码是可以被优化的，因为x和y的值是一样的，所以在第二行代码中，我们就不需要再计算一遍a+b了，直接把x赋值给y就行。这种优化，叫做“公共子表达式删除（Common Subexpression Elimination）”：</description></item><item><title>37_从AST到IR：体会数据流和控制流思维</title><link>https://artisanbox.github.io/3/39/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/39/</guid><description>你好，我是宫文学。
在上一节课，我们已经初步认识了基于图的IR。那接下来，我们就直接动手来实现它，这需要我们修改之前的编译程序，基于AST来生成IR，然后再基于IR生成汇编代码。
过去，我们语言的编译器只有前端和后端。加上这种中间的IR来过渡以后，我们就可以基于这个IR添加很多优化算法，形成编译器的中端。这样，我们编译器的结构也就更加完整了。
今天这节课，我先带你熟悉这个IR，让你能够以数据流和控制流的思维模式来理解程序的运行逻辑。之后，我还会带你设计IR的数据结构，并介绍HIR、MIR和LIR的概念。最后，我们再来讨论如何基于AST生成IR，从而为基于IR做优化、生成汇编代码做好铺垫。
首先，我还是以上一节课的示例程序为础，介绍一下程序是如何基于这个IR来运行的，加深你对控制流和数据流的理解。
理解基于图的运行逻辑下面是上节课用到的示例程序，一个带有if语句的函数，它能够比较充分地展示数据流和控制流的特点：
function foo(a:number, b:number):number{ let x:number; if (a&amp;gt;10){ x = a + b; } else{ x = a - b; } return x; } 我们把这个程序转化成图，是这样的：
我们之前说了，这个图能够忠实地反映源代码的逻辑。那如果程序是基于这个图来解释执行的，它应该如何运行呢？我们来分析一下。
第1步，从start节点进入程序。
第2步，程序顺着控制流，遇到if节点，并且要在if节点这里产生分支。但为了确定如何产生分支，if节点需要从数据流中获取一个值，这个值是由“&amp;gt;”运算符节点提供的。所以，“a&amp;gt;10”这个表达式，必须要在if节点之前运行完毕，来产生if节点需要的值。
第3步，我们假设a&amp;gt;10返回的是true，那么控制流就会走最左边的分支，也就是if块，直到这个块运行结束。而如果返回的是false，那么就走右边的分支，也就是else块，直到这个块运行结束。这里，if块和else块都是以Begin节点开始，以End节点结束。如果块中有if或for循环这样导致控制流变化的语句，那么它们对应的控制流就会出现在Begin和End之间，作为子图。
第4步，在if块或else执行结束后，控制流又会汇聚到一起。所以图中这里就出现了一个Merge节点。这个节点把两个分支的End节点作为输入，这样我们就能知道实际程序执行的时候，是从哪个分支过来的。
第5步，控制流到达Return节点。Return节点需要返回x的值，所以这就要求数据流必须在Return之前把x的值提供出来。那到底是x1的值，还是x2的值呢？这需要由Phi节点来确定。而Phi节点会从控制流的Merge节点获取控制流路径的信息，决定到底采用x1还是x2。
最后，return语句会把所获取的x值返回，程序结束。
在我这个叙述过程中，你有没有发现一个重要的特点，就是程序的控制流和数据流是相对独立的，只是在个别地方有交互。这跟我们平常写程序的思维方式是很不一样的。在写程序的时候，我们是把数据流与控制流混合在一起的，不加以区分。
比如，针对当前我们的示例程序，我们的源代码里一个if语句，然后在if块和else块中分别写一些代码。这似乎意味着，只能在进入if块的时候，才运行x1=a+b的代码，而在进入else块的时候，才可以运行x2=a-b的逻辑。
但如果你把数据流和控制流分开来思考，你会发现，其实我们在任何时候都可以去计算x1和x2的值，只要在return语句之前计算完就行。比如说，你可以把x1和x2的计算挪到if语句前面去，相当于把程序改成下面的样子：
function foo(a:number, b:number):number{ x1 = a + b; x2 = a - b; if (a&amp;gt;10){ x = x1; } else{ x = x2; } return x; } 当然，针对我们现在的例子，把x1和x2提前计算并没有什么好处，反倒增加了计算量。我的用意在于说明，其实数据流和控制流之间可以不必耦合得那么紧，可以相对独立。
我们可以用这种思想再来分析下我们上节课提到的几个优化技术。</description></item><item><title>38｜中端优化第1关：实现多种本地优化</title><link>https://artisanbox.github.io/3/40/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/40/</guid><description>你好，我是宫文学。
上一节课，我们设计了IR的数据结构，并且分析了如何从AST生成IR。并且，这些IR还可以生成.dot文件，以直观的图形化的方式显示出来。
不过，我们上一节课只分析了if语句，这还远远不够。这节课，我会先带你分析for循环语句，加深对你控制流和数据流的理解。接着，我们就会开始享受这个IR带来的红利，用它来完成一些基本的本地优化工作，包括公共子表达式删除、拷贝传播和死代码删除，让你初步体会基于IR做优化的感觉。
那么，我们先接着上一节课，继续把for循环从AST转换成IR。
把For循环转换成IR同样地，我们还是借助一个例子来做分析。这个例子是一个实现累加功能的函数，bar函数接受一个参数a，然后返回从1到a的累加值。
function bar(a:number):number{ let sum:number = 0; for(let i = 1; i &amp;lt;= a; i++){ sum = sum + i; } return sum; } 这里，我先直接画出最后生成的IR图的样子：
你一看这个图，肯定会觉得有点眼花缭乱，摸不清头绪。不过没关系，这里面是有着清晰的逻辑的。
第一步，我们先来看控制流的部分。
在程序开头的时候，依然还是一个Start节点。
而下面的LoopBegin节点，则代表了整个for循环语句的开始。开始后，它会根据for循环的条件，确定是否进入循环体。这里，我们引入了一个If节点，来代表循环条件。If节点要依据一个if条件，所以这里有一条黑线指向一个条件表达式节点。
当循环条件为true的时候，程序就进入循环体。循环体以Begin开头，以LoopEnd结尾。而当循环条件为false的时候，程序则要通过LoopExit来退出循环。最后再通过Return语句从函数中返回。
并且，LoopEnd和LoopExit各自都有一条输入边，连接到LoopBegin。这样，循环的开始和结束就能正确地配对，不至于搞混。
不过，你可能注意到了一个现象，Start节点的后序节点并不马上是循环的开始LoopBegin。为什么呢？因为其实有两条控制流能够到达LoopBegin：一条是从程序开始的上方进去，另一条是在每次循环结束以后，又重新开始循环。所以LoopBegin相当于我们上一节见过的Merge节点，两条控制流在这里汇聚。而我们在控制流中，如果用一条蓝线往下连接其他节点，只适用于单一控制流和流程分叉的情况，不包括流程汇聚的情况。我们上节课也说过，每个ControlNode最多只有一个前序节点。
那控制流的部分就说清楚了。第二步，我们就来看一下数据流。
在数据流中，我们需要计算i和sum这两个变量。我们先看i：
function bar(a:number):number{ let sum1:number = 0; for(let i1 = 1; i &amp;lt;= a; i2 = i + 1){ sum2 = sum + i; } return sum; } 这里，变量i被静态赋值了两次。一开始被赋值为1，后来又通过i++来递增。为了符合SSA格式，我们要把它拆分成i1和i2两个变量，然后再用Phi节点把它们聚合起来，用于循环条件的判断。
我们把与i有关的数据流加入到图中，就是下面这样：
我再解释一下这张图。i1=1这个表达式，在刚进入循环时被触发，一次循环结束后，会触发i2 = i + 1。所以，在i&amp;lt;=a这个条件中的i，在刚进入循环的时候，会选择i1；而在循环体中循环过一次以后，会选择i2。因此，我们图中这个phi节点有一条输入边指向LoopBegin，用于判断控制流到底是从上面那条边进入的，还是从LoopEnd返回的。</description></item><item><title>39｜中端优化第2关：全局优化要怎么搞？</title><link>https://artisanbox.github.io/3/41/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/41/</guid><description>你好，我是宫文学。
上一节课，我们用了一些例子，讨论了如何用基于图的IR来实现一些优化，包括公共子表达式删除、拷贝传播和死代码删除。但这些例子，都属于本地优化的场景。也就是说，在未来生成的汇编代码中，这些代码其实都位于同一个基本块。
不过，复杂一点的程序，都会有if语句和循环语句这种流程控制语句，所以程序就会存在多个基本块。那么就会存在跨越多个基本块的优化工作，也就是全局优化。
所以，今天这节课，我们就来讨论一下如何基于当前的IR做全局优化。同时，为了达到优化效果，我们这一节课还需要把浮动的数据节点划分到具体的基本块中去，实现指令的调度。
但在讨论全局优化的场景之前，我还要先给你补充一块知识点，就是变量的版本和控制流的关系，让你能更好地理解全局优化。
变量的版本和控制流的关系通过前几节课我们已经知道，我们的IR生成算法能够对一个变量产生多个版本的定义，从而让IR符合SSA格式。可是，我们是如何来表示不同版本的定义的，又是如何确定程序中到底引用的是变量的哪个版本呢？
在IR的模型中，我引入了一个VarProxy类，来引用变量的一个版本，就像d0、d1和d2，也有的文献把变量的一个定义叫做变量的一个定值。VarProxy里面保存了一个VarSymbol，还包括了一个下标：
//代表了变量的一次定义。每次变量重新定义，都会生成一个新的Proxy，以便让IR符合SSA格式 class VarProxy{ varSym:VarSymbol; index:number; //变量的第几个定义 constructor(varSym:VarSymbol, index:number){ this.varSym = varSym; this.index = index; } get label():string{ return this.varSym.name+this.index; } } 每次遇到变量声明、变量赋值，以及像i++这样能够导致变量值改变的语句时，我们就会产生一个新的变量定义，也就是一个VarProxy。这个VarProxy会被绑定到一个具体的DataNode上。所以，我在IR中显示DataNode节点的时候，也会把绑定在这个节点上的变量定义一并显示出来。
那当我们在程序中遇到一个变量的时候，如何确定它采用的是哪个版本呢？
这就需要我们在生成IR的过程中，把VarProxy与当前的控制流绑定。每个控制流针对每个变量，只有一个确定的版本。
//把每个变量绑定到控制流，从而知道当前代码用到的是变量的哪个定义 //在同一个控制流里，如果有多个定义，则后面的定义会替换掉前面的。 varProxyMap:Map&amp;lt;AbstractBeginNode,Map&amp;lt;VarSymbol,VarProxy&amp;gt;&amp;gt; = new Map(); 在这里，我们还用了一个AbstractBeginNode节点来标识一个控制流。因为每个控制流都是存在一个起点的。而每个控制流节点，透过它的predecessor链，总能找到自己这条控制流的开始节点。
//获取这条控制流的开头节点 get beginNode():AbstractBeginNode{ if (this instanceof AbstractBeginNode){ return this; } else{ return (this.predecessor as UniSuccessorNode).beginNode; } } 但是，如果变量不是在当前控制流中定义的，而是在前面的控制流中定义的，那我们可以递归地往前查找。这里具体的实现，你可以参考一下getVarProxyFromFlow()。
最后，如果控制流的起点是一个merge节点，那这个变量就可能是在分支语句中定义的，那我们就要生成一个Phi节点，并把这个Phi节点也看成是变量定义的一个版本，方便我们在后续程序中引用。
好了，相信现在你已经可以更清晰地理解变量版本与控制流之间的关系了。现在我们基于这些前置知识，就可以开始讨论全局优化的场景了。
全局的死代码删除上一节课，我们实现了基本块中的死代码删除功能。那个时候，我们基本上只需要考虑数据流的特点，把uses属性为空的节点删除掉就行了。因为这些节点对应的变量定义没有被引用，所以它们就是死代码。
那么，现在考虑带有程序分支的情况，会怎么样呢？
我们还是通过一个例子来分析一下。你可以先停下来两分钟，用肉眼看一下，看看哪些代码可以删除：
function deadCode2(b:number,c:number){ let a:number = b+c; let d:number; let y:number; if (b &amp;gt; 0){ b = a+b; d = a+b; } else{ d = a+c; y = b+d; } let x = a+b; y = c + d; return x; } 我也把答案写出来了，看看跟你想的是否一样。在整个代码优化完毕以后，其实只剩下很少的代码了。变量c、d和y的定义都被优化掉了。</description></item><item><title>40｜中端优化第3关：一起来挑战过程间优化</title><link>https://artisanbox.github.io/3/42/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/42/</guid><description>你好，我是宫文学。
在前面两节课，我们分析了本地优化和全局优化的场景。我们发现，由于基于图IR的优点，也就是控制流和数据流之间耦合度比较低的这个特点，我们很多优化算法的实现都变得更简单了。
那么，对于过程间优化的场景，我们这个基于图IR是否也会带来类似的便利呢？
过程间优化（Inter-procedural Optimization）指的是跨越多个函数（或者叫做过程），对程序进行多方面的分析，包括过程间的控制流分析和数据流分析，从而找出可以优化的机会。
今天这节课，我们就来分析两种常用的过程间优化技术，也就是内联优化和全局的逃逸分析，让你能了解过程间优化的思路，也能明白如何基于我们的IR来实现这些优化。之后，我还会给你补充另一个优化技术方面的知识点，也就是规范化。
内联优化内联优化是最常见到的一个过程间优化场景，说的就是当一个函数调用一个子函数时，干脆把子函数的代码拷贝到调用者中，从而减少由于函数调用导致的开销。
特别是，如果调用者是在一个循环中调用子函数，那么由很多次循环累积而导致的性能开销是很大的。内联优化的优势在这时就会得到体现。
而在面向对象编程中，我们通常会写很多很简短的setter和getter方法，并且在程序里频繁调用。如果编译器能自动把这些短方法做内联优化，我们就可以放心大胆地写这些短方法，而不用担心由此导致的性能开销了。
现在我们就举一个非常简单的、可以做内联的例子看看。在这个示例中，inline函数是调用者，它调用了add函数。
//内联 function inline(x:number):number{ return add(x, x+1); } function add(x:number, y:number):number{ return x + y; } 显然，在编译inline函数的时候，我们没必要额外多产生一次对add函数的调用，而是把add函数内联进来就行了，形成下面这些优化后的代码：
//内联 function inline(x:number):number{ return x + (x+1); } 那要如何基于我们的IR实现内联优化呢？
首先，我们还是看看在没有优化以前，inline和add两个函数的IR：
在inline函数的IR里，你能发现两个新的节点：一个是Invoke节点，代表函数调用的控制流；另一个是CallTarget节点，代表函数调用的数据流。
而内联优化就是要把这两个IR图合并，形成一个大的IR。如下图所示：
具体来说，要实现上面的合并，我们需要完成两个任务：
首先，把inline函数中的函数调用的节点替换成add函数中的加法节点； 第二，将加法节点中的x和y两个形式参数，替换成inline函数里的两个实际参数。 总的来说，整个算法都是去做节点的替换和重新连接，思路还是很清晰的。
我们之前说过，编译器在做了一种优化以后，经常可以给其他优化制造机会。在这里，内联优化不仅仅减少了函数调用导致的开销，它还会导致一些其他优化。比如说，我们在Inline函数里调用add函数的时候，传入两个参数x和-x，如下面的示例代码：
//内联 function inline2(x:number):number{ return add(x, -x); } function add(x:number, y:number):number{ return x + y; } 那么内联之后，这里就相当于计算x+(-x)的值，那也能计算出一个常量0。至于如何把x+(-x)化简成0，我先留个悬念，你先自己思考一下，我们这节课后面会介绍到。
//内联 function inline(x:number):number{ return x + (-x); //常量0 } 再比如，我们在主函数里调用add的时候，传的参数是常量。那么内联以后，我们就可以进行常量传播和常量折叠的优化，在编译期就能计算出结果为5：</description></item><item><title>41｜后端优化：生成LIR和指令选择</title><link>https://artisanbox.github.io/3/43/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/43/</guid><description>你好，我是宫文学。
前面几节课中，我们讨论的主要是中端的优化。中端优化是跟具体硬件关系并不大，但由于我们还要生成针对具体CPU的汇编代码或机器码，所以做完中端优化之后，我们还要针对具体CPU的特性来做一些优化，也就是后端优化。
其实，我们已经接触过一些后端优化技术了。比如，之前我们已经讲过寄存器分配算法、尾调用和尾递归的优化，这些基本上都属于后端优化。不过，那个时候，我们是从AST直接生成汇编代码，然后在这个过程中做一些后端优化的。
在第三部分优化篇中，我们引入了新的、基于图的IR，进行了很多与硬件无关的优化。用这个基于图的IR来做后端优化，效果又怎样呢？接下来，我们就要修改以前的生成汇编代码的逻辑，改成从这个IR来生成汇编代码，并在这个过程中做一些优化。
今天这一节课，我就带你从中端过渡到后端，看看如何实现后端优化，并生成目标代码。这其中包括IR的Lower、生成LIR和指令选择，以及寄存器分配、指令重排序、窥孔优化和汇编代码的生成，等等工作。不过有些知识点我之前已经讲过了，还有一些知识点不是我们这门课的重点，我就不再展开讲了，重点帮你贯穿一下整个过程。
首先，我们先了解一下给IR做Lower的过程。
Lower过程HIR要经过一系列Lower过程，最后变成LIR。我先举一个例子，让你理解一下在Lower过程中会发生什么事情。这是一个简单的例子，它只实现了给mammal对象weight字段赋值的功能：
function accessField(mammal:Mammal, weight:number){ &amp;nbsp; &amp;nbsp; mammal.weight = weight; } 针对对象属性的赋值，通常编译器要生成写内存的指令。这是因为，对象通常使用的是在堆里申请的内存。而且，由于一个对象可能会由多个线程访问，所以只有把对象属性写到内存里，另一个线程才能访问到更新后的属性。
当然，我们前一节课也说过，如果这个对象并没有逃逸，那就是另一种情况了。我们先假设该对象是逃逸的，那么我们要给对象属性赋值，首先就需要进行写内存的操作。
对于这个简单的场景，一开始这个程序的IR是下面这样：
这里，我们使用了一个抽象度比较高的节点，叫做StoreField。它接受两个输入：一个输入是对象的引用，也就是对象地址；第二个输入是weight属性的值。
在编译的过程中，这个IR会被做Lower处理。StoreField节点会被一个Write节点代替，Write节点是一个写内存的操作。而内存地址呢，用OffsetAddress表示，也就是一个基地址加上一定的偏移量。基地址就是对象的地址，偏移量是对象头的大小。在PlayScript的设计中，它是16个字节。Lower过一次的IR图是这样的：
到目前为止，这个IR还是跟具体CPU无关的。因为按照这张IR图，无论针对什么CPU，你都可以通过在某个地址的基础上加上一个偏移量，来获得新的地址。
然后这个IR还会进一步被Lower，让地址的表示方式更贴近x86-64（或AMD64）架构的具体寻址方式。我们曾经学过x86-64的寻址方式，它的完整形式包括基地址、偏移量、下标值、元素字节数等多个参数。但这里我们只需要它的简化方式，也就是基地址加上一个偏移量就行。进一步Lower的IR变成了这样：
到了这一步，我们的IR已经变得跟具体CPU架构相关了。接下来，我们就把它彻底转化成LIR的格式。
生成LIR和指令选择那LIR又是什么样子的呢？你可以思考一下，如果你来设计编译器，应该如何设计LIR呢？
LIR的目的，是进行机器相关的优化，并最后生成汇编代码。所以，大部分LIR的设计，都是跟汇编代码是同构的。也就是说，LIR是由一条条指令构成的，指令是放在基本块中的，而基本块之间存在跳转关系。
从这个意义上说，我们之前生成汇编代码的时候，已经设计过这样的LIR。而Graal、LLVM、Go语言的gc编译器，在生成汇编代码或机器码之前也都有类似的LIR设计。这个数据结构看上去仍然是基于CFG的，但我们目前已经不需要分析它的控制流和数据流，并调整里面的代码了。这些工作，我们在中端优化的时候都已经完成了。现在，基于这个LIR，我们关心的主要是指令选择、寄存器分配和指令重排序（或者叫做指令调度）这样的话题。
由于我们的IR设计借鉴了Graal编译器，那么同样的，我们继续跟着Graal看看它是怎么处理LIR的。图中是Graal编译器中生成的LIR的例子，你可以通过它建立对LIR的直观感觉：
这张图中一行行的文本，是为了显示LIR中内容，便于调试，实际上的LIR都是内存里的一条条的指令对象。在这个图中，你还能看到Graal编译器的后端处理过程，包括生成LIR、寄存器分配，一直到生成目标代码。我们自己实现的编译器，也需要完成类似的功能。
好了，我们现在已经理解了LIR是什么样子了。那我们现在就从HIR生成LIR，并在这个过程中进行指令的选择，这又可以分成几项子任务。
首先，我们要把HIR中的不同节点分配到不同的基本块中，这被叫做调度算法（Schedule）。
我们在39节已经介绍过，由于很多数据流节点是浮动的，我们可以自由地选择在什么时候进行计算。但我们在生成汇编代码之前，还是要把确定这些数据节点的计算时机，因此要把它们分配到具体的基本块中。
而且，我们需要基于一些规则来完成这个分配工作，比如对于循环无关的代码，我们会提到循环外边；而基于控制流来求值的代码，比如if语句的两个不同分支的代码，我们尽量分配到这两个分支对应的基本块中。制定这些规则的出发点，是尽可能地提升程序的性能，但其实并不能完全保证。在比较AOT和JIT时，我们已经讲过这点了。
在划分好基本块以后，我们再做第二项工作，把IR图转化成LIR的指令，并在这个过程中进行指令的选择。
如果细讲起来，指令选择有两层含义，而这两层含义的工作经常是一起实现的。指令选择的第一层含义，是把抽象的运算，准确地Lower到硬件的具体指令上。比如说，我们可以从比较抽象的层次，对整数和浮点数都执行加法运算。但到了CPU层面，整数的加法指令和浮点数的加法指令就不一样了。其他指令，比如比较运算、数据拷贝的指令，也是跟数据类型和所采用的指令集相关的，编译器要确定出正确的指令。
指令选择的第二层含义，指的是相同的功能，可以用不同的指令组合来实现，而我们要尽量选择让整体性能最优的那组指令。这实际上是一个最优化问题。
关于指令选择的算法，我在《编译原理之美》的29节做过一些理论性的介绍，在《编译原理实战课》的16节，我也介绍过Graal编译器的具体实现。这门课，我也会参考Graal的思路，做一个比较简化的实现。
在我看来，要理解指令选择，除了学习算法，更重要的是要了解很多具体的指令选择场景。下面，我们就以x86-64架构的指令来举几个例子，帮助你建立直观理解。经过这些讲解后，你就能理解那些抽象的算法到底在说些什么了。
第一个例子，是经常出现在if语句中的条件跳转指令：
if(a&amp;gt;b){ //somecode } else{ //some other code } 回忆一下，我们在这门课的第9节、为字节码虚拟机生成字节码的时候，if条件和跳转相关的字节码是分两步来生成的：第一步，处理if条件，计算条件表达式"a&amp;lt;b"，并生成1或0两个值，代表true和false；第二步，处理if节点，根据&amp;lt;节点的值来生成跳转指令。跳转指令使用JE或JNE就行了，也就是比较if条件是不是1。
用这个方式生成指令比较简单。算法上说，就是对每个AST节点依次进行处理。像字面量、变量这样的节点，我们会返回一个Operand。而对于计算性节点，我们就要生成指令，并把指令运行的结果作为Operand来返回。
不过，大部分CPU或虚拟机都提供了更丰富的条件跳转指令，比如JL指令就可以用于在a&amp;lt;b的时候做跳转，而JG指令就可以用于在a&amp;gt;b的时候跳转。这个时候，我们需要同时处理if和&amp;lt;号两个节点，确定采用什么指令，你可以看一下这张示意图：
这就是指令选择算法的特点，我们需要一次性地考虑AST或IR中的多个节点，并生成合适的指令，只要最后算法确实覆盖了所有节点就行。
第二类经常需要做指令选择的情况，是对内存的访问。我还是用这节课开头这个、给mammal对象的weight属性赋值的例子来做说明：
function accessField(mammal:Mammal, weight:number){ &amp;nbsp; &amp;nbsp; mammal.weight = weight; } 在生成指令的时候，我们需要在对象的基地址的基础上，添加一个偏移量，获得weight属性的地址，然后再给这个地址赋值。
要完成这个操作，我们有两个办法。第一个办法是分成两步来生成指令，第一步是先计算出weight属性的地址，第二步是往内存地址写weight的值：
这两步对应的LIR相当于下面两条代码：
add $16, p0 #把p0,也就是对象的地址加上偏移量 mov p1, (p0) #把p1赋给p0指向的内存地址 不过，我们还有第二个方法来生成指令，这就是直接使用x86-64的寻址方式，用一条指令就能完成地址计算和写内存这两个操作。我们的指令选择算法需要一次性处理Write和AMD64Address两个节点：</description></item><item><title>42｜到这里，我们的收获和未尽的工作有哪些？</title><link>https://artisanbox.github.io/3/44/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/44/</guid><description>你好，我是宫文学。
到今天这节课为止，我们已经把这门课程的主要内容都学完了。感谢你一路的坚持！
所以，在今天这节课，我想做一个简单的总结。我想先带你回顾一下我们一起闯过的那些技术关卡，以及取得的成果。接下来，我还想梳理一下我们尚未完成的工作，也对我们后续作为开源项目的PlayScript语言做一下规划。
在这个过程中，你可以暂时从技术细节中解脱出来，站在一个语言的架构师的角度，一起做一些高层面的思考，锻炼一下架构思维。
首先，我们简单总结一下当前已经完成的工作。
当前的收获到目前为止，我们在40多节课的内容里，塞进了大量的知识点。我们按课程顺序来梳理一下。
基础篇：三大关卡在第一部分基础篇中，我带你连续闯了三个关卡。
第一个关卡，是编译器前端技术，包括词法分析、语法分析和语义分析技术。
在词法和语法分析方面，我们这门课没有带你进入相关算法的迷魂阵，而是带你去掌握最佳实践。一方面，这些算法我在《编译原理之美》课程中已经讲过了。另一方面，如果你只是写个编译器，而不是写个像Yacc、Antlr这样的编译器生成工具，其实不需要深究那些算法，只要大概明白原理就行了。
即使是这样，对于递归下降中的左递归问题这样偏理论性的知识点，很多同学免不了还是有疑惑。比如，有同学会问我，我在课程里用到的有些文法，为什么仍然有一些是左递归的呢？这里其实涉及到PEG文法的一个知识点，我会在后面的加餐里讲一下PEG。其实，并不是所有的左递归都没有办法处理。关于左递归，直到现在仍然是做算法研究的人感兴趣的一个领域。
在语义分析方面，我们体会了如何建立符号表、如何做引用消解、如何检查一些语义错误的过程，这样，你会对课本中讲到的一些抽象概念建立具象的理解。
为了编译TypeScript语言，编译器在语义分析阶段最重要的功能是进行类型的处理，其中的关键点又是类型的联合和窄化。在这门课里，我们主要采用了集合运算的手法来处理类型。在PlayScript开源项目中，我计划把这部分进一步优化，让类型计算更简洁、更精准。
对很多同学来说，闯过编译器前端的这个关卡，其实已经收获满满，可以在自己的项目里大展身手了。不过，如果你喜欢钻研底层实现，显然还不会满足止步于此，那你就可以继续闯第二关。
在第二关，我们实现了两个版本的字节码虚拟机。一个版本是用TypeScript实现的，另一个版本使用C语言实现的。
通过这个实现过程，你会了解到像Java这样的成熟语言的字节码是如何设计的，又是如何实际运行的。这样，在需要的时候，我希望你能够敢于自己生成Java或.NET的字节码，实现自己想要的软件编程功能。
并且，通过实现C语言版本的虚拟机，我们也能初步了解运行时的功能。特别是，你要知道，如果我们不能做好内存的管理，系统运行的性能就会大受影响。而且，通过我们多次的性能测试，你应该已经对一个解释器中影响性能的因素产生了直观的理解，这样你自己写程序的时候，也能够进行更明智的决策。
在初步实现了字节码解释器以后，我们又进入了第三关，挑战把源代码编译成二进制的可执行程序。
为了完成第三关的任务，我们必须对程序的运行机制有深入的了解，包括程序运行跟硬件是什么关系，跟操作系统和ABI又是什么关系。再进一步，我们还需要了解CPU架构和它支持的指令集，学会阅读甚至手写汇编代码。
生成汇编代码有两个关键点：第一，要熟悉ABI，正确地维护栈桢和寄存器的状态，否则程序运行时就会报segment错误；第二，就是要实现寄存器分配算法。你要知道，不同的指令集会使用不同的寄存器，并且我们在函数调用前后要保护某些寄存器。做好这些以后，程序就可以充分利用寄存器，飞一般地运行了。
在闯完这三关以后，你已经从前端到后端打通了技术路线。接下来在第二部分进阶篇中，我们把这条路线做了拓宽。
进阶篇：拓宽路径怎么去做拓宽呢？我们的主线是支持更多的数据类型，包括浮点数、字符串和数组这几个基础类型，还包括自定义对象、高阶函数这种高级的类型。
为了支持这些类型，我们必须增强运行时的功能，需要设计对象的内存布局。在访问对象属性、数组成员的时候，我们也要能够正确计算出内存地址来。
进阶篇最难的部分，是自动内存管理功能，包括基于Arena的内存申请机制，以及垃圾回收机制。而实现垃圾回收的关键点，在于找到GC根，并顺着GC根去找到直接引用和间接引用的对象。因此，我们需要保存栈桢的布局信息、对象的元数据信息、闭包的元数据信息等各种静态信息。
如果你充分掌握了内存管理涉及的技术点，那么你在后面实现很多高级功能的时候都能用上。比如对程序做调试、支持运行时的类型判断和元编程功能，都需要用到我们提前保存的元数据信息。
学完第二部分以后，你对实现像面向对象、函数式编程等各种语言特性基本上心里有数了。在第三部分优化篇，我们就专注于解决一个问题，就是优化问题。
优化篇：基于图的IR优化是编译器最重要的功能之一。优化可以发生在全生命周期，包括前端、中端、后端和运行过程中。第三部分的核心，就是一个基于图的IR。这个IR被Java和JavaScript的编译器采用，你可以想象一定有它的优势。
在使用这个IR的过程中，我们确实发现，我们很多优化的实现都变得很简单了。像公共子表达式删除，我们在生成IR的过程中顺带着就能完成。还有，像拷贝传播、死代码删除、值编号等这些优化，实现起来也很简单。最重要的是，这个IR更容易打通本地优化、全局优化和过程间优化三者的边界，让代码更容易在不同的基本块中移动，获取我们想要的优化效果。
并且，我们还了解了基于这个IR不断地做lower，直到生成LIR，然后基于LIR做指令选择、寄存器分配等后端优化的完整过程。通过这一部分的学习，你对于前端、中端、后端优化要做的工作就都比较清晰了。
好了，以上就是这门课中我们领略的各种技术风光，我希望你能够充分掌握，一方面这能开阔你的技术思路，另一方面这些技术也能用到你的实际项目中。
不过，受限于时间，我还没有把一门完整的语言完全实现完。所以，我后面会把这门课的示例代码，作为一个开源项目继续迭代下去，并形成完整的、实用的版本。至于当前已有的基础，我们就把它作为0.1版本吧！
那如果我们要实现一个实用的版本，还有哪些工作要做呢？
后续工作第一，我们要对编译器前端做比较大的增强和重构。
首先，当前我们已有的词法分析、语法分析和语义分析功能，都要支持更多的特性，比如，除了我们已经支持的for循环和if分支语句外，还有while循环、switch语句，等等。
而且，我们对编译错误的处理要更加友好。你应该也感受到了，目前我们的编译器，在遇到某些语法错误的时候，会持续不停地尝试，不断打印错误信息。这显然太不友好了，要做优化。
然后还有一个比较大的工作，就是对类型系统进行升级。我们要重构一下我们之前类型计算的算法，让它变得更加简洁和准确。我们目前使用的Nominal的类型系统，也要修改成支持structural的类型系统，并且我们还要让我们的类型计算支持泛型。
另外，我们在升级编译器前端的时候，对AST和符号表这两个重要的数据结构，也需要重构和优化一下。
第二，我们要把面向对象和函数式编程的特性实现完整。
比如，面向对象方面，我们需要实现严格的对象的初始化流程，需要支持访问权限，还要支持接口。在函数式编程方面，怎么着也要把Lambda表达式这些基础功能实现。这主要是工作量的问题，但需要前端、中端、后端和运行时各方面的配合。
第三，是升级编译器的中端优化功能。
基于目前的IR，我们只实现了少量的优化，并且还没有支持面向对象等复杂的语言特性，这些都需要进行扩展和支持。在这个实现的过程中，我们IR的数据结构也会得到丰富和完善。
第四，是升级编译器的后端功能。
我们之前的编译器后端主要是基于AST来生成汇编代码。所以，在引入IR以后，我们编译器的后端也需要重构一下。从AST生成IR后，再基于HIR生成LIR，然后在LIR的基础上重新实现指令选择和寄存器分配。
另外，我们目前只支持x86-64架构，并且也没有在多个操作系统上做测试。在后面，我们要支持至少两种CPU架构，我计划先支持的是x86-64和Aarch64。前者被广泛用于PC和服务器中，后者被广泛用于智能手机和苹果新一代Mac电脑中。而且，我们还要兼容多种操作系统。
第五，是内存管理方面的升级。
在垃圾收集方面，我们的GC还是很基础的，达不到实用级别。那么，接下来我们首先要完善基本的标记-清除算法。之后，我计划实现一个自动引用计数的（ARC）的机制。
ARC的原理是记录每个对象的引用数，当引用数为零的时候，就自动作为垃圾清理掉。ARC的好处就是垃圾回收不会引起大的停顿，能让系统的响应比较平缓。苹果的Objective-C和Swift都采用了ARC，这也是苹果的系统很少卡顿的原因之一。
第六，实现并发机制。
你应该也注意到了，目前我们这门课中并没有涉及并发机制。但如果不实现并发机制，显然会是一个遗憾。所以后面，我会给出协程功能的一个参考实现。至于另外的并发功能的设想，我接下来还会介绍到。
好了，上面就是要实现一个完整的、实用的、静态编译的语言会涉及到的工作量，细细看一下，还真是挺大的。不过，你也不用怵，这里并没有太多技术点是我们这门课没有涵盖到的，更多的是工作量和工程化的问题。
花费这么多的工作量，我并不完全是为了兴趣爱好，或者是做技术验证，还是想未来有一天，能把它用于一些实际的应用场景中。那接下来，我就谈谈对开源的PlayScript语言项目的一些规划。
对PlayScript的规划为什么我会产生自己动手实现一门语言的想法呢？这其实是出于一些实际的需求。现有的语言，或者已有语言的现有实现，有时会让我很不满意。所以我就想，与其等着别人来满足我的需求，不如自己动手试试看。
我就分享一下我的这几个需求，看看你是否也遇到过类似的问题。
首先，我对后端编程语言不满意。
你知道吗？要实现像微信这样的应用的后端，你只能使用C++这样的语言。并且，微信团队还开发了自己的协程库，才能应对海量并发的需求。我们每天用微信，觉得它总是会实时响应，其实后端的挑战是巨大的。你想想看就知道，成亿的用户，加上成亿的并发，绝对是顶级的技术挑战。
Java、Go等典型的后端语言，都不能满足这种场景的需求。Java的内存占用太大，自带的并发机制只有线程。虽然Go语言好一点，但它和Java都有一个致命的弱点，就是垃圾回收导致的停顿是不可控的。这对于微信这种大型的、高并发的平台，会带来灾难性的后果。但是，让普通的技术团队用C++开发应用，门槛有点高。
而且，我对现有后端语言提供的可靠性也不满意。在这方面，我比较喜欢Erlang，它的并发机制和其他特性结合起来，能提供9个9的可靠性。我觉得，如果每个应用都能实现这么高的可靠性就好了。但是，我对Erlang的性能又不满意，而且它的语法对于大多数程序员来说，也不是太友好。
实现一门高可靠性的语言，其实有隐含一个需求，就是语言中的功能是能够在运行时被动态替换的，因为你没有办法停下整个系统。所以，我们不能仅仅实现AOT的功能，还要有JIT、动态优化、动态部署、动态Dispatch的功能。
所以，我理想的后端语言，是能够用比较低的成本，开发出高并发、高可靠性、资源消耗低的应用。不知道你是不是也有类似的需求呢？
第二，我对前端编程环境也不太满意。
我感觉，现在的前端编程环境太碎片化了，包括浏览器、Android、IOS、Windows、macOS、Linux等不同的平台，而且国内还有好几个不同的小程序平台。
所以，我想要是有一个语言或者工具，能够开发一次，部署到很多客户端，那就好了。
第三，我对企业应用的编程语言也不满意。
我曾经参与过很多企业应用的开发工作。在企业应用的开发中，很多时候我们要更关注业务逻辑。但是，现在很多应用的业务逻辑和技术逻辑都是混杂的，企业应用的开发成本太高了。
我一直认为，如果你是做企业软件的厂商，那应该有相应的开发语言才好，比如，德国的SAP就有自己的ABAP语言。不过，这个语言在现代的应用架构下已经过时了，用ABAP开发不出很容易横向扩展的应用。再有一点，这个语言是企业私有的，不是公共的。
当然，现在我们已经迎来了低代码开发的一波浪潮。但是，如果低代码工具的开发者不是像微软这么有实力的厂商，很难维护一个完全私有的生态。这样的情况下，客户在你私有的平台上开发应用，就是比较有风险的，所以还是应该有一个公共开放的语言。
而且，就算是低代码开发，我也希望是基于某个语言的，而不是仅仅提供一些图形化的定制工具。最好呢，是语言可以转化为图形，图形也可以转化为代码。这种代码和图形化表达双向转化的能力，我在华为的HarmonyOS开发工具上看到了，感觉很喜欢。其实我觉得，低代码开发工具也应该实现类似的功能才算合格，这种能把应用表达为代码的能力，是保证应用的可移植性、保护企业投资的关键。
第四，如有可能，我希望能让物联网应用的开发变得更简单一点。
我在之前的一篇加餐里，介绍过工控领域软件开发的情况。工控领域的技术原来叫做OT，它们的技术跟IT是不一样的。但在我看来，现在很多IT技术可以进入OT领域。比如，现在儿童编程都可以用一个图形化开发工具控制机器人，这跟控制发电机、控制高铁，其实没有本质的区别。所以，我们应该也可以把这两个领域的开发工具打通才对。就算是OT强调高可靠性，但其实，IT里现在就有更高可靠性的技术，比如我前面提到过的Erlang的9个9的可靠性。
另外，OT的技术生态，原来都把控在少数外国的企业手里。我觉得，如有可能，我们最好可以搞搞破坏，把它搞成一个开放的生态。</description></item><item><title>“他山之石”｜Sugar：这门课你可以试试这么学</title><link>https://artisanbox.github.io/3/1/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/1/</guid><description>你好，我是这门课程的助教 Sugar，曾供职于百度，现就职于某大型互联网公司，是一名软件工程师。和你一样，我也是一名编译技术的爱好者。
我们的课程更新到今天，已经过半了，不知道你学习得怎么样呢？有没有卡在哪个知识点的实现上？不要担心，如果你有任何的问题，除了在留言区留言外，还可以添加我们的微信交流群，直接 @ 我或者是宫老师，或者是其他志同道合的同学们，我们都会来帮你解决。
回归正题，今天，刚好是国庆假期，我们第一部分的起步篇也更新完了。我们就先停下来休息休息，夯实基础。在这篇分享里，我想跟你聊聊我对编译技术的看法。我也会从我个人的角度，给你总结一下已更新完的起步篇都讲了什么，以及在日常工作中，我们又可以从哪些方向把这门课学到的知识落到实践中来。最开始，我们聊聊为什么要学习编译技术这个话题。
我为什么推荐你学习编译技术？我大概是在2014年入行互联网行业的，一晃就是7年。这7年间，很多公司的口号和观点都从“从PC业务向移动端转型”，变成了“国内移动端用户饱和，期待其他新兴领域带来业务增量”。科技行业发展之快，令人欣喜也叫人唏嘘。
不得不说，作为一名计算机专业科班出身的同学，我很惭愧。我其实是在走上工作岗位后，才对作为本科必修课的编译原理有了真正的了解，也真正感受到了这个技术领域独特的魅力。所以现在，我也推荐你关注这项技术。
为什么我会推荐你学习编译技术呢？如果你一定要问我理由，我想给你分享两点。
第一点，网红热点的“花开花落”，远不如底层技术的“静水流深”有力量。
在我还是一名“产品工程师”（Product Engineer）的时候，我从事过客户端、前端、服务端，以及一些面向业务应用的算法方面的工作。
近些年，每一个技术领域都涌现过各种新概念、新趋势，这可能会让你陷入“学习了这门新技术，就能分享这种技术形态的成长红利，提升自我价值”的错觉。我也曾追赶过这些“技术时尚”：做后端时一会儿学学这个语言，一会儿瞧瞧那个中间件；做前端时，一会儿用用这个框架，一会儿看看那个三方库。
但冷静下来，你就会发现，这些“网红型”技术热点，能够沉淀下来、为业务长期赋能的寥寥无几。真正值得长期学习和不断实践的，反倒是计算机专业的那些基础课，包括但不限于数据结构与算法、计算机网络、操作系统、编译原理、计算机体系结构，还有软件工程等等。这些课程你在学校里学习的时候，可能感觉枯燥乏味、过于抽象，甚至毫无成就感，然而在工作以后你才会发现，这可能是一名 coder 应对“行业内卷”最坚实有力的后盾。
第二点，技术上卡的“脖子”也正意味着更多的机会和可能。
其实，近两年来，我们国内IT行业很多龙头企业都遭遇了“技术卡脖子”的情况。一时间，芯片、操作系统以及其他基础软件国产化的呼声，都起来了。但是，在我看来，这些“low-level-stuff”需要的不止是时间与金钱的投入，更需要技术人才的“梯队化”。
国外的许多大公司里，你都能见到50多岁，甚至年龄更大的资深程序员。他们往往不是从事一些面向用户的业务逻辑开发，而是做一些被称为 Infrastructure 的基础架构工作。我们国内这样的趋势还不够明朗，毕竟我们起步太晚，做这些基础技术的工作，又需要公司雄厚且稳定的营收去支撑。这个差距是显而易见的，甚至短期内都没法快速弥补上。
我曾经就遇到过一个Google V8引擎方面的技术难题。我当时是在一个C++的程序中集成了 V8，通过 V8 的 ObjectTemplate 和 HandleScope 等优化尽可能快速生成 jsObject，并传递到 V8-Isolate 内部的 jsContext 里。但我用尽了所有方法，依然达不到原生 JavaScript 中字面量 Object 的性能。我跟身边许多架构师同事进行了探讨，也通过e-mail和V8项目的一些参与者进行了交流。但是我发现，相比起国外的技术社区，国内工程师们能给出的一些建议确实非常有限。
当然，我不认为这是技术水平、或者是智力这些因素造成的，事实上，国内有大量非常聪明，而且比国外更加勤劳（内卷所致）的软件工程师。在我看来，造成这个现象的原因，主要是 V8 项目的历史实在太久远了，而且早期的核心开发人员又有许多来自于历史更久远的 Java 虚拟机。整个过程具有很强的“技术继承性”，国内的工程师很难有机会，真正深入地了解这些系统的技术内幕。
或许，这就是我们在很多核心技术领域被“卡脖子”现象的主要原因之一。不过，困境也就意味者突破和机会。在底层软硬件国产化的浪潮下，编译器和操作系统是两座绕不过、躲不开的大山，国产芯片也会创造出大量让编译技术大放异彩的机会。在可预见的未来5～10年内，国内的这个技术趋势都是存在的。所以，我看好编译技术、操作系统等这些技术领域的发展，也推荐你深入学习这些底层技术。
起步篇讲了什么？前面聊完了“为什么”，现在我们就来解析一下“是什么”，聊聊我们这门课已更新完的起步篇里，都讲了什么。
不过，在这里我希望你能理解一点，当前这门课程是宫老师讲编译技术的第三季课程了，所以不可避免地存在着一定的知识继承性和延续性。对于编译器的前端部分，这次的课程中讲得相对没有那么深入。如果你想深入了解前端的知识，我建议你去看看第一季《编译原理之美》和第二季《编译原理实战课》。第三季的重点是放在了编译器后端部分，和物理机、操作系统打交道。
如果你看到我梳理的概念中，有很多是你无法理解的，你也可以带着疑问，试着把整个流程串起来。有了一个整体的“大局观”之后，再回头去第一季和第二季中找寻答案，当然也可以在我们的微信交流群里提问。
编译器是一个工业级的基础软件，因此从理论体系上我们就将编译器分成了前端、中端和后端三部分（有些文献上也把中端算为后端）。
你在学习中也会发现，宫老师起步篇的安排，也是按照这个顺序：02是讲词法分析，03和04的前半部分是讲语法分析，后面的04到06的部分则是循序渐进地把编译器前端的语义分析和语法分析的功能，拆成一个个具体的 feature 一点一点放到我们的示范程序中来完成、实现。
07到11节部分呢，是有关虚拟机的话题。严格意义上，其实虚拟机相关的技术并不算是传统的编译原理范畴。在编译技术的三大圣经（《龙书》、《虎书》和《鲸书》）里有关虚拟机、垃圾回收等方面的篇幅少之又少。不过这也是因为历史的局限性，毕竟 Java 这样的语言在1995年才诞生。不过我们的课程却是与时俱进的，在读到宫老师的这部分内容时候，我眼前一亮。
接下来的11-12两节课呢，是一些基础知识的铺垫。这里涉及到编译器与操作系统、和计算机硬件之间“打交道”时的一些“责任边界”。后面的14-18节，则是对编译器后端技术的实践。由于我们课程的受众大部分是软件工程师，所以在14和15两节课，宫老师又花了不少篇幅为大家科普芯片指令集的一些基础知识。
在我看来，理解芯片和汇编语言有一个很好的方法，就是把芯片看成我们中学时期用过的“科学计算器”，甚至是更简单的“日常使用的普通计算器”。唯一的不同之处就是，芯片没有给人类手指去触摸的按钮，取而代之的是需要用程序通过一组组汇编代码去操纵这个“超级微型却功能强大的计算器”。希望我这样的描述，能减少你对芯片指令集的陌生感、缓解你对“超纲知识”的恐惧。
起步篇最后的19-21这三节课呢，是对一些难点知识的精讲。如果你的基础不牢固，我建议你优先学习前面的知识内容。除此之外，我还为你整理了一张脑图，帮你“高亮”出了一些学习这门课有必要弄懂的关键概念：
动手实践才是目的理清了我们起步篇的内容，最后我们聊聊在日常工作中，我们可以从哪些方向把这门课学到的知识落到实践中来。我想从我从事过的前端、客户端、服务端和算法这四个软件工程师岗位，给你讲讲我是如何在日常工作中实践编译技术的，希望能对你有一些参考价值。
平心而论，我非常建议你，把课程作为自己学习的一个起点而不是终点。只有你真正实践过，你才能真正明白为什么大部分语言的前端都在依靠手写递归下降+算符优先级算法的组合去实现，而鲜有教科书上那样设计精巧的LL算法实现（因为first和follow集的维护成本太高了！）。
领域一：前端你可能会问，前端领域真的有必要，学习编译原理这样的技术吗？我理解，毕竟很多前端的同学，每天的工作就是机械地进行设计稿（PS、Sketch等生成的文件）到 HTML+ CSS 代码的转换。但你可能忽略了一些我们前端每天都在使用的构建工具，比如webpack、Rollup，或者是近两年涌现出的ESbuild、swc等等，这些恰恰是我在从事前端工作期间，认为最有意思的一些infra类的工作。
而且，我们这门课也使用了 JavaScript/TypeScript 语言作为教学工具。如果你就从事前端，那我非常建议你把上面这些构建工具作为自己的研究目标，像电影《速度与激情》里的剧情一样，把自己每天开的“车子”拿过来拆开看看，动手改装“魔改”一番，这会是一件非常有乐趣和成就感的事。
另外，从 Typescript 到 Wasm 这些新工具、新技术的出现也能看出，前端是最有可能在近几年内，因为编译技术而出现新变革的技术领域。如何设计出一种在开发阶段可以使用JavaScript技术栈、而在运行时又能提供尽可能像C++一样高性能的编程语言工具链，将成为业界的一个关键课题。</description></item><item><title>“屠龙之秘”｜实现计算机语言这样的技术能用在哪里？（一）</title><link>https://artisanbox.github.io/3/2/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/2/</guid><description>你好，我是宫文学。
在学习这么多硬知识的间隙里，我给你准备了一些相对轻松一点的内容，想让你转换一下，让大脑休息休息。
不知道你在学习这门课的时候，有没有这样的困惑：实现计算机语言这样的“屠龙技”，到底在哪里能够发挥作用呢？毕竟，不是每个人都有机会成为像Java、JavaScript这样的通用语言的发明者的。
我的答案是：其实在任何软件领域，只要你做得足够深，其实都能用上这门课程的知识。我也一直在给你传达一个理念：任何好的软件，其实到最后都会变成一个开发平台，所以也就需要用到实现计算机语言的这些相关技术。
所以，在这里，我想分成两节课或者更多节课，给你介绍一些有意思的应用场景，希望你能从中得到启发，在自己的工作中也能更好地运用我们这节课的知识，做出一些耀眼的成绩。
今天这节课，我会跟你分享自动化控制领域（或者简称自控领域），对软件编程的需求，以及如何设计一个开发平台来满足这样的需求。在学习这节课的过程里，你可以不断地做一些印证，想想你可以用在门课学到的知识，怎么来满足这个领域的需求。
但是，我需要补充一句，我自己并不是自控领域的从业者。只不过，我恰好有一些朋友，是国内这个领域顶级的、资深的专家，所以我就有机会学习到了这个领域的一点知识。并且，我跟他们参与了一个工业领域的操作系统项目的策划工作，这也激发了我对这个领域的编程模式的兴趣。但是呢，我对这个领域了解得并不那么深，也不那么专业，我主要关注其中与编程技术有关的部分。
那么首先，我们来了解一下自控系统的作用和应用场景，方便我们理解它对编程技术的需求。
自控系统的应用场景计算机技术在工业领域有着丰富的应用，其中一个应用领域，就是自动化控制。
其实自动化控制离我们特别近，你肯定不陌生。比如，当你乘坐地铁或高铁的时候，它们总是能够准确地停在站台边，停靠的位置甚至可以精准到厘米级。这里面就有自动控制的程序在起作用。
自动化控制也有在工厂里的应用，你可能没那么熟悉，但也跟你的生活密切相关。比如在发电厂里，我们需要对发电机组机组进行精确地控制。如果转子的旋转速度出了问题，那就会酿成巨大的灾难。在核电厂里，我们也需要对核燃料进行精确地控制，以便正常发电，不要引起事故。
你知道，制造业是一个现代国家的根本。而现代工厂的生产过程，几乎全部都会用到自动控制系统，包括离散制造型企业，就是给我们制造手机、电脑、汽车的企业；还有流程型企业，比如各种化工厂，还有前面提到的电厂。
最后，其实我们身边应用得非常广泛的物联网，也属于广义上的自控领域。比如，你家里的智能电表、智能门锁，还有小区停车场的自动道闸等等。
所有这些应用场景，基本上都会采用类似下面的这种技术架构：
你看这张图，最底下是各种生产设备。在这层之上呢，是一些自动化的控制器。控制器最重要的作用就是控制设备的运行。它的原理是这样的：设备在运行过程中，会不断产生信号，信号会被实时传输给控制器。控制器接收到信息以后，在内部进行实时计算，然后根据需要输出一些控制信号，让设备的运行做出一些改变。
通常来讲，控制器对计算能力的要求不会太高，控制的逻辑通常也并不是特别复杂，因为控制程序的时延必须很低。这也很容易理解，比如你开车的时候，肯定不能容忍刹车的响应很慢，那会出事故的。也正是因为实时性的要求，自动系统一般都运行在实时操作系统上，甚至运行在裸设备上。
而且，控制器会跟一个上位机连接，并通过某种工业协议进行通信。上位机的计算能力和存储能力都会比控制器更强。我们通过上位机，就可以了解每个控制器的运行情况，可以对控制器做一些操作，比如升级控制器上的程序等等。
好了，这就是自控领域最基本的计算架构，以及系统的运行场景。那么为了满足自控系统的需求，需要什么样的开发工具呢？是不是用普通的编程语言和开发工具就能满足自动的需求呢？
自控系统的技术特征自控程序的开发和运行有特殊的要求。我们平常用到的开发语言和开发工具，很难满足这些需求，因此我们必须设计专门的工具。我来给你分析一下。
首先，自控系统运行的硬件环境是不同的。
从硬件架构来看，这些控制器的设计跟我们平常的手机和桌面电脑都不一样。。
从硬件的电气特性来看，这些硬件在环境适应上的要求要比普通民用的更加严苛。这些硬件在设计上能够更好适应比较恶劣的工业环境，比如能承受比较大的震动、电磁、灰尘等的影响。普通民用的硬件设计，在这种环境下可能会从硬件产生出错误的信号，或者存储的数据发生错误，甚至无法正常工作。
从编程者的角度看，这些控制器的CPU的架构也跟我们手机和电脑不大相同。CPU架构的概念我们前面已经学过了。不同的CPU架构，意味着不同的指令集、不同的寄存器、不同的内存寻址方式，以及不同的异常处理机制等等。
不同的CPU架构，自然会导致程序开发方式的不同。普通的编译器，有可能都不支持这些芯片，或者没有针对这些硬件进行专门的优化。这个时候，如果你掌握了一些编译技术的后端知识，就知道如何以最优的方式生成机器码，并充分发挥硬件的能力。
第二，自控系统运行的软件环境也是不同的。
我们前面提到过，对于实时性要求比较高的场景，自控程序通常运行在实时操作系统里，或者是在裸设备上运行。所以，我们的开发工具也要能够生成在实时操作系统或裸设备上运行的程序。
不知道你还记不记得，我们前面讲过，在操作系统上运行，需要遵守相应的ABI，让程序能够跟操作系统相互配合起来。所以，这就需要开发工具支持实时操作系统才可以。当然，如果运行在裸设备上，那么就需要我们的开发平台本身来提供一些运行时功能，有支持IO、任务调度等能力，那这个运行时在某种意义上也是一个简化版的实时操作系统。
第三，自控系统的软件更新机制是不同的。
自控系统跟我们其他软件一样，在开发过程上也需要进行版本迭代。不过它的版本迭代有时候要求更高。比如，像发电机组等设备一旦投入运行，是不可以随意停机的。每次停机，都会造成很大的成本和影响。还有像卫星、太空舱上面的关键设备，大概也是这样的。这就需要自控系统能够在不重启的情况下实现更新。在这种需求下，自控软件的更新可能会有下面几个特点：
第一个特点：通常这些系统的更新都不是整体更新，而是支持一个个小模块的动态更新。
如果我们拿Java语言来打个比方，这相当于程序在运行的时候每次只更新一个类。从这个角度看，我们在课程里讲过的动态编译并形成可运行的模块的技术，就会派上用场了。但是静态编译并不能满足这个场景的要求，因为静态编译后的程序，在代码区里的内容通常是固定的、不能修改的。
第二个特点：在更新的时候，要满足实时性的需求。
在自控系统上，通常会有这样的场景：在10毫秒前的一次调用，可能使用的是前一个版本，在下一次调用，就已经无缝切换成了新版本。在这种情况下，程序之间不是静态链接在一起的。当我们要执行某个函数的时候，需要动态查询这个函数的地址，然后再跳转。在采用JIT技术的系统中，通常也会采用类似的技术。
第三个特点：在模块更新的时候，要能够保留程序中原来的状态信息。
自控软件在控制设备运行的时候，需要正确地掌握设备过去的状态。拿我们熟悉的场景来举个例子，如果你要升级红绿灯的控制软件，那么程序中的状态信息就要包括每个灯的状态是什么、已经持续了多久。
如果按照原来的规则，红灯要在5秒后转绿，那么软件升级后，必须仍然是在5秒后转绿，系统整体的运行逻辑才不受影响。否则的话，可能会出现路口两个方向都是绿灯的错误状态，从而引发交通事故。这种状态的错误，如果出现在电梯控制上、发电机组控制上，都会导致致命的后果。
第四，自控系统对可靠性和安全性有着很高的要求。
通过前面的描述，你应该已经体会到了，自控系统对于可靠性和安全性，有着很高的要求。我们可以想象一下，在未来的战争中，可能我们受到的第一波攻击并不是从天而降的导弹，而是来自网络的攻击。如果网络攻击就瘫痪掉来一个国家的高铁、核电、各种基础设施和工厂，那么战争也就根本不用打了。
可靠性和安全性要通过多个方面的工作来保证，包括管理角度、物理防护角度等等。落实到IT技术上，也会有多个层面的工作。比如，在操作系统层面，我们会进行可靠性方面的增强，尽量消除由于硬件的原因而产生的数据错误，比如网络传输中的数据错误、由于存储设备的原因导致的数据错误，等等。
从软件开发和运行的角度，在可靠性和安全性方面也有很多可以提升的地方。比如，传统的软件运行方式，代码段的地址都是固定的，所以就会比较容易导致攻击，比如内存溢出攻击。如果你的运行机制，让每个函数的代码地址都是随机的，那么就可能避开这种类型的攻击。
通过我们前面这些对自控程序的运行特征的分析，你会发现它确实跟我们普通的桌面软件、服务端软件、移动APP软件都不太相同。所以，针对这个领域，我们就需要专门的开发工具。那我们就看看这个领域的开发工具都有哪些特点。
自控系统的开发平台由于自控领域自身的独特性，所以多年来这个领域也发展出了一系列独特的技术。这些技术被统称为OT，也就是Operational Technology。而你熟悉的互联网系统等，则属于IT领域。在OT领域，也形成了相应的国际组织和技术标准。在过去，这些组合和标准的话语权主要在国外一些企业的手中。
在OT领域，软件开发被叫做“组态”开发。组态是英文Configuration的意思。从字面上你可以这样理解，我们给控制器开发的软件，相当于是对控制器在做配置。
而这些控制器呢，在OT领域有个广为人知的名称，叫做PLC，也就是可编程控制器（Program Logic Controller）。那么我们可以怎么为可编程控制器编程呢？
根据相关国际标准（IEC 61131-3），如果我们要给PLC编程，可以使用5中不同的编程语言，如下图：
首先是文本化的编程语言。我们平常用的编程语言其实都是文本化的，这里面又细分为两种。一种是指令表，它相当于一种语法特别简单的计算机语言。虽然简单，但是对某些编程需求来说却足够。第二种是结构化的文本，这个跟普通的高级语言差不多，语法上有点像Pascal语言。
除了这两种文本化的编程语言以外，还有三种图形化编程语言，包括梯形图、功能块图和顺序功能流图。我相信，这几个图对大多数IT领域的同学来说，应该都不太熟悉。但对于弱电领域或OT领域的很多工程师来说，阅读这些图是他们的基本功。
通过这些图，他们就能很容易地理解程序的逻辑。其实在IT领域，一直也有图形化编程的方式，比如少儿编程领域，就可以通过拖拉图形块的方式来编程。而最近越来越为人所知的低代码开发平台，也大量采用了图形化编程的方式。
我这里给出了几张图，是对某个组态开发平台的截屏，可以帮助你更直观地理解这些编程语言。
那么，问题来了，你可以怎么来利用我们这门课学到的知识点，来实现上面这样一个开发平台呢？
首先，针对这5种语言，无论是文本化的语言，还是图形化的语言，你都可以利用词法分析、语法分析和语义分析技术，形成统一的、正确的AST。
第二，基于这个统一的AST，你再可以继续编译成机器码。我们在课程里讲过了如何针对x86-64架构的CPU生成汇编代码。不过呢，你要根据PLC所采用的芯片，来为它生成针对该芯片的汇编代码。一般芯片厂商都要提供工具链，能够把相应的汇编代码生成机器码。
第三，我们要设计一个专门的运行时。在我们的课程中，我们已经实现过虚拟机，这就是一种运行时。不过，针对OT的需求，PLC的运行时要复杂一些，比如要能够实现软件模块的动态加载和更新的管理、代码地址的转换、状态信息的维护，还有与通讯模块和底层操作系统的衔接等工作。
第四，我们要对程序进行优化。对于比较复杂的控制逻辑，我们要运用优化算法，提高程序的性能。程序的性能越高，可以满足的实时性要求就越高。像控制机器人臂这样的场景，对实时性要求就是很高的。如果我们不把代码进行充分优化，那就很难满足这些高实时性场景的要求。
所以，我们在课程的第三部分，会专门花时间学习优化技术。如果你能把优化技术也掌握透彻，那么你就有可能成为这个领域的顶级技术专家了。
通过上面的这些分析，你会发现，其实很多知识点，我们在前面的课程中都已经涉及了，还有一些知识点我们会在后面继续学习。所以，只要你认真掌握了我们这门课的内容，你基本上就可以胜任这些技术工作了！
课程小结今天的加餐，我分享了自动控制领域的一些背景信息，也讨论了如何针对这个领域的需求来研发相应的组态软件平台。我写这篇加餐其实有几个目的：
第一，是开阔你的视野。你可能并不是OT领域的技术人员，以后也不会做OT有关的事情。但是，它山之石可以攻玉。OT和IT在发展过程中，一直在互相影响。比如，OT处理高可靠性的一些思路，就有可能用于高可靠的IT应用中。
第二，我希望你能理解我们这节课的知识点，是怎么用于解决具体领域的问题的。比如，你可能发现，我在这门课里特别重视让你理解程序的运行机制，包括程序跟CPU架构的关系、跟操作系统的关系、理解ABI等等。从今天的分享中你会看到，要解决一个特定领域的问题，特别是当你需要自己研发相关工具的时候，这些知识都很重要。
最后，我也希望通过今天这节课，能让工业领域之外的人也了解一点工业软件。毕竟，工业是我们国家的立身之本。而工业领域的基础软件，还有很多工作，需要有志之士参与进来，提升我们国家在这个领域的创新能力和话语权。
我在后面的加餐里，还准备给你分析一些其他的应用领域和开发工具。我们总说“学以致用”，了解更多的应用场景，也会有助于你理解和掌握我们这门课程的知识点。
思考题如果你是来自于自控领域的，我想请你帮我补充一些信息，包括自控领域的其他应用场景、编程技术等等。
如果你来自其他领域，那么我想问问，你们的领域有没有跟自控领域类似的技术问题，以至于需要研发专门的开发平台呢？欢迎在留言区和我分享。
我是宫文学，我们下节课见。
ul { list-style: none; display: block; list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } li { display: list-item; text-align: -webkit-match-parent; } .</description></item><item><title>开篇词｜让我们来写一门计算机语言吧</title><link>https://artisanbox.github.io/3/46/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/46/</guid><description>你好，我是宫文学，一名技术创业者。
20多年前，我从北大毕业，搞过一些基础软件，也创过业，最近也一直在研究编译器、操作系统这样的底层技术。
我其实是极客时间的老面孔了，我曾在极客时间开过两门课，《编译原理之美》和《编译原理实战》。这两门课都聚焦于编译技术，一个是“读万卷书”，带你掌握编译原理；另一个是“行万里路”，教你怎么用编译技术。
今天我又设计了这门新课，带你来实现一门计算机语言。但是，你要知道，对于实现一门计算机语言而言，编译技术只是构成要素之一。它还有另外两块大的要素：一个是计算机语言的特性，包括类型系统、面向对象、函数式编程等；另一个是运行时技术，如虚拟机技术、内存管理等。
通过这门课你更好地把握计算机语言中涉及的各类技术的全貌，体会一下实现一门计算机语言的过程。
可能你还有点懵：我为啥要经历实现一门计算机语言的过程呢？这件事能帮我们提升哪些方面的能力或者成就感呢？接下来，我慢慢告诉你。
为什么要自己折腾一门编程语言？现在，每个程序员都熟悉一门或几门计算机语言，但是，我们很少有人想过自己去动手实现一门语言。又或者，虽然豪情万丈地计划过，却又因为种种原因不曾真正付诸实践。
当然，我们也会为自己找很多理由。
最常见的想法是，计算机语言已经很多了，我们会用就行，干嘛要自己去实现呢？另一个常见的想法是，计算机语言，我学习起来都挺不容易，要想去实现它，那更是难以逾越的吧？
这些顾虑看起来都很有说服力，可是，尽管如此，仍然有不少人还是会摆脱这些顾虑，去动手亲自实现一下计算机语言。为什么要做这样看上去很不理性的事情呢？我从我自身的体会来谈一下。
第一，实现一门计算机语言所带来的能力，是真的有用。
我们有时候觉得实现一门计算机语言这样的事情，纯属闲着没事干，因为要让一门计算机语言成功的机会太渺茫了，条件太苛刻了。
不过，在实现一门计算机语言的时候，你能接触到编译技术、运行时技术、汇编语言、硬件架构和各种算法，基本上是从顶层到底层把技术做穿。有了这些硬功夫，其实你已经能够胜任大多数高层次的软件开发工作了。比如，据我了解，Python语言的异步IO模块的开源贡献者，前一阵创业就去做一种创新的异步数据库产品了。
你一样也可以。从前你只会用人家写的东西，现在你要自己来实现了，肯定能更好地理解这套东西的核心逻辑，也能获得更多技术上的高维优势。最现实的就是你能拿下一个个难啃的技术难题，获得更多的晋升机会。
第二，不仅有用，而且这个过程真的很爽。
在我的前两门课里，有同学在实现了一个简单的脚本解释器之后，留言说“激动得浑身发抖”。是的，钻研一些比较深入的技术，会给人带来极大的成就感。特别是对于天天使用计算机语言的程序员来说，如果你有机会把计算机语言实现一遍，洞悉其中的技术秘密，那带来的成就感更是难以比拟的！
第三，像计算机语言这样的领域，更是大有前景。
如果你在关注中国技术发展，那你肯定知道我们目前正奋力在补基础技术方面的课，希望有朝一日也能拥有我们中国自己的优秀基础软件，比如HarmonyOS就在做这种尝试。而且，我们会看到中国涌现出越来越多的编程平台，很多产品会具备二次编程能力，甚至我们自己的计算机语言也会出现并逐步成熟。
要实现这样的突破，需要有更多具备底层编程能力的人才加入进来，要能够深刻理解程序在计算机硬件和操作系统之上运行的基础机制，以及计算机语言编译和运行所需要的技术。而学习如何实现一门计算机语言的过程，就能够带给你这些方面的提高。
现在，我相信你已经了解了，为什么你有必要掌握实现一门计算机语言所涉及的各种技术。不管仅仅是兴趣爱好的原因，还是为了自己的发展，甚至是为了在科技创新的趋势中弄潮，我都邀请你参与进来，一起来玩一玩这些技术。
而要开始实现一门计算机语言，我们首先就需要做一个决策：去实现一门什么样的语言？
我要带你实现什么样的语言？首先，我否决了去设计一门全新的语言。
因为设计一门语言真的很有难度，也是最容易引起争议的话题。而且，这项工作不仅是一项技术工作，还是一个产品设计工作，需要兼顾艺术性和用户体验，是个见仁见智的话题。
其次，我也不想像一些教科书那样，去实现一个玩具语言，这些语言往往不具备最后真正意义上的实用性。
经过几番思考，最终我选择去实现一门已经存在的语言：TypeScript。一门计算机语言其实可以有多个具体实现，像JavaScript就有V8（用于Chrome和Node.js）、TraceMonkey（用于FireFox）、QuickJS等多个不同的实现，每个实现都有不同的适用场景。而我要带你做的是，TypeScript的一个全新的实现。
TypeScript（以及JavaScript）的程序员群体相当庞大，并且它还具备编译成原生应用的潜力，所以HarmonyOS选择了TypeScript作为主力开发语言。
我前一阵参与发起了一个开源工业操作系统的项目。为顺应HarmonyOS的趋势，我也准备用TypeScript实现工业控制软件的开发。过去这些领域都是用C++做开发，其实用TS也完全可以。我甚至也跟JavaScript（ECMAScript）标准组的一名专家热烈讨论过，我们可以把HarmonyOS的基于TypeScript的前端开发工具扩展开来，用于支持安卓、IOS、桌面应用乃至小程序的开发，变成一个跨平台的开发工具，这也完全可以。
所以说，我们这门课选择TypeScript，是看好它未来有更大的发展空间。HarmonyOS已经开了个头，我们还可以做更多的探索。
而且，这门课的大部分内容，比如编译功能等，我们也是采用TypeScript来实现的。对于前端工程师来说，他们本身就很熟悉TypeScript。对于众多的后端工程师而言，由于TypeScript是静态类型的语言，所以他们上手起来也会很快。对于移动端的开发者而言，未来肯定需要了解在HarmonyOS上如何开发应用，所以熟悉一下TypeScript也是有必要的。
那接下来，我们看看在这门课里，我会带你完成哪些工作和挑战。
我会带着你完成什么挑战？总的来说，实现一门计算机语言，我们需要实现编译器、运行时，还要实现面向对象等各种语言特性。
具体一点，首先，我会带着你实现一个纯手写的编译器前端。
编译器前端指的是词法分析、语法分析和语义分析功能。我们目前使用的大多数计算机语言，比如Java、Go、JavaScript等，其编译器前端功能都是纯手写的，而不是采用工具生成的。我会带你了解那些被这些语言所广泛采用的最佳实践，比如LL算法、运算符优先级算法等等。
这种纯手写的实现方式，能让你最大程度体会相关算法的原理。另外，也非常有利于你根据自己的需要进行修改，来满足特定领域的需求。比如，我同学的公司有一个产品，支持在浏览器里编写代码，处理遥感数据。这样的需求，完全可以用TypeScript实现，再编译成JavaScript在浏览器里运行即可。
第二，我还会带你实现纯手写的编译器后端。
编译器后端指的是生成目标代码的功能，而目标代码呢，指的是字节码或汇编代码。编译器后端不仅要生成代码，还要对代码进行优化，尽量提升它的性能。
编译器后端的工作量通常更大，所以像Rust、Julia等新兴起的语言，往往采用一个后端工具，比如LLVM，而不是自己编写后端，这样可以节省大量的工作。不过这个方式也有缺陷，比如针对移动应用或者浏览器运行环境，在资源占用、即时编译速度等方面就不够理想。所以，像JVM、Android的运行时、V8等，都会自己去实现后端。
而且，如果你对语言的运行机制有特殊的要求，并且跟C/C++这些不同，那么你最好自己实现一个后端，比如Go语言就是这样。
编译器后端通常还包含大量的优化算法（有时候，我们把这些优化功能归为中端），这些优化算法具有比较强的工程性，所以教科书里的描述往往不够具体，也不能体现业界的一些最佳实践。在这门课里呢，我们可以自己动手去体会这些最佳实践，包括基于图的IR，以及一些优化算法，从而对优化算法的理解更加具象化。
在编译器后端里，因为我们还要生成汇编代码，所以能带你掌握汇编语言的精髓。在实现一些系统级软件的时候，我们有时候必须能够想象出来，这些软件的逻辑落实到汇编代码层面是什么样子的，这样才能确定最佳的技术策略。而破除对汇编代码的陌生感，是打通技术人员奇经八脉的重要一环。
第三，我还会带你实现多个运行时机制。
要让编译后的程序运行起来，我们必须要设计程序的运行机制。当然了，让一个程序跑起来的方法很多。在这门课里，我将带你实现多种运行时机制，让你能体会它们各自的设计思想，并能进行相互间的比较。
首先，我会带你实现一个AST解释器，也就是通过遍历AST的方式来运行程序。这种方式虽然简单，但很实用，对很多应用需求来说都够用了。
接着，我会把AST编译成字节码，在虚拟机上运行。像Java、JavaScript、Python等语言，都支持这种运行方式。在这个环节，我们会讲解栈机和寄存器机的差别，设计字节码，并实现一个栈机。
并且，我还会带你实现两个不同版本的虚拟机，一个是基于TypeScript实现的，一个是基于C语言实现的。当你采用C语言时，你对于运行时的一些实现细节拥有更多的掌控能力。你会看到，只有掌控了像内存分配这些技术细节，才能让基于C语言的虚拟机在性能上胜出。
当然，最后，我还会带你把程序编译成本地可执行文件来运行。在这个过程中，我最希望你能够彻底搞清楚，当一个编译成本地代码的程序在运行的时候，到底CPU、操作系统和计算机语言本身各自都扮演了什么角色。这是打通技术上的奇经八脉来说，是非常重要的一环。
你会发现，作为计算机语言的实现者，你其实拥有比自己想象中大得多的发挥空间。所以，当你实现像协程、JIT机制等高级特性的时候，就能够更好地设计或理解相应的技术方案。
对于一些技术细节，比如通过汇编代码做栈桢的管理，我们也会上手获得细致的理解。基于这些透彻的理解，你会有能力基于栈桢的机制来实现尾递归和尾调用的优化，从而让你增强对于物理机的运行机制的掌控感。
最重要的是，每实现一个运行时机制，我们都会进行性能的测试和比拼。这些真实的测试和数据，会让你对于运行时机制产生非常具象的感受。下面这张图就是在课程的某一讲中，我们集齐了5个版本的运行时进行对比测试的结果。更重要的是，这几个版本的运行时，你都可以自己动手做出来。
第四，我会带你理解一些高级语言的特性是如何实现的。
在实现了计算机语言的一些基本特性以后，我们会去讨论一些高级一点的话题，比如类型体系的实现；在支持面向对象时，如何用最小的代价实现运行时的多态特性；在支持函数编程特性时，又是如何实现高阶函数功能、闭包功能等。
而对象、闭包等特性，又不可避免地会引出运行时的内存管理问题，因此，我们也会实现一个自己的垃圾收集器。
我会怎么带你一步步实现？看着我前面大段大段的介绍，你觉得这些东西难吗？有编译，有运行时，还有一些更高级的语言特性，看上去还挺难吧？内容也很多，你可能心里已经开始打“退堂鼓”了：这么多内容，难度又不小，我能跟下来吗？
请打住！其实你根本不用担心。我在课程内容的设计上是逐步递进的，你会自然而然地跟着走下来，不会感觉有很大的学习困难。我会从原理出发，带你走完整个语言的实现过程，一方面能避免各种繁琐的编程工作，对你理解原理带来干扰；另一方面又能保留足够多的技术细节，让我们的教学语言具备足够的实用性。
哪怕你只学了几节课，你也能够掌握编译器前端的基础技能，实现一个AST解释器。再学几节课呢，就能搞出一个基于TypeScript的虚拟机出来。然后再加两节呢，又搞出一个C语言版本的虚拟机出来。不知不觉间，你就走出很远，爬得很高了。
在第一部分起步篇中，我会主要选取少量的语言特性，带你迅速实现从前到后的技术贯穿，这样你就能对计算机语言涉及的各项技术有一个全局性的了解。
这一部分又分成了三个阶段。在第一个阶段，我会带你用AST解释器把TypeScript跑起来，并在这个过程中带你掌握业界最常用的词法分析技术、语法分析技术和语义分析技术。在第二个阶段，我会升级解释运行的机制，带你掌握字节码技术和栈机。而在第三个阶段，我们就已经能够让程序编译成本地代码运行了！
紧接着在第二部分进阶篇呢，我会把这条路拓宽，也就是增加更丰富的语言特性，比如支持更多的数据类型、支持面向对象和函数式编程特性，等等。在这一部分，你能够丰富知识面，从而有能力解决更多的基础技术问题，其中就有内存管理这个关键技术。
学完进阶篇以后，你对实现一门计算机语言中所涉及的知识点，掌握得就比较全面了。剩下的知识点，通常只有专门从事这个领域工作的人或研究人员才会去涉足，这里面就包含编译优化技术。
每一门语言都会特别重视性能，而优化技术就是提升语言性能的关键。我还看到现实中一些做开发平台的项目中，真正的硬骨头往往就是优化技术。所以在最后在第三部分优化篇里，我就主要介绍一下优化技术。我会用比较浅显和直观的方式，让你了解Java、JavaScript等语言所采用的前沿优化技术，洞悉它们最深处的奥秘，让你有能力去承担那些攻坚性的任务。
更具体的详细目录你可以看看这个：
如果把实现一门计算机语言看成是一场冒险，那么现在我已经给你规划好了目标和路线，也会在路途中给你不断充实“武器”和“弹药”。
但俗语也有说，“兵马未动，粮草先行。”贴心的我还给你储备好了“衣物”和“粮草”，我给你备好了有着上万行的实验代码的代码库。而且，我们课中采用的技术，是基于我手头正在做的一门实用级语言为素材的，而且会作为开源项目一直进行版本迭代，所以你甚至可以拿这个开源项目作为自己工作的基础。当然了，我也无比欢迎你加入其中和我一起共建，为我们的“后勤保障”添砖加瓦。
好了，现在万事俱备，只欠东风。加入我吧，我已经迫不及待和你开启这一场计算机语言的冒险了！
欢迎点击链接加入交流群 ul { list-style: none; display: block; list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } li { display: list-item; text-align: -webkit-match-parent; } .</description></item><item><title>期中测试｜快来检验你在起步篇的学习成果吧</title><link>https://artisanbox.github.io/3/49/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/49/</guid><description>你好，我是宫文学。
不知不觉间，我们的课程已经更新过半了。前几天，我们也更新完了第一部分，也就是起步篇的内容。到这里，我其实已经带你完整地跑完了，实现一门计算机语言需要的全部流程了。不知道你学习得怎么样呀？不如做套题来检验一下吧？
趁着国庆假期，我根据我们第一部分起步篇里讲过的知识，给你出了20道选择题，你可以检验一下自己的学习成果。如果你有什么不理解的地方，欢迎在留言区留言，也可以直接来我们的微信交流群找我。
快点击下面的按钮开始测试吧，我期待着你满分的好消息。</description></item><item><title>期末考试｜实现编程语言这些核心知识点，你掌握得咋样了？</title><link>https://artisanbox.github.io/3/48/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/48/</guid><description>你好，我是宫文学。
我们的课程已接近尾声，要学的内容我们都已经全部学完了。不知道你掌握得怎么样了呢？今天，我给你准备了20道选择题，满分100分，范围囊括我们这门课的众多核心知识，一起来挑战一下吧！
如果有什么不明白的，欢迎直接在留言区提问，也可以在交流群找我，期待你满分的好消息！
另外，我还给你准备了一份调查问卷，想听一下你对我这门课的看法和建议。题目不多，两分钟就可以填完，非常希望能看到你的反馈。</description></item><item><title>结束语｜等待你大展身手的那些领域</title><link>https://artisanbox.github.io/3/45/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/45/</guid><description>你好，我是宫文学。
到今天为止，我们这门课的主要内容就都更新完了。不过，还有一些补充性的内容，我会通过加餐和开源项目的方式，继续和你保持沟通。
今天的结束语，我想跟你探讨一下，学习实现一门语言的相关技术，到底会有什么用途。
我会分成领域编程语言、平台级的软件和通用编程语言这三个话题，分析一下 编程语言技术能帮助你抓住哪些机会，让你有机会从普通的程序员进阶成大神级的程序员，并创造出一些卓越的产品。
首先，我们来谈谈领域编程语言这个话题。
领域编程语言（DSL）对于我们大部分同学来说，其实很难有机会，或者也没有这个意愿，去参与实现一门通用性编程语言。不过，其实在大部分情况下，我们也没有必要追求那么大的目标。有时候，针对我们所在的领域，实现一门领域编程语言，就是很有意义、很有成就感的事情。
我举几个我遇到的DSL的例子，看看能否抛转引玉，让你找到更多可以设计和使用DSL的场景。
MiniZinc：最优化领域的开发工具在2020年的12月，我曾经研究了一下最优化算法相关的技术和工具，看看它能否用于我们的一个产品。
很多同学在大学都学过最优化相关的理论，像线性规划、非线性规划这些，都属于这个领域。你也可能听说过运筹学，它们的意思差不多。最优化理论在实践中有很多用途。比如，我要解决一个应用问题，就是在某个领域，有很多员工，也有很多任务要完成。每个员工的技能是不同的，我需要通过算法来安排这些员工的工作，取得整体最优的效果。
为了实现最优化求解，有人开发了各种求解器，有商业的，也有开源的。但对于我一个新手来说，我一开始并不知道要用哪个工具，有点茫然。
通过某些途径，我了解到了MiniZinc这个工具。这个工具提供了一种DSL，能够描述各种最优化问题，然后调用各种不同的求解器来求解。比如在下图，你能看到菜单栏有一个下拉菜单，里面有多个求解器。
MiniZinc这个工具一下子解决了我的两个需求。首先，这个DSL很友好、很直观。你完全可以按照最优化的理论，描述一个问题的变量、参数、约束条件，然后就可以求解了，非常方便。第二，我暂时也不用关心不同的求解器的差别，可以随便选一个先用着，或者换着用不同的求解器，看看它们在性能和求解结果有哪些差异。
所以我很快就用MiniZinc编写了几个小程序来验证我的想法，并在较短的时间内取得了一些成果。
在使用这个工具的时候，我就在想，上过我这门课的同学，有没有能力做这么一个工具呢？我们来分析一下。
其实，要实现MiniZinc，主要的工作就是实现一个编译器的前端，做词法分析、语法分析和语义分析工作。这个DSL的语法和语义都不是很复杂，所以工作量并不大。
做完前端的工作以后，程序就可以基于AST来解释执行了。解释执行的过程，其实就是调用各个求解器的API，并把结果显示到界面上。
这么一个小工具，会给那些最优化领域的工作者和科研人员带来很大的便利。因为他们通常专注于研究算法，对于通用的计算机编程并不是很熟练。
那在你的领域中，是不是也有这样的情况呢？你是IT专业的人员，而你同事可能是其他专业的专家，比如是工程专家、投资专家、财务专家等等。你能否针对他们的领域，设计出一些DSL，并提供一个开发工具来解决他们的一些痛点问题呢？
我们再看看第二个例子，这个例子是遥感领域的一个二次开发平台。
遥感领域的二次开发平台我硕士的专业是在遥感和GIS领域，我有一个硕士同学在这个领域做出了一个上市公司。他们有一个产品，是一个遥感云平台，也就是把全国各地的很多遥感资料都放到云上管理。这个云平台里有一个开发工具，能够让用户在浏览器里编写程序，调用云平台的API，实现遥感数据分析等功能。
据说这个平台是跟Google Earth对标的，国外很多科学家都会在Google Earth平台上写程序处理遥感数据，并构建自己领域的应用。
如果让你去实现这个开发工具，你会怎么做呢？
首先，你肯定需要一个基于Web的代码编辑器，这方面有好几个开源工具，所以这点并不是难题。
接下来，你仍然要实现编译器前端的工作。这一次，你需要编译的是JavaScript语言，它的语法特性和语义特性都比较多，所以实现的工作量要大一些。你可以把我们现在的词法分析器和语法分析器改一改，来实现JavaScript的解析。如果你想偷懒，还可以直接用antlr和现成的语法规则生成一下解析器。不过，无论如何，语义分析的工作是省不了的。你需要建立符号表、进行符号的消解，但不需要像我们这门课这样做那么多的类型处理。
完成编译器前端以后，还要做些什么呢？我们还要做一些中端的优化工作。因为这个开发工具要调用与遥感有关的API。而如何调用这些API才会让效率最高呢？所以这一点上，我们实际上是要做一些优化的。
做完中端优化后，后续的编译和运行过程，有可能只要交给一个成熟的JavaScript引擎就可以了。
怎么样？使用我们这门课上学过的技术，你可以把很多科研工作者、各个行业的应用开发人员，都聚集到一个平台上，充分释放海量遥感数据的价值，这是不是一件挺酷的事情？
接下来，我再举一个CAD领域的例子，这个产品是OpenCAD。
OpenCAD几个月前，我一时兴起买了一台3D打印机，想自己打印点好玩的东西。但是在打印之前，还需要建立3D模型，所以我就搜了搜建模工具，发现了一个叫做OpenCAD的软件。
这个软件提供了一个编程界面。你可以在这个界面中，通过编程来创建长方体、圆柱体这样的三维对象，也可以通过编程来控制它们的位置、旋转的角度。
另外，你还可以创建模块，把多个基础的对象拼成复杂的对象，比如把一些长方体、圆柱体拼成一辆车。之后，这辆车就可以作为一个整体，用来构架更复杂的场景。
并且，模块还可以带参数，就像一个函数或者一个类那样。你通过调整模块的参数，就可以调整生成的3D对象。比如同样是一辆车，你可以通过调整参数生成一辆很大的车，也可以生成一辆玩具车。
我并不熟悉CAD领域，所以很难把这个软件跟其他CAD软件做客观地对比。不过，我能够看出，OpenCAD通过编程来建模的形式，有几个特别的优势：
第一个优势是精准。在建立某些机械模型的时候，零件的大小、位置等信息必须是精准的。而使用编程语言，你可以用数学公式做出各种精准地计算。比如，上面的例子就使用了三角函数来精确的绘制曲线。
第二个优势是可重用性。可重用性是编程语言的基本特征，模块、函数、类，都是可重用的元素。并且，这种可重用的元素都是参数化的。在不同的场景中，可以通过调整参数来获得想要的功能。
所以，要开发一款优秀的CAD软件，我们需要充分吸收编程语言的技术。类似的领域还有建筑建模软件（BIM）、城市建模软件（CIM）等，现在很多公司的产品，都声称提供了低代码的数字城市平台，那这些产品也应该充分使用计算机语言的技术，并形成特定领域的DSL。
你看，我们现在分析了三个案例，看到了三个领域对计算机语言的要求。其实，这样的领域还有很多，并且它们都可以受益于领域编程语言。我希望你能受到这些例子的启发，看看在自己的领域内还有没有这样的需求，说不定你会也能做出一些开创性的事情。因为这样级别的工作，必须在掌握了我们这门课的知识体系以后，你才有能力驾驭。
上面这些采用了DSL的软件，基本都属于一些平台级的软件。那我们再围绕如何实现平台级的软件这个话题，展开讨论一下编程语言技术的作用，和你当前面对的机会。
实现平台级的软件Lisp语言的重要推广者、《黑客与画家》的作者、创业孵化器Y Combinator的创始人保罗·格雷厄姆曾经说过一段话，大概就是说，每个软件演化到最后，都会内置一个Lisp语言的实现。
他的这段话，其实是说，任何软件，如果想覆盖尽量多的应用场景，都需要提供一定的编程能力。我举几个例子来说明一下这个观点：
为了更高效的管理很多服务器上的操作系统，搞运维的技术人员都会用Python来写脚本。这个时候，我们是在用脚本语言来扩展操作系统的功能； 数据库系统之所以能够满足各种应用的需求，是因为它是通过SQL语言来访问数据库的功能； 微软的各种应用产品，几乎都提供了二次开发的能力，这让你可以基于微软的产品形成各种不同领域的解决方案。比如，如果你能够熟练使用Excel里面的宏和编程技术，你可以完成很多的数据分析需求； 三维游戏引擎提供编程功能，让你能够创建各种三维游戏场景； 各种报表或BI工具，都提供了定义数据源、定义报表公式等功能，方便你设计各种报表； 工作流或BPM系统，需要提供流程设计、公式定义和自定义逻辑的功能，来满足各种不同的流程场景了； 对于一个API网关来说，需要提供一定的编程逻辑，来定义在什么情况下，把API访问路由到哪个微服务，或者进行熔断。 类似的例子还有很多。
如果你的软件只是为某个用户个性化定制的，只需要满足这一个客户的需求，那么你只要弄清楚需求，然后实现出来就行了。但如果你想让更多的用户使用你的软件，那该怎么办呢？
在少量情况下，你可以设计一套标准的软件，并让所有的用户都满意。比如，几乎所有的字处理软件的功能都差不多，你只需要购买一个License就行了，很少会提出个性化的需求。
但这样的通用软件是很少的。更多的情况下，特别是在企业应用领域，我们都需要对软件的标准功能做一定的调整，让它符合某个客户特定的需求。比如，你可能需要调整某些业务规则、某些流程、某些数据项，等等。
而国内大部分软件公司，目前都是通过修改源代码来满足这些个性化的需求。这就导致软件的实施成本很高，版本难以维护，这是很多应用软件开发商所处的困境。你在的公司，也可能存在这样的困境。
这个时候，如果你能把应用软件上升为平台，也就是在不修改原来的源代码的基础上，提供二次开发的能力，二次开发的部分由各个客户自行维护，才可以从根本上打破这种困境。从这个角度看，我们每个同学所在的领域，都存在着大量的潜在机会，采用这门课学习到的编程语言技术，你可以把你所在领域的软件，提升成一个平台级的软件。
还有最后一种情况，就是你本来就要开发平台级的软件，比如数据库系统、表单系统、报表系统、游戏引擎等，那么编程能力就更加是缺省的要求。
不管怎样，只要你想让你的软件变成平台级的软件，具备适应各种不同应用场景的能力，具备扩展功能的能力，你就需要采用这门课教给你的编程语言技术，对这些软件进行改造。在我看来，国内有太多软件产品需要进行这种提升了，这都是你可以施展身手的机会。
好了，聊完了领域编程语言和平台级软件以后，你还有没有其他机会来大显身手呢？有的，这就是实现通用编程语言这个终极大Boss。
通用编程语言像Java、C、Go这些语言，能够用于很多领域，所以它们被叫做通用编程语言。到目前为止，我们国家还没有正式发布的、被广泛接受的通用编程语言。
不过信息灵通的同学可能也知道，我们多个大厂，其实都在内部酝酿和研发这样的语言。我本人也在参与某门语言的内测和评价工作。鉴于保密协议的约束，在这门语言没有正式发布前，我是不能谈论它的名称和技术细节的。
所以，如果你对实现通用编程语言很感兴趣的话，其实现在就有机会进入这些团队，贡献自己的一份力量。
如果你参与了这样的项目团队，那么你就可以选定一个具体的领域，深入研究我们这门课涉及的那些知识点。有人可能变成语法分析的专家，有人可能成为优化技术的专家，有人可能成为后端技术的专家，还有人可能会成为运行时方面的专家。
而我相信，正是你们这些未来的专家，将来必然会让中国的通用编程语言领域大放异彩！
写在最后这门课程的主体内容，到这里就正式结束了，不过我还会跟同学们保持联系。保持联系的方式有几个，一是开源项目PlayScript，一是计划不定期发布的几篇加餐，还有就是这门课的微信群。
我会继续在编程语言的领域探索和实践，希望能够跟你多多交流。也希望你在前进的道路上，能够找到更多的志同道合的朋友，一起砥砺前行，创造出优秀的作品！
另外，我还给你准备了一份毕业问卷，题目不多，希望你能在问卷里聊一聊你对这门课的看法。欢迎你点击下面的图片，用1～2分钟的时间填写一下。当然了，如果你对课程内容还有什么问题，也欢迎你在留言区或交流群继续提问，我会持续回复你的留言。</description></item><item><title>课前热身｜开始学习之前我们要准备什么？</title><link>https://artisanbox.github.io/3/47/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/3/47/</guid><description>你好！我是宫文学，欢迎来到《手把手带你写一门编程语言》的课程。
其实，你从课程题目就可以看出，我们这个课强调动手实践。所以在这一节课，我要给你介绍一下我们这个课程示例代码所采用的计算机语言，以及相关编程环境的搭建。这样，会方便你阅读、运行和修改课程的示例代码。
对于课程里用到的汇编语言、编译原理知识，如果你之前没有相关的经验，也不要担心。我会介绍一下我们这方面的设计思路，保证你通过这个课程会更快、更扎实地掌握它们。
通过这篇导读，你会对课程里用到的语言、工具、技术心里有数，以便更好地开启你的学习之旅。
好，我们先从使用的计算机语言和环境说起。
怎么快速上手TypeScript语言我们这个课程的目标呢，是要实现TypeScript的编译器和各种运行时。既然如此，那么我就尽可能地用TypeScript来实现这个目标。
虽然我们这个课程主体的代码都是用TypeScript写的，但我正式使用TypeScript其实是从2021年5月份开始，也就是我开始准备这个课的时间。
我知道你肯定会问：用几个月的时间，既要了解TypeScript，又要用TypeScript写自己的编译器，是不是太不靠谱了？当然，你可能也是因为要学习这门课程，第一次使用TypeScript，所以我就分享一下自己的一些经验。
第一，使用它！
我一直觉得，真正的语言学习开始于你使用它的那一刻。否则，你就是一直看这门语言的资料，也只能留下个大概印象，而且很快就会忘掉，只有动手使用，才会形成肌肉记忆。比如，现在我一写for循环，手指不自觉地打出“for (let i = …)”或"for (let x of …)"开头，这就是形成肌肉记忆了。
第二，看资料！
说实在的，现在学习计算机语言实在是太方便了，各种资料应有尽有，又有很多热心同学在网上的分享，遇到什么需求一查就有，用过才会记住。
如果你让我推荐一本学习资料，我比较推荐流浪小猫写的开源电子书《TypeScript入门教程》。这个作者可能比较懂我想看什么，提供的内容会到点上。比如，我们做面向对象编程的时候，都关心该语言是否具备运行时的类型判断能力，因为这个功能几乎百分之百会被用到，而这个教程里就专门有类型断言的章节。
第三，靠经验直觉！
其实，很多同学都学过多门语言，那么学一门新语言的速度就会很快。有经验的程序员会建立一些直觉，能够猜到一门语言可能具备什么特性。
在准备课程代码的时候，我有一次要编写一个类，代表汇编指令中的寄存器操作数。而在x86的汇编指令中，不同位数的寄存器的名称是不一样的，所以，我需要用一个成员变量bits，来表示这个寄存器的位数。这个时候，我想当然地写出了下面的代码：
class Register extends Oprand{ bits:32|64 = 32; //寄存器的位数 ... } 也就是位数只能取两个值，要么是32，要么是64，赋其他值给它都是错误的。
在使用这个写法的时候，我其实不是很确定是否可以用两个值的集合来描述变量的类型，因为在教程里提到联合类型（Union Types）的时候，只是说了可以用两个类型的联合。我直觉上觉得也应该支持两个值的联合，因为如果我是TypeScript的作者，我可能不会忽视这种使用场景。我根据自己的猜测试了一下，然后就成功了。
如果上升到类型理论的高度，那么我们可以说，类型本来就是可以取的值的集合。但如果我们不上升到理论高度，仅凭直觉，其实也能去正确地使用类型。
说到老程序员的直觉，其实这门课程的一个重要目标，就是想帮你建立起更多的直觉，建立仅仅通过高级语言的语法表象就能看透其内部实现机制的能力，让计算机语言在你面前成为一个白盒子，从而让你能够更加自如地去支配不同的语言来为自己服务。
好了，了解了怎么上手以后，我们再来看看在这门课程中的TypeScript的环境配置问题。
TypeScript的环境配置我们这个课程关于TypeScript的环境配置主要包括这些：
1.编译和运行环境：Node.js。
首先，我使用Node.js来编译和运行TypeScript，所以你要先在自己的电脑上安装Node.js，配置好相应的环境。这方面的资料很多，我就不提供链接了。
2.安装和配置TypeScript。
使用下面的命令，可以安装TypeScript：
npm install typescript -g 之后，你可以用git命令下载示例代码：
git clone https://gitee.com/richard-gong/craft-a-language.git 在用git下载了示例代码以后，需要你在示例代码的目录中运行下面这个命令，安装示例程序依赖的node.js中的一些包。安装完毕以后，会在craft-a-language目录中建立一个node_modules子目录：
npm i --save-dev @types/node 3.IDE：Visual Studio Code（简称VS Code）。
我在课程里使用了VS Code作为IDE，VS Code缺省就支持TypeScript语言，毕竟这个IDE本身就是用TypeScript编写的。
而且，我们每一节课的代码，都会被放在我们代码库里的一个单独的目录下，比如01、02……在每个目录下，都会有几个json文件，是TypeScript的工程配置文件。你只要在目录下输入tsc，就会编译该工程的所有.ts文件。
打开tscongfig.json，你会看到我提供的一些配置项：
target项是编译目标，这里我用的是es6，因为es6具备了很多高级特性。 module项是模块管理工具，我们选用的是CommonJS。 另外，有“exclude”选项，是排除了一些.</description></item></channel></rss>