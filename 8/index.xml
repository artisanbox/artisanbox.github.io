<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MySQL 必知必会 on Gen 的学习笔记</title><link>https://artisanbox.github.io/8/</link><description>Recent content in MySQL 必知必会 on Gen 的学习笔记</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 08 Mar 2022 18:37:53 +0800</lastBuildDate><atom:link href="https://artisanbox.github.io/8/index.xml" rel="self" type="application/rss+xml"/><item><title>01_存储：一个完整的数据存储过程是怎样的？</title><link>https://artisanbox.github.io/8/1/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/1/</guid><description>你好，我是朱晓峰。今天，我想跟你聊一聊MySQL是怎么存储数据的。
存储数据是处理数据的第一步。在咱们的超市项目中，每天都要处理大量的商品，比如说进货、卖货、盘点库存，商品的种类很多，而且数量也比较大。只有正确地把数据存储起来，我们才能进行有效的处理和分析，进而对经营情况进行科学的评估，超市负责人在做决策时，就能够拿到数据支持。否则，只能是一团乱麻，没有头绪，也无从着手。
那么，怎样才能把用户各种经营相关的、纷繁复杂的数据，有序和高效地存储起来呢？
在MySQL中，一个完整的数据存储过程总共有4步，分别是创建数据库、确认字段、创建数据表、插入数据。
接下来，我就给你详细讲解一下这个过程的每一步，帮你掌握MySQL的数据存储机制。
先提醒你一句，这节课最后有一个视频，我在视频里演示了今天讲到的所有操作。我建议你学完文字以后，跟着视频实操一下。
好了，话不多说，我们现在开始。
创建MySQL数据库数据存储的第一步，就是创建数据库。
你可能会问，为啥我们要先创建一个数据库，而不是直接创建数据表呢？
这是个很好的问题。其实啊，这是因为，从系统架构的层次上看，MySQL数据库系统从大到小依次是数据库服务器、数据库、数据表、数据表的行与列。
安装程序已经帮我们安装了MySQL数据库服务器，所以，我们必须从创建数据库开始。
数据库是MySQL里面最大的存储单元。数据表、数据表里的数据，以及我们以后会学到的表与表之间的关系，还有在它们的基础上衍生出来的各种工具，都存储在数据库里面。没有数据库，数据表就没有载体，也就无法存储数据。
下面我就来给你具体介绍下，怎么在我们安装的MySQL服务器里面创建、删除和查看数据库。
1.如何创建数据库？创建数据库，我们已经在上节课介绍过了，你可以在Workbench的工作区，通过下面的SQL语句创建数据库“demo”：
CREATE DATABASE demo； 2.如何查看数据库？下面我们来看一下，如何查看数据库。
在Workbench的导航栏，我们可以看到数据库服务器里的所有数据库，如下图所示：
你也可以在Workbench右边的工作区，通过查询语句，查看所有的数据库：
mysql&amp;gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | demo | | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) 看到这儿，你是不是觉得很奇怪，为什么Workbench导航栏里面的数据库只有两个（我们创建的数据库“demo”和安装完MySQL就有的数据库“sys”）呢？
换句话说，为什么有的数据库我们可以在Workbench里面看到，有的数据库却必须通过查询语句才可以看到呢？要弄明白这个问题，你必须要知道这些数据库都是干什么的。
“demo”是我们通过SQL语句创建的数据库，是我们用来存储用户数据的，也是我们使用的主要数据库。 “information_schema”是MySQL系统自带的数据库，主要保存MySQL数据库服务器的系统信息，比如数据库的名称、数据表的名称、字段名称、存取权限、数据文件所在的文件夹和系统使用的文件夹，等等。 “performance_schema”是MySQL系统自带的数据库，可以用来监控MySQL的各类性能指标。 “sys”数据库是MySQL系统自带的数据库，主要作用是，以一种更容易被理解的方式展示MySQL数据库服务器的各类性能指标，帮助系统管理员和开发人员监控MySQL的技术性能。 “mysql”数据库保存了MySQL数据库服务器运行时需要的系统信息，比如数据文件夹、当前使用的字符集、约束检查信息，等等。 如果你是DBA，或者是MySQL数据库程序员，想深入了解MySQL数据库系统的相关信息，可以看下官方文档。
话说回来，为什么Workbench里面我们只能看到“demo”和“sys”这2个数据库呢？其实啊，这是因为，Workbench是图形化的管理工具，主要面向开发人员，“demo”和“sys”这2个数据库已经够用了。如果有特殊需求，比如，需要监控MySQL数据库各项性能指标、直接操作MySQL数据库系统文件等，可以由DBA通过SQL语句，查看其它的系统数据库。
确认字段数据存储流程的第二步是确认表的字段。
创建好数据库之后，我们选择要导入的Excel数据文件，MySQL会让我们确认新表中有哪些列，以及它们的数据类型。这些列就是MySQL数据表的字段。
MySQL数据表由行与列组成，一行就是一条数据记录，每一条数据记录都被分成许多列，一列就叫一个字段。每个字段都需要定义数据类型，这个数据类型叫做字段类型。
这样一来，每一条数据记录的每一个片段，就按照字段的定义被严格地管理起来了，从而使数据有序而且可靠。MySQL支持多种字段类型，字段的定义会影响数据的取值范围、精度，以及系统的可靠性，下节课我会重点给你讲一讲字段的定义。这里你只要选择系统默认的字段类型，就可以了。
创建数据表数据存储流程的第三步，是创建数据表。
当我们确认好了表的字段，点击下一步，Workbench就帮助我们创建了一张表。
MySQL中的数据表是什么呢？你可以把它看成用来存储数据的最主要工具。数据表对存储在里面的数据进行组织和管理，使数据变得有序，并且能够实现高效查询和处理。
虽然Workbench帮助我们创建了一个表，但大多数情况下，我们是不会先准备一个Excel文件，再通过Workbench的数据导入来创建表的，这样太麻烦了。我们可以通过SQL语句，自己来创建表。
具体咋做呢？我来介绍一下。</description></item><item><title>02_字段：这么多字段类型，该怎么定义？</title><link>https://artisanbox.github.io/8/2/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/2/</guid><description>你好，我是朱晓峰。
MySQL中有很多字段类型，比如整数、文本、浮点数，等等。如果类型定义合理，就能节省存储空间，提升数据查询和处理的速度，相反，如果数据类型定义不合理，就有可能会导致数据超出取值范围，引发系统报错，甚至可能会出现计算错误的情况，进而影响到整个系统。
之前，我们就遇到过这样一个问题：在销售流水表中，需要定义商品销售的数量。由于有称重商品，不能用整数，我们想当然地用了浮点数，为了确保精度，我们还用了DOUBLE类型。结果却造成了在没有找零的情况下，客人无法结账的重大错误。经过排查，我们才发现，原来DOUBLE类型是不精准的，不能使用。
你看，准确地定义字段类型，不但关系到数据存储的效率，而且会影响整个信息系统的可靠性。所以，我们必须要掌握不同字段的类型，包括它们的适用场景、定义方法，这节课，我们就聊一聊这个问题。
首先，我要说的是MySQL中最简单的数据类型：整数类型。
整数类型整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT，它们的区别如下表所示：
这么多整数类型，咱们该怎么选择呢？
其实，在评估用哪种整数类型的时候，你需要考虑存储空间和可靠性的平衡问题：一方面，用占用字节数少的整数类型可以节省存储空间；另一方面，要是为了节省存储空间，使用的整数类型取值范围太小，一旦遇到超出取值范围的情况，就可能引起系统错误，影响可靠性。
举个例子，在我们的项目中，商品编号采用的数据类型是INT。
我们之所以没有采用占用字节更少的SMALLINT类型整数，原因就在于，客户门店中流通的商品种类较多，而且，每天都有旧商品下架，新商品上架，这样不断迭代，日积月累。如果使用SMALLINT类型，虽然占用字节数比INT类型的整数少，但是却不能保证数据不会超出范围65535。相反，使用INT，就能确保有足够大的取值范围，不用担心数据超出范围影响可靠性的问题。
你要注意的是，在实际工作中，系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因此，我建议你首先确保数据不会超过取值范围，在这个前提之下，再去考虑如何节省存储空间。
接下来，我再给你介绍下浮点数类型和定点数类型。
浮点数类型和定点数类型浮点数和定点数类型的特点是可以处理小数，你可以把整数看成小数的一个特例。因此，浮点数和定点数的使用场景，就比整数大多了。
我们先来了解下MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。
FLOAT表示单精度浮点数； DOUBLE表示双精度浮点数； REAL默认就是DOUBLE。如果你把SQL模式设定为启用“REAL_AS_FLOAT”，那么，MySQL就认为REAL是FLOAT。如果要启用“REAL_AS_FLOAT”，就可以通过以下SQL语句实现： SET sql_mode = “REAL_AS_FLOAT”; FLOAT和DOUBLE这两种数据类型的区别是啥呢？其实就是，FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。
看到这儿，你有没有发现一个问题：为什么浮点数类型的无符号数取值范围，只相当于有符号数取值范围的一半，也就是只相当于有符号数取值范围大于等于零的部分呢？
其实，这里的原因是，MySQL是按照这个格式存储浮点数的：符号（S）、尾数（M）和阶码（E）。因此，无论有没有符号，MySQL的浮点数都会存储表示符号的部分。因此，所谓的无符号数取值范围，其实就是有符号数取值范围大于等于零的部分。
不过，我要提醒你的是，浮点数类型有个缺陷，就是不精准。因此，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。下面我来重点解释一下为什么MySQL的浮点数不够精准。
为了方便你理解，我来借助一个实际的例子演示下。
我们先创建一个表，如下所示：
CREATE TABLE demo.goodsmaster ( barcode TEXT, goodsname TEXT, price DOUBLE, itemnumber INT PRIMARY KEY AUTO_INCREMENT ); 运行这个语句，我们就创建了一个表，其中的字段“price”就是浮点数类型。我们再通过下面的SQL语句，给这个表插入几条数据：
-- 第一条 INSERT INTO demo.goodsmaster ( barcode, goodsname, price ) VALUES ( '0001', '书', 0.47 ); -- 第二条 INSERT INTO demo.goodsmaster ( barcode, goodsname, price ) VALUES ( '0002', '笔', 0.</description></item><item><title>03_表：怎么创建和修改数据表？</title><link>https://artisanbox.github.io/8/3/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/3/</guid><description>你好，我是朱晓峰。今天，我们来聊一聊怎么创建和修改数据表。
创建和修改数据表，是数据存储过程中的重要一环。我们不仅需要把表创建出来，还需要正确地设置限定条件，这样才能确保数据的一致性和完整性。同时，表中的数据会随着业务需求的变化而变化，添加和修改相应的字段也是常见的操作。这节课，我们就来学习下具体的方法。
在我们的超市项目里，客户经常需要进货，这就需要在MySQL数据库里面创建一个表，来管理进货相关的数据。我们先看看这个表里有什么内容。
假设这个表叫做进货单头表（importhead），如下图所示：
这里的1、2、3表示门店的3种进货方式，分别是配送中心配送、门店采买和供货商直供。
其中，“1（配送中心配送）”是标准进货方式。因为超市是连锁经营，为了确保商品质量和品类一致，超过9成的门店进货，是通过配送中心进行配送的。因此，我们希望这个字段的值能够默认是1，这样一来，除非有特别的指定，否则，门店进货单的进货方式，就自动设置成“1”了。
现在，客户需要一个类似的表来存储进货数据，而且进货方式还有3个可能的取值范围，需要设置默认值，那么，应该怎么创建这个表呢？另外，创建好表以后，又该怎么进行修改呢？
如何创建数据表？首先，我们要知道MySQL创建表的语法结构：
CREATE TABLE &amp;lt;表名&amp;gt; ( 字段名1 数据类型 [字段级别约束] [默认值]， 字段名2 数据类型 [字段级别约束] [默认值]， ...... [表级别约束] ); 在这里，我们通过定义表名、表中的字段、表的属性等，把一张表创建出来。
你可能注意到了，在MySQL创建表的语法结构里面，有一个词叫做“约束”。“约束”限定了表中数据应该满足的条件。MySQL会根据这些限定条件，对表的操作进行监控，阻止破坏约束条件的操作执行，并提示错误，从而确保表中数据的唯一性、合法性和完整性。这是创建表时不可缺少的一部分。
下面我来带你创建刚刚提到的进货单表。需要注意的是，这里我们需要定义默认值，也就是要定义默认值约束，除此之外，还有很多种约束，一会儿我再细讲。
我们先来看基本的数据表创建流程，创建代码如下：
CREATE TABLE demo.importhead ( listnumber INT, supplierid INT, stocknumber INT, --我们在字段importype定义为INT类型的后面，按照MySQL创建表的语法，加了默认值1。 importtype INT DEFAULT 1, quantity DECIMAL(10,3), importvalue DECIMAL(10,2), recorder INT, recordingdate DATETIME ); 运行这个SQL语句，表demo.importhead就按照我们的要求被创建出来了。
在创建表的时候，字段名称要避开MySQL的系统关键字，原因是MySQL系统保留的关键字都有特定的含义，如果作为字段名称出现在SQL语句中，MySQL会把这个字段名称理解为系统关键字，从而导致SQL语句无法正常运行。比如，刚刚我们把进货金额设置为“importvalue”，而不是“value”，就是因为，“value”是MySQL的系统关键字。
好了，现在我们尝试往刚刚创建的表里插入一条记录，来验证一下对字段“importtype”定义的默认值约束是否起了作用。
INSERT INTO demo.importhead ( listnumber, supplierid, stocknumber, -- 这里我们没有插入字段importtype的值 quantity, importvalue, recorder, recordingdate ) VALUES ( 3456, 1, 1, 10, 100, 1, '2020-12-10' ); 插入完成后，我们来查询一下表的内容：</description></item><item><title>04_增删改查：如何操作表中的数据？</title><link>https://artisanbox.github.io/8/4/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/4/</guid><description>你好，我是朱晓峰。今天，我们来聊一聊如何操作数据表里的数据。
在咱们的超市项目中，我们给用户设计好了一个数据表 demo.goodsmaster，定义好了里面的字段，以及各种约束，如下所示：
mysql&amp;gt; DESCRIBE demo.goodsmaster; +---------------+--------------+------+-----+---------+--+ | Field | Type | Null | Key | Default |Extra | +---------------+------------+------+-----+---------+------------+ | itemnumber | int | NO | PRI | NULL |auto_increment | | barcode | text | NO | | NULL | | | goodsname | text | NO | | NULL | | | specification | text | YES | | NULL | | | unit | text | YES | | NULL | | | price | decimal(10,2)| NO | | NULL | | +---------------+------------+------+-----+---------+----------------+ 6 rows in set (0.</description></item><item><title>05_主键：如何正确设置主键？</title><link>https://artisanbox.github.io/8/5/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/5/</guid><description>你好，我是朱晓峰，今天我们来聊一聊如何用好MySQL的主键。
前面在讲存储的时候，我提到过主键，它可以唯一标识表中的某一条记录，对数据表来说非常重要。当我们需要查询和引用表中的一条记录的时候，最好的办法就是通过主键。只有合理地设置主键，才能确保我们准确、快速地找到所需要的数据记录。今天我就借助咱们的超市项目的实际需求，来给你讲一讲怎么正确设置主键。
在我们的项目中，客户要进行会员营销，相应的，我们就需要处理会员信息。会员信息表（demo.membermaster）的设计大体如下：
为了能够唯一地标识一个会员的信息，我们需要为会员信息表设置一个主键。那么，怎么为这个表设置主键，才能达到我们理想的目标呢？
今天，我就带你在解决这个实际问题的过程中，学习下三种设置主键的思路：业务字段做主键、自增字段做主键和手动赋值字段做主键。
业务字段做主键针对这个需求，我们最容易想到的，是选择表中已有的字段，也就是跟业务相关的字段做主键。那么，在这个表里，哪个字段比较合适呢？我们来分析一下。
会员卡号（cardno）看起来比较合适，因为会员卡号不能为空，而且有唯一性，可以用来标识一条会员记录。我们来尝试一下用会员卡号做主键。
我们可以用下面的代码，在创建表的时候，设置字段cardno为主键：
mysql&amp;gt; CREATE TABLE demo.membermaster -&amp;gt; ( -&amp;gt; cardno CHAR(8) PRIMARY KEY, -- 会员卡号为主键 -&amp;gt; membername TEXT, -&amp;gt; memberphone TEXT, -&amp;gt; memberpid TEXT, -&amp;gt; memberaddress TEXT, -&amp;gt; sex TEXT, -&amp;gt; birthday DATETIME -&amp;gt; ); Query OK, 0 rows affected (0.06 sec) 我们来查询一下表的结构，确认下主键是否创建成功了：
mysql&amp;gt; DESCRIBE demo.membermaster; +---------------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------------+----------+------+-----+---------+-------+ | cardno | char(8) | NO | PRI | NULL | | | membername | text | YES | | NULL | | | memberphone | text | YES | | NULL | | | memberpid | text | YES | | NULL | | | memberaddress | text | YES | | NULL | | | sex | text | YES | | NULL | | | birthday | datetime | YES | | NULL | | +---------------+----------+------+-----+---------+-------+ 7 rows in set (0.</description></item><item><title>06_外键和连接：如何做关联查询？</title><link>https://artisanbox.github.io/8/6/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/6/</guid><description>你好，我是朱晓峰。今天我来和你聊一聊关联查询的问题。
在实际的数据库应用开发过程中，我们经常需要把2个或2个以上的表进行关联，以获取需要的数据。这是因为，为了提高存取效率，我们会把不同业务模块的信息分别存放在不同的表里面。但是，从业务层面上看，我们需要完整全面的信息为经营决策提供数据支撑。
就拿咱们的超市项目来说，数据库里面的销售流水表一般只保存销售必需的信息（比如商品编号、数量、价格、金额和会员卡号等）。但是，在呈现给超市经营者的统计报表里面，只包括这些信息是不够的，比如商品编号、会员卡号，这些数字经营者就看不懂。因此，必须要从商品信息表提取出商品信息，从会员表中提取出会员的相关信息，这样才能形成一个完整的报表。这种把分散在多个不同的表里的数据查询出来的操作，就是多表查询。
不过，这种查询可不简单，我们需要建立起多个表之间的关联，然后才能去查询，同时还需要规避关联表查询中的常见错误。具体怎么做呢？我来借助实际的项目给你讲一讲。
在我们项目的进货模块，有这样2个数据表，分别是进货单头表（importhead）和进货单明细表（importdetails），我们每天都要对这两个表进行增删改查的操作。
进货单头表记录的是整个进货单的总体信息：
进货单明细表记录了每次进货的商品明细信息。一条进货单头数据记录，对应多条进货商品的明细数据，也就是所谓的一对多的关系。具体信息如下表所示：
现在我们需要查询一次进货的所有相关数据，包括进货单的总体信息和进货商品的明细，这样一来，我们就需要把2个表关联起来，那么，该怎么操作呢？
在MySQL中，为了把2个表关联起来，会用到2个重要的功能：外键（FOREIGN KEY）和连接（JOIN）。外键需要在创建表的阶段就定义；连接可以通过相同意义的字段把2个表连接起来，用在查询阶段。
接下来，我就先和你聊聊外键。
如何创建外键？我先来解释一下什么是外键。
假设我们有2个表，分别是表A和表B，它们通过一个公共字段“id”发生关联关系，我们把这个关联关系叫做R。如果“id”在表A中是主键，那么，表A就是这个关系R中的主表。相应的，表B就是这个关系中的从表，表B中的“id”，就是表B用来引用表A中数据的，叫外键。所以，外键就是从表中用来引用主表中数据的那个公共字段。
为了方便你理解，我画了一张图来展示：
如图所示，在关联关系R中，公众字段（字段A）是表A的主键，所以表A是主表，表B是从表。表B中的公共字段（字段A）是外键。
在MySQL中，外键是通过外键约束来定义的。外键约束就是约束的一种，它必须在从表中定义，包括指明哪个是外键字段，以及外键字段所引用的主表中的主键字段是什么。MySQL系统会根据外键约束的定义，监控对主表中数据的删除操作。如果发现要删除的主表记录，正在被从表中某条记录的外键字段所引用，MySQL就会提示错误，从而确保了关联数据不会缺失。
外键约束可以在创建表的时候定义，也可以通过修改表来定义。我们先来看看外键约束定义的语法结构：
[CONSTRAINT &amp;lt;外键约束名称&amp;gt;] FOREIGN KEY 字段名 REFERENCES &amp;lt;主表名&amp;gt; 字段名 你可以在创建表的时候定义外键约束：
CREATE TABLE 从表名 ( 字段名 类型, ... -- 定义外键约束，指出外键字段和参照的主表字段 CONSTRAINT 外键约束名 FOREIGN KEY (字段名) REFERENCES 主表名 (字段名) ) 当然，你也可以通过修改表来定义外键约束：
ALTER TABLE 从表名 ADD CONSTRAINT 约束名 FOREIGN KEY 字段名 REFERENCES 主表名 （字段名）; 一般情况下，表与表的关联都是提前设计好了的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但没有预先定义外键约束，那么，就要用修改表的方式来补充定义。
下面，我就来讲一讲怎么创建外键约束。
先创建主表demo.importhead：
CREATE TABLE demo.importhead ( listnumber INT PRIMARY KEY, supplierid INT, stocknumber INT, importtype INT, importquantity DECIMAL(10 , 3 ), importvalue DECIMAL(10 , 2 ), recorder INT, recordingdate DATETIME ); 然后创建从表demo.</description></item><item><title>07_条件语句：WHERE与HAVING有什么不同</title><link>https://artisanbox.github.io/8/7/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/7/</guid><description>你好，我是朱晓峰。
我们在进行查询的时候，经常需要按条件对查询结果进行筛选，这就要用到条件语句WHERE和HAVING了。
WHERE是直接对表中的字段进行限定，来筛选结果；HAVING则需要跟分组关键字GROUP BY一起使用，通过对分组字段或分组计算函数进行限定，来筛选结果。虽然它们都是对查询进行限定，却有着各自的特点和适用场景。很多时候，我们会遇到2个都可以用的情况。一旦用错，就很容易出现执行效率低下、查询结果错误，甚至是查询无法运行的情况。
下面我就借助项目实施过程中的实际需求，给你讲讲WHERE和HAVING分别是如何对查询结果进行筛选的，以及它们各自的优缺点，来帮助你正确地使用它们，使你的查询不仅能够得到正确的结果，还能占用更少的资源，并且速度更快。
一个实际查询需求超市的经营者提出，要查单笔销售金额超过50元的商品。我们来分析一下这个需求：需要查询出一个商品记录集，限定条件是单笔销售金额超过50元。这个时候，我们就需要用到WHERE和HAVING了。
这个问题的条件很明确，查询的结果也只有“商品”一个字段，好像很容易实现。
假设我们有一个这样的商品信息表（demo.goodsmaster），里面有2种商品：书和笔。
mysql&amp;gt; SELECT * -&amp;gt; FROM demo.goodsmaster; +------------+---------+-----------+---------------+------+------------+ | itemnumber | barcode | goodsname | specification | unit | salesprice | +------------+---------+-----------+---------------+------+------------+ | 1 | 0001 | 书 | | 本 | 89.00 | | 2 | 0002 | 笔 | | 支 | 5.00 | +------------+---------+-----------+---------------+------+------------+ 2 rows in set (0.00 sec) 同时，我们还有一个商品销售明细表（demo.transactiondetails），里面有4条销售记录：
mysql&amp;gt; SELECT * -&amp;gt; FROM demo.transactiondetails; +---------------+------------+----------+-------+------------+ | transactionid | itemnumber | quantity | price | salesvalue | +---------------+------------+----------+-------+------------+ | 1 | 1 | 1.</description></item><item><title>08_聚合函数：怎么高效地进行分组统计？</title><link>https://artisanbox.github.io/8/8/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/8/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊聚合函数。
MySQL中有5种聚合函数较为常用，分别是求和函数SUM()、求平均函数AVG()、最大值函数MAX()、最小值函数MIN()和计数函数COUNT()。接下来，我就结合超市项目的真实需求，来带你掌握聚合函数的用法，帮你实现高效的分组统计。
咱们的项目需求是这样的：超市经营者提出，他们需要统计某个门店，每天、每个单品的销售情况，包括销售数量和销售金额等。这里涉及3个数据表，具体信息如下所示：
销售明细表（demo.transactiondetails)：
销售单头表（demo.transactionhead)：
商品信息表（demo.goodsmaster）：
要统计销售，就要用到数据求和，那么我们就先来学习下求和函数SUM()。
SUM（）SUM（）函数可以返回指定字段值的和。我们可以用它来获得用户某个门店，每天，每种商品的销售总计数据：
mysql&amp;gt; SELECT -&amp;gt; LEFT(b.transdate, 10), -- 从关联表获取交易时间，并且通过LEFT函数，获取交易时间字符串的左边10个字符，得到年月日的数据 -&amp;gt; c.goodsname, -- 从关联表获取商品名称 -&amp;gt; SUM(a.quantity), -- 数量求和 -&amp;gt; SUM(a.salesvalue) -- 金额求和 -&amp;gt; FROM -&amp;gt; demo.transactiondetails a -&amp;gt; JOIN -&amp;gt; demo.transactionhead b ON (a.transactionid = b.transactionid) -&amp;gt; JOIN -&amp;gt; demo.goodsmaster c ON (a.itemnumber = c.itemnumber) -&amp;gt; GROUP BY LEFT(b.transdate, 10) , c.goodsname -- 分组 -&amp;gt; ORDER BY LEFT(b.transdate, 10) , c.goodsname; -- 排序 +-----------------------+-----------+-----------------+-------------------+ | LEFT(b.</description></item><item><title>09_时间函数：时间类数据，MySQL是怎么处理的？</title><link>https://artisanbox.github.io/8/9/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/9/</guid><description>你好，我是朱晓峰。今天，咱们来聊一聊MySQL的时间函数。
顾名思义，时间函数就是用来处理时间的函数。时间，几乎可以说是各类项目中都会存在的数据，项目需求不同，我们需要的时间函数也不一样，比如：
如果我们要统计一天之中不同时间段的销售情况，就要获取时间值中的小时值，这就会用到函数HOUR()； 要计算与去年同期相比的增长率，这就要计算去年同期的日期时间，会用到函数DATE_ADD()； 要计算今天是周几、有没有优惠活动，这就要用到函数DAYOFWEEK()了； …… 这么多不同类型的时间函数，该怎么选择呢？这节课，我就结合不同的项目需求，来讲一讲不同的时间函数的使用方法，帮助你轻松地处理各类时间数据。
获取日期时间数据中部分信息的函数我先举个小例子。超市的经营者提出，他们希望通过实际的销售数据，了解到一天当中什么时间段卖得好，什么时间段卖得不好，这样他们就可以根据不同时间的销售情况，合理安排商品陈列和人员促销，以实现收益最大化。
要达到这个目标，我们就需要统计一天中每小时的销售数量和销售金额。
这里涉及3组数据，分别是销售单头表（demo.transactionhead)、销售单明细表 (demo.transactiondetails)和商品信息表（demo.goodsmaster）（为了便于你理解，表的结构和表里的记录都是经过简化的）。
销售单头表包含了销售单的整体信息，包括流水单号、交易时间、收款机编号、会员编号和收银员编号等。
销售单明细表中保存的是交易明细数据，包括商品编号、销售数量、价格、销售金额等。
商品信息表主要包括商品编号、条码、商品名称、规格、单位和售价。
需要注意的是，销售单明细表通过流水编号与销售单头表关联，其中流水编号是外键。通过流水编号，销售单明细表引用销售单头表里的交易时间、会员编号等信息，同时，通过商品编号与商品信息表关联，引用商品信息表里的商品名称等信息。
首先，我们来分析一下“统计一天中每小时的销售数量和销售金额”的这个需求。
要统计一天中每小时的销售情况，实际上就是要把销售数据按照小时进行分组统计。那么，解决问题的关键，就是把交易时间的小时部分提取出来。这就要用到MySQL的日期时间处理函数EXTRACT（）和HOUR（）了。
为了获取小时的值，我们要用到EXTRACT()函数。EXTRACT（type FROM date）表示从日期时间数据“date”中抽取“type”指定的部分。
有了这个函数，我们就可以获取到交易时间的小时部分，从而完成一天中每小时的销售数量和销售金额的查询：
mysql&amp;gt; SELECT -&amp;gt; EXTRACT(HOUR FROM b.transdate) AS 时段, -&amp;gt; SUM(a.quantity) AS 数量, -&amp;gt; SUM(a.salesvalue) AS 金额 -&amp;gt; FROM -&amp;gt; demo.transactiondetails a -&amp;gt; JOIN -&amp;gt; demo.transactionhead b ON (a.transactionid = b.transactionid) -&amp;gt; GROUP BY EXTRACT(HOUR FROM b.transdate) -&amp;gt; ORDER BY EXTRACT(HOUR FROM b.transdate); +------+--------+--------+ | 时段 | 数量 | 金额 | +------+--------+--------+ | 9 | 16.</description></item><item><title>10_如何进行数学计算、字符串处理和条件判断？</title><link>https://artisanbox.github.io/8/10/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/10/</guid><description>你好，我是朱晓峰。
MySQL提供了很多功能强大，而且使用起来非常方便的函数，包括数学函数、字符串处理函数和条件判断函数等。
在很多场景中 ，我们都会用到这些函数，比如说，在超市项目的实际开发过程中，会有这样的需求：
会员积分的规则是一元积一分，不满一元不积分，这就要用到向下取整的数学函数FLOOR()； 在打印小票的时候，收银纸的宽度是固定的，怎么才能让打印的结果清晰而整齐呢？这个时候，就要用到CONCAT()等字符串处理函数； 不同数据的处理方式不同，怎么选择正确的处理方式呢？这就会用到IF(表达式，V1，V2)这样的条件判断函数； …… 这些函数对我们管理数据库、提高数据处理的效率有很大的帮助。接下来，我就带你在解决实际问题的过程中，帮你掌握使用这些函数的方法。
数学函数我们先来学习下数学函数，它主要用来处理数值数据，常用的主要有3类，分别是取整函数ROUND()、CEIL()、FLOOR()，绝对值函数ABS()和求余函数MOD()。
知道了这些函数，我们来看看超市经营者的具体需求。他们提出，为了提升销量，要进行会员营销，主要是给会员积分，并以积分数量为基础，给会员一定的优惠。
积分的规则也很简单，就是消费一元积一分，不满一元不积分，那我们就需要对销售金额的数值进行取整。
这里主要用到四个表，分别是销售单明细表、销售单头表、商品信息表和会员信息表。为了方便你理解，我对表结构和数据进行了简化。
销售单明细表：
销售单头表：
商品信息表：
会员信息表：
这个场景下，可以用到MySQL数学函数中的取整函数，主要有3种。
向上取整CEIL(X)和CEILING(X)：返回大于等于X的最小INT型整数。 向下取整FLOOR(X)：返回小于等于X的最大INT型整数。 舍入函数ROUND(X,D)：X表示要处理的数，D表示保留的小数位数，处理的方式是四舍五入。ROUND(X)表示保留0位小数。 现在积分的规则是一元积一分，不满一元不积分，显然是向下取整，那就可以用FLOOR（）函数。
首先，我们要通过关联查询，获得会员消费的相关信息：
mysql&amp;gt; SELECT -&amp;gt; c.membername AS '会员', -- 从会员表获取会员名称 -&amp;gt; b.transactionno AS '单号',-- 从销售单头表获取单号 -&amp;gt; b.transdate AS '交易时间', -- 从销售单头表获取交易时间 -&amp;gt; d.goodsname AS '商品名称', -- 从商品信息表获取商品名称 -&amp;gt; a.salesvalue AS '交易金额' -&amp;gt; FROM -&amp;gt; demo.transactiondetails a -&amp;gt; JOIN -&amp;gt; demo.transactionhead b ON (a.transactionid = b.transactionid) -&amp;gt; JOIN -&amp;gt; demo.</description></item><item><title>11_索引：怎么提高查询的速度？</title><link>https://artisanbox.github.io/8/11/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/11/</guid><description>你好，我是朱晓峰。
在我们的超市信息系统刚刚开始运营的时候，因为数据量很少，每一次的查询都能很快拿到结果。但是，系统运转时间长了以后，数据量不断地累积，变得越来越庞大，很多查询的速度就变得特别慢。这个时候，我们就采用了MySQL 提供的高效访问数据的方法—— 索引，有效地解决了这个问题，甚至之前的一个需要8秒钟才能完成的查询，现在只用0.3秒就搞定了，速度提升了20多倍。
那么，索引到底是啥呢？该怎么使用呢？这节课，我们就来聊一聊。
索引是什么？如果你去过图书馆，应该会知道图书馆的检索系统。图书馆为图书准备了检索目录，包括书名、书号、对应的位置信息，包括在哪个区、哪个书架、哪一层。我们可以通过书名或书号，快速获知书的位置，拿到需要的书。
MySQL中的索引，就相当于图书馆的检索目录，它是帮助MySQL系统快速检索数据的一种存储结构。我们可以在索引中按照查询条件，检索索引字段的值，然后快速定位数据记录的位置，这样就不需要遍历整个数据表了。而且，数据表中的字段越多，表中数据记录越多，速度提升越是明显。
我来举个例子，进一步解释下索引的作用。这里要用到销售流水表（demo.trans），表结构如下：
mysql&amp;gt; describe demo.trans; +---------------+----------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +---------------+----------+------+-----+---------+-------+ | itemnumber | int | YES | MUL | NULL | | | quantity | text | YES | | NULL | | | price | text | YES | | NULL | | | transdate | datetime | YES | MUL | NULL | | | actualvalue | text | YES | | NULL | | | barcode | text | YES | | NULL | | | cashiernumber | int | YES | MUL | NULL | | | branchnumber | int | YES | MUL | NULL | | | transuniqueid | text | YES | | NULL | | +---------------+----------+------+-----+---------+-------+ 9 rows in set (0.</description></item><item><title>12_事务：怎么确保关联操作正确执行？</title><link>https://artisanbox.github.io/8/12/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/12/</guid><description>你好，我是朱晓峰。
我们经常会遇到这样的场景：几个相互关联的数据操作，必须是全部执行，或者全部不执行，不可以出现部分执行的情况。比如说，你从微信账号里提现100元到银行卡上，这个动作就包括了相互关联的2个步骤，首先是微信账号减100元，然后是银行卡账号加100元（这里假设没有手续费）。假如因为某种异常，这2个操作只执行了一个，另外一个没有执行，就会出现你的钱少了100元，或者你的钱多了100元的情况，这肯定是不能接受的。
如何才能确保多个关联操作全部执行呢？这时就要用到事务了。接下来我就重点讲一讲什么是事务，以及如何正确使用事务。
什么是事务？事务是MySQL的一项功能，它可以使一组数据操作（也叫DML操作，是英文Data Manipulation Language的缩写，包括SELECT、INSERT、UPDATE和DELETE），要么全部执行，要么全部不执行，不会因为某种异常情况（比如硬件故障、停电、网络中断等）出现只执行一部分操作的情况。
事务的语法结构如下所示：
START TRANSACTION 或者 BEGIN （开始事务） 一组DML语句 COMMIT（提交事务） ROLLBACK（事务回滚） 我解释一下这几个关键字。
START TRANSACTION和BEGIN：表示开始事务，意思是通知MySQL，后面的DML操作都是当前事务的一部分。 COMMIT：表示提交事务，意思是执行当前事务的全部操作，让数据更改永久有效。 ROLLBACK：表示回滚当前事务的操作，取消对数据的更改。 事务有4个主要特征，分别是原子性（atomicity）、一致性（consistency）、持久性（durability）和隔离性（isolation）。
原子性：表示事务中的操作要么全部执行，要么全部不执行，像一个整体，不能从中间打断。 一致性：表示数据的完整性不会因为事务的执行而受到破坏。 隔离性：表示多个事务同时执行的时候，不互相干扰。不同的隔离级别，相互独立的程度不同。 持久性：表示事务对数据的修改是永久有效的，不会因为系统故障而失效。 持久性非常好理解，我就不多说了，接下来我重点讲一讲事务的原子性、一致性和隔离性，这是确保关联操作正确执行的关键。
如何确保操作的原子性和数据的一致性？我借助一个超市的收银员帮顾客结账的简单场景来讲解。在系统中，结算的动作主要就是销售流水的产生和库存的消减。这里会涉及销售流水表和库存表，如下所示：
销售流水表（demo.mytrans）：
库存表（demo.inventory）：
现在，假设门店销售了5个商品编号是1的商品，这个动作实际上包括了2个相互关联的数据库操作：
向流水表中插入一条“1号商品卖了5个”的销售流水； 把库存表中的1号商品的库存减5。 这里包含了2个DML操作，为了避免意外事件导致的一个操作执行了而另一个没有执行的情况，我把它们放到一个事务里面，利用事务中数据操作的原子性，来确保数据的一致性。
mysql&amp;gt; START TRANSACTION; -- 开始事务 Query OK, 0 rows affected (0.00 sec) mysql&amp;gt; INSERT INTO demo.mytrans VALUES (1,1,5); -- 插入流水 Query OK, 1 row affected (0.00 sec) mysql&amp;gt; UPDATE demo.inventory SET invquantity = invquantity - 5 WHERE itemnumber = 1; -- 更新库存 Query OK, 1 row affected (0.</description></item><item><title>13_临时表：复杂查询，如何保存中间结果？</title><link>https://artisanbox.github.io/8/13/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/13/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊临时表。
当我们遇到一些复杂查询的时候，经常无法一步到位，或者是一步到位会导致查询语句太过复杂，开发和维护的成本过高。这个时候，就可以使用临时表。
下面，我就结合实际的项目来讲解一下，怎么拆解一个复杂的查询，通过临时表来保存中间结果，从而把一个复杂查询变得简单而且容易实现。
临时表是什么？临时表是一种特殊的表，用来存储查询的中间结果，并且会随着当前连接的结束而自动删除。MySQL中有2种临时表，分别是内部临时表和外部临时表：
内部临时表主要用于性能优化，由系统自动产生，我们无法看到； 外部临时表通过SQL语句创建，我们可以使用。 因为我们不能使用内部临时表，所以我就不多讲了。今天，我来重点讲一讲我们可以创建和使用的外部临时表。
首先，你要知道临时表的创建语法结构：
CREATE TEMPORARY TABLE 表名 ( 字段名 字段类型, ... ); 跟普通表相比，临时表有3个不同的特征：
临时表的创建语法需要用到关键字TEMPORARY； 临时表创建完成之后，只有当前连接可见，其他连接是看不到的，具有连接隔离性； 临时表在当前连接结束之后，会被自动删除。 因为临时表有连接隔离性，不同连接创建相同名称的临时表也不会产生冲突，适合并发程序的运行。而且，连接结束之后，临时表会自动删除，也不用担心大量无用的中间数据会残留在数据库中。因此，我们就可以利用这些特点，用临时表来存储SQL查询的中间结果。
如何用临时表简化复杂查询？刚刚提到，临时表可以简化复杂查询，具体是怎么实现的呢？我来介绍一下。
举个例子，超市经营者想要查询2020年12月的一些特定商品销售数量、进货数量、返厂数量，那么，我们就要先把销售、进货、返厂这3个模块分开计算，用临时表来存储中间计算的结果，最后合并在一起，形成超市经营者想要的结果集。
首先，我们统计一下在2020年12月的商品销售数据。
假设我们的销售流水表（mysales）如下所示：
我们可以用下面的SQL语句，查询出每个单品的销售数量和销售金额，并存入临时表：
mysql&amp;gt; CREATE TEMPORARY TABLE demo.mysales -&amp;gt; SELECT -- 用查询的结果直接生成临时表 -&amp;gt; itemnumber, -&amp;gt; SUM(quantity) AS QUANTITY, -&amp;gt; SUM(salesvalue) AS salesvalue -&amp;gt; FROM -&amp;gt; demo.transactiondetails -&amp;gt; GROUP BY itemnumber -&amp;gt; ORDER BY itemnumber; Query OK, 2 rows affected (0.01 sec) Records: 2 Duplicates: 0 Warnings: 0 mysql&amp;gt; SELECT * FROM demo.</description></item><item><title>14_视图：如何简化查询？</title><link>https://artisanbox.github.io/8/14/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/14/</guid><description>你好，我是朱晓峰。今天，我们来聊一聊视图。
视图是一种虚拟表，我们可以把一段查询语句作为视图存储在数据库中，在需要的时候，可以把视图看做一个表，对里面的数据进行查询。
举个小例子，在学校的信息系统里面，为了减少冗余数据，学生档案（包括姓名、年龄等）和考试成绩（包括考试时间、科目、分数等）是分别存放在不同的数据表里面的，但是，我们经常需要查询学生的考试成绩（包括学生姓名、科目、分数）。这个时候，我们就可以把查询学生考试成绩的这个关联查询，用视图的形式保存起来。这样一来，我们不仅可以从视图中直接查询学生考试成绩，让查询变得简单，而且，视图没有实际存储数据，还避免了数据存储过程中可能产生的冗余，提高了存储的效率。
今天，我就结合超市的项目，来具体讲解一下怎么创建和操作视图，来帮助你提高查询效率。
视图的创建及其好处首先，我们来学习下创建视图的方法，以及使用视图的一些好处。
创建视图的语法结构：
CREATE [OR REPLACE] VIEW 视图名称 [(字段列表)] AS 查询语句 现在，假设我们要查询一下商品的每日销售明细，这就要从销售流水表（demo.trans）和商品信息表（demo.goodsmaster）中获取到销售数据和对应的商品信息数据。
销售流水表包含流水单号、商品编号、销售数量、销售金额和交易时间等信息：
商品信息表包含商品编号、条码、名称和售价等信息：
在不使用视图的情况下，我们可以通过对销售流水表和商品信息表进行关联查询，得到每天商品销售统计的结果，包括销售日期、商品名称、每天销售数量的合计和每天销售金额的合计，如下所示：
mysql&amp;gt; SELECT -&amp;gt; a.transdate, -&amp;gt; a.itemnumber, -&amp;gt; b.goodsname, -&amp;gt; SUM(a.quantity) AS quantity, -- 统计销售数量 -&amp;gt; SUM(a.salesvalue) AS salesvalue -- 统计销售金额 -&amp;gt; FROM -&amp;gt; demo.trans AS a -&amp;gt; LEFT JOIN -- 连接查询 -&amp;gt; demo.goodsmaster AS b ON (a.itemnumber = b.itemnumber) -&amp;gt; GROUP BY a.transdate , a.itemnumber; +---------------------+------------+-----------+----------+------------+ | transdate | itemnumber | goodsname | quantity | salesvalue | +---------------------+------------+-----------+----------+------------+ | 2020-12-01 00:00:00 | 1 | 本 | 1.</description></item><item><title>15_存储过程：如何提高程序的性能和安全性？</title><link>https://artisanbox.github.io/8/15/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/15/</guid><description>你好，我是朱晓峰。今天呢，我们来聊一聊MySQL的存储过程。
在我们的超市项目中，每天营业结束后，超市经营者都要计算当日的销量，核算成本和毛利等营业数据，这也就意味着每天都要做重复的数据统计工作。其实，这种数据量大，而且计算过程复杂的场景，就非常适合使用存储过程。
简单来说呢，存储过程就是把一系列SQL语句预先存储在MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列SQL语句全部执行。
这样一来，不仅执行效率非常高，而且客户端不需要把所有的SQL语句通过网络发给服务器，减少了SQL语句暴露在网上的风险，也提高了数据查询的安全性。
今天，我就借助真实的超市项目，给你介绍一下如何创建和使用存储过程，帮助你提升查询的效率，并且让你开发的应用更加简洁安全。
如何创建存储过程？在创建存储过程的时候，我们需要用到关键字CREATE PROCEDURE。具体的语法结构如下：
CREATE PROCEDURE 存储过程名 （[ IN | OUT | INOUT] 参数名称 类型）程序体 接下来，我以超市的日结计算为例，给你讲一讲怎么创建存储过程。当然，为了方便你理解，我对计算的过程进行了简化。
假设在日结计算中，我们需要统计每天的单品销售，包括销售数量、销售金额、成本、毛利、毛利率等。同时，我们还要把计算出来的结果存入单品统计表中。
这个计算需要用到几个数据表，我分别来展示下这些表的基本信息。
销售单明细表（demo.transactiondetails）中包括了每笔销售中的商品编号、销售数量、销售价格和销售金额。
mysql&amp;gt; SELECT * -&amp;gt; FROM demo.transactiondetails; +---------------+------------+----------+------------+------------+ | transactionid | itemnumber | quantity | salesprice | salesvalue | +---------------+------------+----------+------------+------------+ | 1 | 1 | 1.000 | 89.00 | 89.00 | | 1 | 2 | 2.000 | 5.00 | 10.00 | | 2 | 1 | 2.000 | 89.</description></item><item><title>16_游标：对于数据集中的记录，该怎么逐条处理？</title><link>https://artisanbox.github.io/8/16/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/16/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊游标。
咱们前面学习的MySQL数据操作语句，都是针对结果集合的。也就是说，每次处理的对象都是一个数据集合。如果需要逐一处理结果集中的记录，就会非常困难。
虽然我们也可以通过筛选条件WHERE和HAVING，或者是限定返回记录的关键字LIMIT返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是随意定位到某一条记录，并对记录的数据进行处理。
这个时候，就可以用到游标。所谓的游标，也就是能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。
这么说可能有点抽象，我举一个生活中的例子，你一看就明白了。比如，你想去某个城市旅游，现在需要订酒店。你打开预订酒店的App，设置好价格区间后进行搜索，得到了一个酒店列表。接下来，你可能要逐条查看列表中每个酒店的客户评价，最后选择一个口碑不错的酒店。这个逐条搜索并对选中的数据进行操作的过程，就相当于游标对数据记录进行操作的过程。
今天我就来给你讲一讲游标的使用方法，同时还会通过一个案例串讲，帮助你更好地使用游标，让你能够轻松地处理数据集中的记录。
游标的使用步骤游标只能在存储程序内使用，存储程序包括存储过程和存储函数。关于存储过程，我们上节课刚刚学过，这里我简单介绍一下存储函数。创建存储函数的语法是：
CREATE FUNCTION 函数名称 （参数）RETURNS 数据类型 程序体 存储函数与存储过程很像，但有几个不同点：
存储函数必须返回一个值或者数据表，存储过程可以不返回。 存储过程可以通过CALL语句调用，存储函数不可以。 存储函数可以放在查询语句中使用，存储过程不行。 存储过程的功能更加强大，包括能够执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的。 这节课，我们主要学习下游标在存储过程中的使用方法，因为游标在存储过程中更常用。游标在存储函数中的使用方法和在存储过程中的使用方法是一样的。
在使用游标的时候，主要有4个步骤。
第一步，定义游标。语法结构如下：
DECLARE 游标名 CURSOR FOR 查询语句 这里就是声明一个游标，它可以操作的数据集是“查询语句”返回的结果集。
第二步，打开游标。语法结构如下：
OPEN 游标名称； 打开游标之后，系统会为游标准备好查询的结果集，为后面游标的逐条读取结果集中的记录做准备。
第三步，从游标的数据结果集中读取数据。语法结构是这样的：
FETCH 游标名 INTO 变量列表； 这里的意思是通过游标，把当前游标指向的结果集中那一条记录的数据，赋值给列表中的变量。
需要注意的是，游标的查询结果集中的字段数，必须跟INTO后面的变量数一致，否则，在存储过程执行的时候，MySQL会提示错误。
第四步，关闭游标。语法结构如下：
CLOSE 游标名； 用完游标之后，你一定要记住及时关闭游标。因为游标会占用系统资源，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。而关闭游标的操作，会释放游标占用的系统资源。
知道了基本步骤，下面我就结合超市项目的实际案例，带你实战一下。
案例串讲在超市项目的进货模块中，有一项功能是对进货单数据进行验收。其实就是在对进货单的数据确认无误后，对进货单的数据进行处理，包括增加进货商品的库存，并修改商品的平均进价。下面我用实际数据来演示一下这个操作流程。
这里我们要用到进货单头表（demo.importheadl）、进货单明细表（demo.importdetails）、库存表（demo.inventory）和商品信息表（demo.goodsmaster）。
进货单头表：
进货单明细表：
库存表：
商品信息表：
要验收进货单，我们就需要对每一个进货商品进行两个操作：
在现有库存数量的基础上，加上本次进货的数量； 根据本次进货的价格、数量，现有商品的平均进价和库存，计算新的平均进价：（本次进货价格 * 本次进货数量+现有商品平均进价 * 现有商品库存）/（本次进货数量+现有库存数量）。 针对这个操作，如果只用我们在第4讲里学习的SQL语句，完成起来就比较困难。
因为我们需要通过应用程序来控制操作流程，做成一个循环操作，每次只查询一种商品的数据记录并进行处理，一直到把进货单中的数据全部处理完。这样一来，应用必须发送很多的SQL指令到服务器，跟服务器的交互多，不仅代码复杂，而且也不够安全。
这个时候，如果使用游标，就很容易了。因为所有的操作都可以在服务器端完成，应用程序只需要发送一个命令调用存储过程就可以了。现在，我们就来看看如何用游标来解决这个问题。
我用代码创建了一个存储过程demo.mytest（）。当然，你也完全可以在Workbench中创建存储过程，非常简单，我就不多说了。创建存储过程的代码如下：
mysql&amp;gt; DELIMITER // mysql&amp;gt; CREATE PROCEDURE demo.mytest(mylistnumber INT) -&amp;gt; BEGIN -&amp;gt; DECLARE mystockid INT; -&amp;gt; DECLARE myitemnumber INT; -&amp;gt; DECLARE myquantity DECIMAL(10,3); -&amp;gt; DECLARE myprice DECIMAL(10,2); -&amp;gt; DECLARE done INT DEFAULT FALSE; -- 用来控制循环结束 -&amp;gt; DECLARE cursor_importdata CURSOR FOR -- 定义游标 -&amp;gt; SELECT b.</description></item><item><title>17_触发器：如何让数据修改自动触发关联操作，确保数据一致性？</title><link>https://artisanbox.github.io/8/17/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/17/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊触发器。
在实际开发中，我们经常会遇到这样的情况：有2个或者多个相互关联的表，如商品信息和库存信息分别存放在2个不同的数据表中，我们在添加一条新商品记录的时候，为了保证数据的完整性，必须同时在库存表中添加一条库存记录。
这样一来，我们就必须把这两个关联的操作步骤写到程序里面，而且要用事务包裹起来，确保这两个操作成为一个原子操作，要么全部执行，要么全部不执行。要是遇到特殊情况，可能还需要对数据进行手动维护，这样就很容易忘记其中的一步，导致数据缺失。
这个时候，其实咱们可以使用触发器。你可以创建一个触发器，让商品信息数据的插入操作自动触发库存数据的插入操作。这样一来，就不用担心因为忘记添加库存数据而导致的数据缺失了。
听上去好像很不错，那触发器到底怎么使用呢？接下来，我就重点给你聊聊。我会先给你讲解创建、查看和删除触发器的具体操作，然后借助一个案例带你实战一下。
如何操作触发器？首先，咱们来学习下触发器的基本操作。
创建触发器创建触发器的语法结构是：
CREATE TRIGGER 触发器名称 {BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON 表名 FOR EACH ROW 表达式； 在创建时，你一定要注意触发器的三个要素。
表名：表示触发器监控的对象。 INSERT|UPDATE|DELETE：表示触发的事件。INSERT表示插入记录时触发；UPDATE表示更新记录时触发；DELETE表示删除记录时触发。 BEFORE|AFTER：表示触发的时间。BEFORE表示在事件之前触发；AFTER表示在事件之后触发。 只有把这三个要素定义好，才能正确使用触发器。
创建好触发器之后，咱们还要知道触发器是不是创建成功了。怎么查看呢？我来介绍下。
查看触发器查看触发器的语句是：
SHOW TRIGGERS\G; 删除触发器删除触发器很简单，你只要知道语法结构就可以了：
DROP TRIGGER 触发器名称; 知道了触发器的操作方法，接下来咱们就借助超市项目的实际案例，在真实的场景中实战一下，毕竟，实战是掌握操作的最好方法。
案例讲解超市项目实际实施过程中，客户经常要查询储值余额变动的明细，但是，查询会员消费流水时，存在数据汇总不及时、查询速度比较慢的问题。这时，我们就想到用触发器，及时把会员储值金额的变化信息记录到一个专门的表中。
我先用咱们熟悉的SQL语句来实现记录储值金额变动的操作，后面再带你使用触发器来操作。通过两种操作的对比，你就能更好地理解，在什么情况下，触发器能够比普通的SQL语句更加简洁高效，从而帮助你用好触发器这个工具，提高开发的能力。
下面我就借助具体数据，来详细说明一下。这里我们需要用到会员信息表（demo.membermaster）和会员储值历史表（demo.deposithist）。
会员信息表：
会员储值历史表：
假如在2020年12月20日这一天，会员编号是2的会员李四，到超市的某家连锁店购买了一条烟，消费了150元。现在，我们用之前学过的SQL语句，把这个会员储值余额的变动情况记录到会员储值历史表中。
第一步，查询出编号是2的会员卡的储值金额是多少。我们可以用下面的代码来实现：
mysql&amp;gt; SELECT memberdeposit -&amp;gt; FROM demo.membermaster -&amp;gt; WHERE memberid = 2; +---------------+ | memberdeposit | +---------------+ | 200.00 | +---------------+ 1 row in set (0.00 sec) 第二步，我们把会员编号是2的会员的储值金额减去150。
mysql&amp;gt; UPDATE demo.</description></item><item><title>18_权限管理：如何控制数据库访问，消除安全隐患？</title><link>https://artisanbox.github.io/8/18/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/18/</guid><description>你好，我是朱晓峰，今天，我来和你聊一聊权限管理。
我们在开发应用的时候，经常会遇到一种需求，就是要根据用户的不同，对数据进行横向和纵向的分组。
所谓横向的分组，就是指用户可以接触到的数据的范围，比如可以看到哪些表的数据；所谓纵向的分组，就是指用户对接触到的数据能访问到什么程度，比如能看、能改，甚至是删除。
我们把具有相同数据访问范围和程度的用户归成不同的类别，这种类别就叫角色。通过角色，管理用户对数据库访问的范围和程度就更加方便了。这也就是对用户的数据访问权限的管理。
恰当的权限设定，可以确保数据的安全性，这是至关重要的。
那么，怎么进行权限管理呢？这节课，我就结合超市项目的实际案例，给你讲一下权限管理的具体操作，包括怎么操作角色和用户，怎么通过角色给用户授权，怎么直接给用户授权，从而帮助你管理好用户的权限，提升数据库的安全性。
下面我就来先讲讲角色。我们可以通过角色对相同权限的用户进行分组管理，这样可以使权限管理更加简单高效。
角色的作用角色是在MySQL 8.0中引入的新功能，相当于一个权限的集合。引入角色的目的是方便管理拥有相同权限的用户。
下面我举个超市项目中的例子，来具体说明一下如何通过角色管理用户权限。
超市项目中有库管、营运和财务等不同的模块，它们各自对应不同的数据表。比如库存模块中的盘点表（demo.invcount）、营运模块中的商品信息表（demo.goodsmaster），还有财务模块中的应付账款表（demo.settlement）。下面是这些表的具体信息。
盘点表：
商品信息表：
应付账款表：
在超市项目中，员工的职责不同，包括库管、营运和财务等，不同的职责有不同的数据访问权限。比如：
张三是库管，他就可以查询商品信息表，对盘点表有增删改查的权限，但无权访问应付账款表； 李四是营运，他就拥有对商品信息表有增删改查的权限，而对库存表和应付账款表，只有查看的权限； 王五是财务，他就有对应付账款表有增删改查的权限，对商品信息表和库存表，只有查看的权限。 所以，我们需要为每一个职责创建一个对应的角色，为每个员工创建一个对应的数据库用户。然后通过给角色赋予相关的权限，再把角色赋予用户，实现对超市员工访问数据权限的管理，从而保证数据的安全性。
这样说有点抽象，下面我们具体操作一下角色和用户。
如何操作角色？首先，我们要创建一个角色，为后面的授权做好准备。
如何创建角色？MySQL中的角色名称由角色名称加主机名称组成。创建角色的语法结构如下：
CREATE ROLE 角色名; 假设我们现在需要创建一个经理的角色，就可以用下面的代码：
mysql&amp;gt; CREATE ROLE 'manager'@'localhost'; Query OK, 0 rows affected (0.06 sec) 这里的意思是，创建一个角色，角色名称是“manager”，角色可以登录的主机是“localhost”，意思是只能从数据库服务器运行的这台计算机登录这个账号。你也可以不写主机名，直接创建角色“manager”：
mysql&amp;gt; CREATE ROLE 'manager'; Query OK, 0 rows affected (0.01 sec) 如果不写主机名，MySQL默认是通配符“%”，意思是这个账号可以从任何一台主机上登录数据库。
同样道理，如果我们要创建库管的角色，就可以用下面的代码：
mysql&amp;gt; CREATE ROLE 'stocker'; Query OK, 0 rows affected (0.02 sec) 创建角色之后，默认这个角色是没有任何权限的，我们需要给角色授权。
怎么给角色赋予权限？给角色授权的语法结构是：
GRANT 权限 ON 表名 TO 角色名; 假设我们现在想给经理角色授予商品信息表、盘点表和应付账款表的只读权限，就可以用下面的代码来实现：</description></item><item><title>19_日志（上）：系统出现问题，如何及时发现？</title><link>https://artisanbox.github.io/8/19/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/19/</guid><description>你好，我是朱晓峰。
我们曾经开发过一个数据库应用系统，但是却突然遭遇了数据库宕机。在这种情况下，定位宕机的原因就非常关键，毕竟，知道了问题，才能确定解决方案。
这时，我们就想到了查看数据库的错误日志，因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。从日志中，我们发现，原来某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。知道了原因，处理起来也就比较轻松了，系统很快就恢复了运行。
除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用，对提升你的数据库应用的开发能力至关重要。
今天，我就结合超市项目的实际案例，给你讲解一下怎么通过查看系统日志，来了解数据库中实际发生了什么，从而快速定位原因。
MySQL的日志种类非常多，包括通用查询日志、慢查询日志、错误日志、二进制日志、中继日志、重做日志和回滚日志，内容比较多，而且都很重要，所以我们来花两节课的时间学习一下。
这节课，我会先具体讲一讲通用查询日志、慢查询日志和错误日志。
通用查询日志通用查询日志记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。当我们的数据发生异常时，开启通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。
举个小例子，在超市项目实施的过程中，我们曾遇到过这样一件事：超市经营者月底查账的时候发现，超市的1号门店在12月1日销售了5件化妆品，但是当天对应的历史库存并没有减少。化妆品的金额都比较大，库存不对的话，会在报表查询中产生巨额差异，触发到报警机制，对超市经营者的决策产生影响。超市经营者找到我们，对系统的可靠性提出质疑。
我们对系统进行了仔细检查，没有发现数据问题。可是商品确实卖出去了，当天的历史库存也确实没有消减。这个时候，我们想到了检查通用查询日志，看看当天到底发生了什么。
查看之后，我们就复原了当天的情况：12月1日下午，门店的收银台销售了5件化妆品，但是由于网络故障，流水没有及时上传到总部。12月1日晚上11:59，总部的历史库存被保存下来，但是因为没有收到门店的流水，所以没有消减库存。12月2日上午，门店的网络恢复了，流水得以上传总部，这个时候，对应化妆品的库存才被消减掉。
这样，我们就确定了故障的原因，也就是超市的网络问题，而系统本身是没有问题的。
你看，通用查询日志可以帮助我们了解操作发生的具体时间和操作的细节，对找出异常发生的原因极其关键。
下面我来具体介绍一下控制通用查询日志的系统变量。通过这些变量，你会清楚怎么控制通用查询日志的开启和关闭，以及保存日志的文件是哪个。
mysql&amp;gt; SHOW VARIABLES LIKE '%general%'; +------------------+---------------+ | Variable_name | Value | +------------------+---------------+ | general_log | OFF | -- 通用查询日志处于关闭状态 | general_log_file | GJTECH-PC.log | -- 通用查询日志文件的名称是GJTECH-PC.log +------------------+---------------+ 2 rows in set, 1 warning (0.00 sec) 在这个查询的结果中，有2点需要我们注意一下。
系统变量general_log的值是OFF，表示通用查询日志处于关闭状态。在MySQL中，这个参数的默认值是关闭的。因为一旦开启记录通用查询日志，MySQL会记录所有的连接起止和相关的SQL操作，这样会消耗系统资源并且占用磁盘空间。我们可以通过手动修改变量的值，在需要的时候开启日志。 通用查询日志文件的名称是GJTECH-PC.log。这样我们就知道在哪里可以查看通用查询日志的内容了。 下面我们来看看如何开启通用查询日志，把所有连接的起止和连接的SQL操作都记录下来。这个操作可以帮助我们追踪SQL操作故障的原因。
开启通用查询日志我们可以通过设置系统变量的值，来开启通用查询日志，并且指定通用查询日志的文件夹和文件名为“H:\mytest.log”。这个操作如下：
mysql&amp;gt; SET GLOBAL general_log = 'ON'; Query OK, 0 rows affected (0.00 sec) mysql&amp;gt; SET @@global.</description></item><item><title>20_日志（下）：系统故障，如何恢复数据？</title><link>https://artisanbox.github.io/8/20/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/20/</guid><description>你好，我是朱晓峰。
上节课，咱们学习了通用查询日志、慢查询日志和错误日志，它们可以帮助我们快速定位系统问题。但实际上，日志也可以帮助我们找回由于误操作而丢失的数据，比如二进制日志（binary log）、中继日志（relay log）、回滚日志（undo log）和重做日志（redo log）。
这节课，我们就来学习下这4种日志。
二进制日志二进制日志主要记录数据库的更新事件，比如创建数据表、更新表中的数据、数据更新所花费的时长等信息。通过这些信息，我们可以再现数据更新操作的全过程。而且，由于日志的延续性和时效性，我们还可以利用日志，完成无损失的数据恢复和主从服务器之间的数据同步。
可以说，二进制日志是进行数据恢复和数据复制的利器。所以，接下来我就结合一个实际案例，重点给你讲一讲怎么操作它。
如何操作二进制日志？操作二进制日志，主要包括查看、刷新二进制日志，用二进制日志恢复数据，以及删除二进制日志。
1.查看二进制日志
查看二进制日志主要有3种情况，分别是查看当前正在写入的二进制日志、查看所有的二进制日志和查看二进制日志中的所有数据更新事件。
查看当前正在写入的二进制日志的SQL语句是：
SHOW MASTER STATUS; 我们可以通过这条语句，查看当前正在写入的二进制日志的名称和当前写入的位置：
mysql&amp;gt; SHOW MASTER STATUS; +----------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +----------------------+----------+--------------+------------------+-------------------+ | GJTECH-PC-bin.000011 | 2207 | | | | +----------------------+----------+--------------+------------------+-------------------+ -- 当前正在写入的二进制日志是“GJTECH-PC-bin.000011”，当前的位置是2207。 1 row in set (0.00 sec) 查看所有的二进制日志的SQL语句是：
SHOW BINARY LOGS; 查看二进制日志中所有数据更新事件的SQL语句是：
SHOW BINLOG EVENTS IN 二进制文件名; 2.刷新二进制日志
刷新二进制日志的SQL语句是：
FLUSH BINARY LOGS; 这条语句的意思是，关闭服务器正在写入的二进制日志文件，并重新打开一个新文件，文件名的后缀在现有的基础上加1。
3.用二进制日志恢复数据
我们可以用mysqlbinlog工具进行数据恢复：</description></item><item><title>21_数据备份：异常情况下，如何确保数据安全？</title><link>https://artisanbox.github.io/8/21/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/21/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊数据备份。
数据备份，对咱们技术人员来说十分重要。当成千上万的用户，每天使用我们开发的应用做着他们的日常工作的时候，数据的安全性就不光是你一个人的事了。要是有一天，突然发生了某种意想不到的情况，导致数据库服务器上的数据全部丢失，所有使用这个应用的人都会受到严重影响。
所以，我们必须“未雨绸缪”，及时把数据备份到安全的地方。这样，当突发的异常来临时，我们就能把数据及时恢复回来，就不会造成太大损失。
MySQL的数据备份有2种，一种是物理备份，通过把数据文件复制出来，达到备份的目的；另外一种是逻辑备份，通过把描述数据库结构和内容的信息保存起来，达到备份的目的。逻辑备份这种方式是免费的，广泛得到使用；而物理备份的方式需要收费，用得比较少。所以，这节课我重点和你聊聊逻辑备份。
我还会给你介绍一下MySQL中的数据备份工具mysqldump、数据恢复的命令行客户端工具mysql，以及数据表中数据导出到文件和从文件导入的SQL语句，帮助你提高你所开发的应用中的数据安全性。
如何进行数据备份？首先，我们来学习下用于数据备份的工具mysqldump。它总共有三种模式：
备份数据库中的表； 备份整个数据库； 备份整个数据库服务器。 接下来，我就来介绍下这3种备份的具体方法。
如何备份数据库中的表？mysqldump备份数据库中的表的语法结构是：
mysqldump -h 服务器 -u 用户 -p 密码 数据库名称 [表名称 … ] &amp;gt; 备份文件名称 我简单解释一下这里的核心内容。
“-h”后面跟的服务器名称，如果省略，默认是本机“localhost”。 “-u”后面跟的是用户名。 “-p”后面跟的是密码，如果省略，执行的时候系统会提示录入密码。 我举个小例子，带你看看怎么使用这个工具。
假设数据库demo中有2个表，分别是商品信息表（demo.goodsmaster）和会员表（demo.membermaster）。
商品信息表：
会员表：
现在，我需要把数据库demo备份到文件中，就可以用下面的代码实现：
H:\&amp;gt;mysqldump -u root -p demo goodsmaster membermaster &amp;gt; test.sql Enter password: ***** 这个指令的意思，就是备份本机数据库服务器上demo数据库中的商品信息表和会员信息表的所有信息。
备份文件是以文本格式保存的，我们可以用记事本打开，看一下备份的内容：
-- MySQL dump 10.13 Distrib 8.0.23, for Win64 (x86_64) -- -- Host: localhost Database: demo -- 表示从本地进行备份，数据库是demo -- ------------------------------------------------------ -- Server version 8.</description></item><item><title>22_范式：如何消除冗余，实现高效存取？</title><link>https://artisanbox.github.io/8/22/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/22/</guid><description>你好，我是朱晓峰。今天，我们来聊一聊数据表设计的范式。
在超市项目的设计阶段，超市经营者把他们正在用的Excel表格给到我们，要求我们把这些数据存储到超市管理系统的数据库中。为了方便你理解，我挑选了1个有代表性的表来举例说明。
进货单表（import）：
这个表中的字段很多，包含了各种信息，表里的数据量也很惊人。我们刚拿到这个表的时候，光是打开表这个操作，就需要等十几秒。
仔细一看，发现表里重复的数据非常多：比如第一行和第二行的数据，同样是3478号单据，供货商编号、供货商名称和仓库，这3个字段的信息完全相同。可是这2条数据的后半部分又不相同，因此，并不能认为它们是冗余数据而删除。
其实，造成这种问题的原因是这张表的设计非常不合理，大量重复导致表变得庞大，效率极低。
在我们的工作场景中，这种由于数据表结构设计不合理，而导致的数据重复的现象并不少见，往往是系统虽然能够运行，承载能力却很差，稍微有点流量，就会出现内存不足、CUP使用率飙升的情况，甚至会导致整个项目失败。
所以，高效可靠的设计是提升数据库工作效率的关键。那该怎么设计呢？有没有什么可以参考的设计规范呢？自然是有了。
接下来，我就带你重新设计一下刚刚的进货单表，在这个过程中给你具体介绍一下数据表设计的三大范式，分别是第一范式（1NF）、第二范式（2NF）和第三范式（3NF），这些范式可以帮助我们设计出简洁高效的数据表，进而提高系统的效率。
我先来介绍一下最基本的第一范式。
第一范式我们对这张进货单表重新设计的第一步，就是要把所有的列，也就是字段，都确认一遍，确保每个字段只包含一种数据。如果各种数据都混合在一起，就无法通过后面的拆解，把重复的数据去掉。
其实，这就是第一范式所要求的：所有的字段都是基本数据字段，不可进一步拆分。
在我们的这张表里，“property”这一字段可以继续拆分。其他字段已经都是基本数据字段，不能再拆了。
经过优化，我们把“property”这一字段，拆分成“specification（规格）”和“unit（单位）”，这2个字段如下：
这样处理之后，字段多了一个，但是每一个字段都成了不可拆分的最小信息单元，我们就可以在这个表的基础之上，着手进行进一步的优化了。这就要用到数据表设计的第二范式了。
第二范式通过观察，我们可以发现，这个表的前2条记录的前4个字段完全一样。那可不可以通过拆分，把它们变成一条记录呢？当然是可以的，而且为了优化，必须要进行拆分。
具体怎么拆分呢？第二范式就告诉了我们拆分的原则。
第二范式要求，在满足第一范式的基础上，还要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有字段，都必须完全依赖主键，不能只依赖主键的一部分。
根据这个要求，我们可以对表进行重新设计。
重新设计的第一步，就是要确定这个表的主键。通过观察发现，字段“listnumber”+“barcode”可以唯一标识每一条记录，可以作为主键。确定好了主键以后，我们判断一下，哪些字段完全依赖主键，哪些字段只依赖于主键的一部分。同时，把只依赖于主键一部分的字段拆分出去，形成新的数据表。
首先，进货单明细表里面的“goodsname”“specification”“unit”这些信息是商品的属性，只依赖于“barcode”，不完全依赖主键，可以拆分出去。我们把这3个字段加上它们所依赖的字段“barcode”，拆分形成一个新的数据表“商品信息表”。
这样一来，原来的数据表就被拆分成了两个表。
商品信息表：
进货单表：
同样道理，字段“supplierid”“suppliername”“stock”只依赖于“listnumber”，不完全依赖于主键，所以，我们可以把“supplierid”“suppliername”“stock”这3个字段拆出去，再加上它们依赖的字段“listnumber”，就形成了一个新的表“进货单头表”。剩下的字段，会组成新的表，我们叫它“进货单明细表”。
这样一来，原来的数据表就拆分成了3个表。
进货单头表：
进货单明细表：
商品信息表：
到这里，我们就按照第二范式的要求，把原先的一个数据表拆分成了3个数据表。
现在，我们再来分析一下拆分后的3个表，保证这3个表都满足第二范式的要求。
在“商品信息表”中，字段“barcode”是有可能存在重复的，比如，用户门店可能有散装称重商品和自产商品，会存在条码共用的情况。所以，所有的字段都不能唯一标识表里的记录。这个时候，我们必须给这个表加上一个主键，比如说是自增字段“itemnumber”。
现在，我们就可以把进货单明细表里面的字段“barcode”都替换成字段“itemnumber”，这就得到了新的进货单明细表和商品信息表。
进货单明细表：
商品信息表：
这样一来，我们拆分后的3个数据表中的数据都不存在重复，可以唯一标识。而且，表中的其他字段，都完全依赖于表的主键，不存在部分依赖的情况。所以，拆分后的3个数据表就全部满足了第二范式的要求。
第三范式如果你仔细看的话，会发现，我们的进货单头表，还有数据冗余的可能。因为“suppliername”依赖“supplierid”。那么，这个时候，就可以按照第三范式的原则进行拆分了。
第三范式要求数据表在满足第二范式的基础上，不能包含那些可以由非主键字段派生出来的字段，或者说，不能存在依赖于非主键字段的字段。
在刚刚的进货单头表中，字段“suppliername”依赖于非主键字段“supplierid”。因此，这个表不满足第三范式的要求。
那接下来，我们就进一步拆分下进货单头表，把它拆解成供货商表和进货单头表。
供货商表：
进货单头表：
这样一来，供货商表和进货单头表中的所有字段，都完全依赖于主键，不存在任何一个字段依赖于非主键字段的情况了。所以，这2个表就都满足第三范式的要求了。
但是，在进货单明细表中，quantity * importprice = importvalue，“importprice”“quantity”和“importvalue”这3个字段，可以通过任意两个计算出第三个来，这就存在冗余字段。如果严格按照第三范式的要求，现在我们应该进行进一步优化。优化的办法是删除其中一个字段，只保留另外2个，这样就没有冗余数据了。
可是，真的可以这样做吗？要回答这个问题，我们就要先了解下实际工作中的业务优先原则。
业务优先的原则所谓的业务优先原则，就是指一切以业务需求为主，技术服务于业务。完全按照理论的设计不一定就是最优，还要根据实际情况来决定。这里我们就来分析一下不同选择的利与弊。
对于quantity * importprice = importvalue，看起来“importvalue”似乎是冗余字段，但并不会导致数据不一致。可是，如果我们把这个字段取消，是会影响业务的。
因为有的时候，供货商会经常进行一些促销活动，按金额促销，那他们拿来的进货单只有金额，没有价格。而“importprice”反而是通过“importvalue”÷“quantity”计算出来的。因此，如果不保留“importvalue”字段，只有“importprice”和“quantity”的话，经过四舍五入，会产生较大的误差。这样日积月累，最终会导致查询结果出现较大偏差，影响系统的可靠性。
我借助一个例子来说明下为什么会有偏差。
假设进货金额是25.5元，数量是34，那么进货价格就等于25.5÷34=0.74元，但是如果用这个计算出来的进货价格来计算进货金额，那么，进货金额就等于0.74×34=25.16元，其中相差了25.5-25.16=0.34元。代码如下所示：
“importvalue”=25.5元，“quantity”=34，“importprice”=25.5÷34=0.74 “importprice”=0.74元，“quantity”=34，“importvalue”=0.74*34=25.16 误差 = 25.5 - 25.16 = 0.34 现在你知道了，在我们这个场景下，“importvalue”是必须要保留的。
那么，换一种思路，如果我们保留“quantity”和“importvalue”，取消“importprice”，这样不是既能节省存储空间，又不会影响精确度吗？</description></item><item><title>23_ER模型：如何理清数据库设计思路？</title><link>https://artisanbox.github.io/8/23/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/23/</guid><description>你好，我是朱晓峰。
在超市项目的数据库设计阶段，超市经营者交给我们一大堆Excel表格。我们需要把这些表格的数据都整理清楚，并且按照一定的规则存储起来，从而进行高效的管理。
比如，当时我们有这样一张进货表：
为了提高数据存储的效率，我们按照第三范式的原则进行拆分，这样就得到了4个表，分别是供货商表、进货单头表、进货单明细表和商品信息表。
供货商表：
进货单头表：
进货单明细表：
商品信息表：
其中，商品信息表、供货商表和进货单头表都满足第三范式的原则，进货单明细表虽然不满足第三范式的原则，但是满足第二范式的要求，而且保留的冗余字段也是基于业务优先的原则保留的。因此，超市经营者给我们提供的进货单表，经过我们的拆解，已经是存取效率最佳的方案了。在进货管理这个局部模块中，是最优的数据库设计方案。
但是，当我们按照这样的方式拆分一连串数据表时，却发现越拆越多，而且支离破碎。事实上，局部最优的表，不仅有可能存在进一步拆分的情况，还有可能会出现数据缺失。
毕竟，数据库设计是牵一发而动全身的。那有没有什么办法提前看到数据库的全貌呢？比如需要哪些数据表、数据表中应该有哪些字段，数据表与数据表之间有什么关系、通过什么字段进行连接，等等。这样我们才能进行整体的梳理和设计。
其实，ER模型就是一个这样的工具。ER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。在开发基于数据库的信息系统的设计阶段，通常使用ER模型来描述信息需求和信息特性，帮助我们理清业务逻辑，从而设计出优秀的数据库。
今天，我还是借助实际案例，带你使用ER模型分析一下超市的业务流程，具体给你讲一讲怎么通过ER模型来理清数据库设计的思路，从而设计出优秀的数据库。
在使用之前，咱们得先知道ER模型里都包括啥。
ER模型包括哪些要素？在ER模型里面，有三个要素，分别是实体、属性和关系。
实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。比如，这个连锁超市就可以看做一个实体。在ER模型中，用矩形来表示。实体分为两类，分别是强实体和弱实体。强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。 属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用椭圆形来表示。 关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。 需要注意的是，有的时候，实体和属性不容易区分。比如刚刚商品信息表中的商品的单位，到底是实体还是属性呢？如果从进货的角度出发，单位是商品的属性，但是从超市信息系统的整体出发，单位可以看做一个实体。
那么，该如何区分实体和属性呢？
我给你提供一个原则：我们要从系统整体的角度出发去看，可以独立存在的是实体，不可再分的是属性。也就是说，属性不需要进一步描述，不能包含其他属性。
在ER模型的3个要素中，关系又可以分为3种类型，分别是1对1、1对多和多对多。
1对1：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是1对1的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。 1对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如超市与超市里的收款机之间的从属关系，超市可以拥有多台收款机，但是每一条收款机只能从属于一个超市。 多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。 知道了这些要素，我们就可以给超市业务创建ER模型了，如下图所示：
我来简单解释一下这个图。
在这个图中，供货商和超市之间的供货关系，两边的数字都不是1，表示多对多的关系。同样，超市和顾客之间的零售关系，也是多对多的关系。
这个ER模型，包括了3个实体之间的2种关系：
超市从供货商那里采购商品； 超市把商品卖给顾客。 有了这个ER模型，我们就可以从整体上理解超市的业务了。但是，这里没有包含属性，这样就无法体现实体和关系的具体特征。现在，我们需要把属性加上，用椭圆来表示，这样我们得到的ER模型就更加完整了。
ER模型的细化刚刚的ER模型展示了超市业务的框架，但是只包括了供货商、超市和顾客这三个实体，以及它们之间的关系，还不能对应到具体的表，以及表与表之间的关联。
因此，我们需要进一步去设计一下这个ER模型的各个局部，也就是细化下超市的具体业务流程，然后把它们综合到一起，形成一个完整的ER模型。这样可以帮助我们理清数据库的设计思路。
我们刚才的超市业务模型，包括了两个模块，分别是进货模块和销售模块。下面我们分别对这2个模块进行细化。
首先，我们来看一下超市业务中的进货模块的ER模型，整理一下其中包含哪些实体、哪些关系和哪些属性。
在我们的进货模块里，有5个实体：
供货商 商品 门店 仓库 员工 其中，供货商、商品和门店是强实体，因为它们不需要依赖其他任何实体。而仓库和员工是弱实体，因为它们虽然都可以独立存在，但是它们都依赖门店这个实体，因此都是弱实体。
接下来，我们再分析一下各个实体都有哪些属性。
供货商：名称、地址、电话、联系人。 商品：条码、名称、规格、单位、价格。 门店：编号、地址、电话、联系人。 仓库：编号、名称。 员工：工号、姓名、住址、电话、身份证号、职位。 这样细分之后，我们就可以重新设计进货模块了，ER模型如下：
需要注意的是，这里我是用粗框矩形表示弱实体，用粗框菱形，表示弱实体与它依赖的强实体之间的关系。
第二步，我们再分析一下零售模块。
经过分析，我们发现，在超市的业务流程中，零售业务包括普通零售和会员零售两种模式。普通零售包含的实体，包括门店、商品和收银款台；会员零售包含的实体，包括门店、商品、会员和收银款台。
这样我们就可以提炼出零售业务模块中的实体：
商品 门店 会员 收银款台 其中，商品和门店不依赖于任何其他实体，所以是强实体；会员和收银款台都依赖于门店，所以是弱实体。
有了实体之后，我们就可以确定实体的属性了。
商品：条码、名称、规格、单位、价格。 会员：卡号、发卡门店、名称、电话、身份证、地址、积分、储值。 门店：编号、地址、电话、联系人。 收银款台：编号、名称。 现在，我们就可以重新设计零售模块的ER模型了：</description></item><item><title>24_查询有点慢，语句该如何写？</title><link>https://artisanbox.github.io/8/24/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/24/</guid><description>你好，我是朱晓峰。这节课，我想和你聊一聊怎么对查询语句进行调优。
你肯定遇到过这样的情况：你写的SQL语句执行起来特别慢，要等好久才出结果，或者是干脆就“死”在那里，一点反应也没有。一旦遇到这种问题，你就要考虑进行优化了。
如果你开发过数据库应用，肯定会有这样的体会：让应用运行起来不难，但是要运行得又快又好，就没那么不容易了。这很考验我们的内功。
而要想提高应用的运行效率，你就必须掌握优化查询的方法。今天，我就给你讲一下MySQL的查询分析语句和2种优化查询的方法。
查询分析语句虽然MySQL的查询分析语句并不能直接优化查询，但是却可以帮助你了解SQL语句的执行计划，有助于你分析查询效率低下的原因，进而有针对性地进行优化。查询分析语句的语法结构是：
{ EXPLAIN | DESCRIBE | DESC }查询语句; 下面我借助一个小例子，给你详细地讲解一下，怎么使用查询分析语句，来分析一个查询的执行计划。
假设有一个销售流水表（demo.trans），里面有400万条数据，如下所示：
现在，我要查询一下商品编号是1的商品，在2020年6月18日上午9点到12点之间的销售明细。代码如下所示：
mysql&amp;gt; SELECT itemnumber,quantity,price,transdate -&amp;gt; FROM demo.trans -&amp;gt; WHERE itemnumber=1 -&amp;gt; AND transdate&amp;gt;'2020-06-18 09:00:00' -&amp;gt; AND transdate&amp;lt;'2020-06-18 12:00:00'; +------------+----------+-------+---------------------+ | itemnumber | quantity | price | transdate | +------------+----------+-------+---------------------+ | 1 | 0.276 | 70.00 | 2020-06-18 11:04:00 | | 1 | 1.404 | 70.00 | 2020-06-18 11:10:57 | | 1 | 0.554 | 70.00 | 2020-06-18 11:18:12 | | 1 | 0.</description></item><item><title>25_表太大了，如何设计才能提高性能？</title><link>https://artisanbox.github.io/8/25/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/25/</guid><description>你好，我是朱晓峰。
随着数据量的不断增加，表会变得越来越大，查询的速度也会越来越慢。针对这种情况，该怎么处理呢？
咱们上节课学习的优化查询语句是一种方法，不过它并不足以解决所有问题。如果表的设计不合理，会导致数据记录占用不必要的存储空间。
MySQL在存取数据时，并不是一条条去处理的，而是会按照固定大小的页进行处理，如果数据记录占用了不必要的存储空间，就会导致一次读入的有效数据很少。那么，无论怎么改写语句，都无法提升这步操作的效率。这个时候，对表的设计进行优化，就是必不可少的了。
所以，今天，我就给你介绍一下怎么通过优化数据类型、合理增加冗余字段、拆分表和使用非空约束等方法，来改进表的设计，从而提高查询性能。
数据类型优化在改进表的设计时，首先可以考虑优化字段的数据类型。下面我就来讲解2种方法，一种是针对整数类型数据，尽量使用小的整数类型来定义；另外一种是，如果字段既可以用文本类型，也可以用整数类型，尽量使用整数类型。
先说第一种方法，对整数类型数据进行优化。
在第2讲中，我建议你，遇到整数类型的字段可以用INT型。这样做的理由是，INT型数据有足够大的取值范围，不用担心数据超出取值范围的问题。刚开始做项目的时候，首先要保证系统的稳定性，这样设计字段类型是可以的。
但是，随着你的经验越来越丰富，参与的项目越来越大，数据量也越来越多的时候，你就不能只从系统稳定性的角度来思考问题了，还要考虑到系统整体的效率。
这是因为，在数据量很大的时候，数据类型的定义，在很大程度上会影响到系统整体的执行效率。这个时候，你就必须同时考虑稳定性和效率。
第2种优化方法，就是既可以使用文本类型也可以使用整数类型的字段，要使用整数类型，而不要用文本类型。
跟文本类型数据相比，大整数往往占用更少的存储空间，因此，在存取和比对的时候，可以占用更少的内存。所以，遇到既可以使用文本类型，又可以使用整数类型来定义的字段，尽量使用整数类型，这样可以提高查询的效率。
接下来，我就结合超市项目的案例来讲解下具体的优化方法。
在这个项目中，我们有一个400万条记录的流水数据。为了方便你理解，这里我只保留2个字段，分别是商品编号字段itemnumber和流水唯一编号字段transuniqueid。流水唯一编号用于在系统中唯一标识一条流水。
为了对比方便，我创建了2个表demo.test和demo.test1：
在demo.test的表中，我给商品编号设定的数据类型是INT，给流水唯一编号设定的数据类型是TEXT； 在demo.test1中，我给商品编号设定的数据类型是MEDIUMINT，给流水唯一编号设定的数据类型是BIGINT。 这样设定的原因是，MEDIUMINT类型的取值范围是“无符号数0 – 16777215”。对于商品编号来说，其实够用了。我的400万条数据中没有超过这个范围的值。而流水唯一编号是一个长度为18位的数字，用字符串数据类型TEXT肯定是可以的，大整数类型BIGINT的取值范围是“无符号数0 – 18446744083709551616”，有20位，所以，用大整数类型数据来定义流水唯一编号，也是可以的。
创建表demo.test和demo.test1的语句如下所示：
mysql&amp;gt; CREATE TABLE demo.test (itemnumber INT,transuniqueid TEXT); Query OK, 0 rows affected (0.23 sec) mysql&amp;gt; CREATE TABLE demo.test1 (itemnumber MEDIUMINT,transuniqueid BIGINT); Query OK, 0 rows affected (0.25 sec) 然后，我们来对这两个表进行数据导入和查询操作，看看哪个效率更高：
mysql&amp;gt; LOAD DATA INFILE &amp;lsquo;C:\ProgramData\MySQL\MySQL Server 8.0\Uploads\trans.txt&amp;rsquo; INTO TABLE demo.test FIELDS TERMINATED BY &amp;lsquo;,&amp;rsquo; LINES TERMINATED BY &amp;lsquo;\n&amp;rsquo;; Query OK, 4328021 rows affected (3 min 23.</description></item><item><title>26_如何充分利用系统资源？</title><link>https://artisanbox.github.io/8/26/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/26/</guid><description>你好，我是朱晓峰。
内存和CPU都是有限的资源，因此，把它们的作用发挥到极致，对提高应用的承载能力来说至关重要。
磁盘读写需要计算位置、发出读写指令等，这些都要消耗CPU资源，很容易成为提升系统效能的瓶颈。
如果采取“先把数据放在内存，然后集中写入磁盘”的办法，可以节省CPU资源和磁盘读取的时间，但是也会面临系统故障时会丢失数据的风险；相反，如果每次都写入磁盘，数据最安全，但是频繁的磁盘读写，会导致系统效率低下。这就需要我们提升优化资源配置的能力。
今天，我就给你介绍一下优化系统配置的方法，同时还会讲解系统自带的监控工具，从而帮助你合理配置系统资源，精准发现系统资源的瓶颈，进一步提升你处理大并发、大数据的能力。
优化系统资源配置对CPU资源的掌控，关系到系统整体的成败。因为CPU资源是系统最核心的资源，无可替代，而且获取成本高。如果应用无法控制CPU的使用率，就有可能是失败的，不管你的界面多么人性化，功能多么强大。
因此，我们需要管理好系统配置，把资源效率提升到极致。系统参数控制着资源的配置，调整系统参数的值，可以帮助我们提升资源的利用效率。
我来借助一个小例子，给你介绍下怎么通过对系统变量进行调优，来提升系统的整体效率。
我曾参与过一个点餐系统应用的开发，其实就是一个为客户提供点餐服务的应用，类似于美团。商家购买服务，入住平台，开通之后，商家可以在系统中录入自己能够提供的各类餐食品种，客户通过手机App、微信小程序等点餐，商家接到订单以后进行制作，并根据客户需求提供堂食或者送餐服务。
系统中包括订单表（orderlist）、客户信息表（clientlist）和客户储值表（clientdeposit）。
订单表：
客户信息表：
客户储值表：
刚刚上线的时候，系统运行状态良好。但是，随着入住的商家不断增多，使用系统的用户量越来越多，每天的订单数据达到了2万条以上。这个时候，系统开始出现问题，CPU使用率不断飙升。终于，有一天午餐高峰的时候，CPU使用率达到99%，这实际上就意味着，系统的计算资源已经耗尽，再也无法处理任何新的订单了。换句话说，系统已经崩溃了。
这个时候，我们想到了对系统参数进行调整，因为参数的值决定了资源配置的方式和投放的程度。为了解决这个问题，我们一共调整了3个系统参数，分别是InnoDB_flush_log_at_trx_commit、InnoDB_buffer_pool_size、InnoDB_buffer_pool_instances。
接下来，我就给你讲一讲怎么对这三个参数进行调整。
1. 调整系统参数InnoDB_flush_log_at_trx_commit这个参数适用于InnoDB存储引擎。因为刚刚的表用的存储引擎都是InnoDB，因此，这个参数对我们系统的效能就有影响。需要注意的是，如果你用的存储引擎不是InnoDB，调整这个参数对系统性能的提升就没有什么用了。
这个参数存储在MySQL的配置文件my.ini里面，默认的值是1，意思是每次提交事务的时候，都把数据写入日志，并把日志写入磁盘。这样做的好处是数据安全性最佳，不足之处在于每次提交事务，都要进行磁盘写入的操作。在大并发的场景下，过于频繁的磁盘读写会导致CPU资源浪费，系统效率变低。
这个参数的值还有2个可能的选项，分别是0和2。其中，0表示每隔1秒将数据写入日志，并将日志写入磁盘；2表示，每次提交事务的时候都将数据写入日志，但是日志每间隔1秒写入磁盘。
最后，我们把这个参数的值改成了2。这样一来，就不用每次提交事务的时候都启动磁盘读写了，在大并发的场景下，可以改善系统效率，降低CPU使用率。即便出现故障，损失的数据也比较小。0虽然效率更高一些，但是数据安全性方面不如2。
2. 调整系统参数InnoDB_buffer_pool_size这个参数的意思是，InnoDB存储引擎使用缓存来存储索引和数据。这个值越大，可以加载到缓存区的索引和数据量就越多，需要的磁盘读写就越少。
因为我们的MySQL服务器是数据库专属服务器，只用来运行MySQL数据库服务，没有其他应用了，而我们的计算机是64位机，内存也有128G。于是我们把这个参数的值调整为64G。这样一来，磁盘读写次数可以大幅降低，我们就可以充分利用内存，释放出一些CPU的资源。
3. 调整系统参数InnoDB_buffer_pool_instances这个参数的意思是，将InnoDB的缓存区分成几个部分，这样一来，就可以提高系统的并行处理能力，因为可以允许多个进程同时处理不同部分的缓存区。这就好比买电影票，如果大家都挤在一个窗口、一个接一个地进行交易，效率肯定是很慢的。如果一次开很多售票窗口，多笔交易同时进行，那速度就快得多了。
我们把InnoDB_buffer_pool_instances的值修改为64，意思就是把InnoDB的缓存区分成64个分区，这样就可以同时有多个进程进行数据操作，CPU的效率就高多了。
修改好了系统参数的值，我们需要重新保存MySQL的配置文件my.ini，并且重启MySQL数据库服务器。
这里有个坑你要注意：由于my.ini文件是文本格式文件，你完全可以用记事本对文件进行修改操作。但是，如果你只是简单地进行保存，就会发现，MySQL服务器停止之后，再次启动时没有响应，服务器起不来了。其实，这就是文件的码制出了问题。
记事本保存文件默认的码制是UTF-8，但配置文件的码制必须是ANSI才行。所以，当你修改完MySQL的配置文件my.ini之后，保存的时候，记得用ANSI的格式。如下图所示：
经过我们对系统参数的调整，重启MySQL服务器之后，系统效率提高了，CPU资源的使用率下来了，系统得以正常运行。
咱们来小结下。CPU资源是系统的核心资源，获取成本非常高。CPU的特点就是阻塞，只要CPU一开始计算，就意味着等待。遇到CPU资源不足的问题，可以从2个思路去解决：
疏通拥堵路段，消除瓶颈，让等待的时间更短； 开拓新的通道，增加并行处理能力。 刚刚的调优思路，其实就是围绕着这2个点展开的。如果遇到CPU资源不足的问题，我建议你也从这2个角度出发去思考解决办法。
如何利用系统资源来诊断问题？在刚刚的例子中，我提到了解决CPU资源不足需要消除瓶颈。而消除瓶颈的第一步就是要发现它。如何发现呢？幸运的是，MySQL提供了很好的工具：Performance Schema。
这是一种专门用来监控服务器执行情况的存储引擎，它会把监控服务器执行情况的数据记录在系统自带的数据库performance_schema中。我们可以利用监控的数据，对服务器中执行查询的问题进行诊断。
我还是以刚刚的那个点餐系统为例，来解释一下。
当我们调整完系统参数之后，系统恢复了运行。可是随着数据量的不断增大，单日订单量超过20万，我们再次遇到了问题：CPU飙升到99%，系统无法工作了。这个时候，我们就可以利用performance_schema记录的监控数据来发现问题。
我先讲一讲怎么让Performance Schema监控查询执行事件，并且把我们需要的监控数据记录下来。
如何启用系统监控？系统数据库performance_schema中的表setup_instruments和setup_consumers中的数据，是启用监控的关键。
setup_instruments保存的数据，表示哪些对象发生的事件可以被系统捕获（在MySQL中，把这些事件称作信息生产者）。
我们可以通过下面的代码，来查看一下当前MySQL会监控哪些事件的信息：
mysql&amp;gt; SELECT NAME,ENABLED,TIMED -&amp;gt; FROM performance_schema.setup_instruments -&amp;gt; LIMIT 1,10; +---------------------------------------------------------+---------+-------+ | NAME | ENABLED | TIMED | +---------------------------------------------------------+---------+-------+ | wait/synch/mutex/sql/TC_LOG_MMAP::LOCK_tc | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit_queue | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_done | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_flush_queue | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_index | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_log | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_binlog_end_pos | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync | YES | YES | | wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync_queue | YES | YES | +---------------------------------------------------------+---------+-------+ 10 rows in set (0.</description></item><item><title>27_手把手带你设计一个完整的连锁超市信息系统数据库（上）</title><link>https://artisanbox.github.io/8/27/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/27/</guid><description>你好，我是朱晓峰。
从创建第一个MySQL数据库开始到现在，我们已经学完了MySQL的核心操作。最后这两节课，我想带你实际设计一个超市信息系统的数据库。毕竟，设计数据库很考验我们综合运用单个技术点的能力。所以，通过这个项目，我不仅会带你把前面的内容串联起来，而且还会教你设计数据库的通用思路。
为什么选择超市项目呢？一方面呢，超市的场景与我们的日常生活密切相关，你比较容易理解其中的业务逻辑，另一方面，超市的业务又相当复杂，几乎能用到我们学到的所有知识点，利于我们对前面学过的内容进行整合。
今天，我就带你一起，从需求分析开始入手，一直到容灾和备份，完成一个全流程的连锁超市数据库设计。这节课，我会主要给你讲解需求分析、ER模型、分库分表和数据库设计方案。我们做项目，首先要从大处着眼，把握方向，这样才不容易出现大的偏差。下节课，我们再设计具体的细节，比如创建数据表、外键约束，设计灾备方案和备份数据等。
在开始设计之前，咱们得先了解一下项目背景。
随着互联网使用的日益广泛，传统的桌面管理系统的数据不能互通、资源利用率低等弊端越来越明显，显然不能满足用户的需求了。因此，我们需要开发一款基于云服务的连锁超市管理信息系统。具体的要求是：
基于浏览器，无需安装，账号开通即可使用，方便快捷； 数据部署在云端，由运营商负责维护，安全可靠； 用户无需自备服务器，只需租用信息服务，资源利用率高。 知道了具体要求，那该怎么进行设计呢？下面我带你来分析一下。
如何设计数据结构？用户账号开通即可使用，所以必然要设计分层的数据结构；数据要部署在云端，所以必然要使用云。根据这些要求，我们可以设计一个基于云服务的2层数据结构，这个结构的示意图如下所示：
我来解释一下图中展示的内容。
首先，你可以看到，所有的系统资源和服务都部署在云端。
其次，我们来看下数据结构层面，主要有2层。
第一层是商户。每个入驻的商户都有一个组号，所有与这个商户有关的数据，通过这个组号进行识别。 第二层是分支机构。分支机构从属于商户，相同商户的分支机构有相同的组号。分支机构分为几种，包括总部、门店、配送中心等。门店又分为直营店和加盟店。每个分支机构有一个机构编号，同一分支机构的数据，有相同的组号和机构编号。 这样一来，新商户只需要开通账号，分配一个新的组号，就可以使用了。组号用于隔离商户之间的数据，使商户之间互相不影响。
最后，数据由我们统一进行运维，安全性有保障。商户自己不需要采购服务器，只需租用服务，资源的利用率更高。
系统的整体结构设计思路有了，那具体在应用层面如何实现呢？
我先用一张图来展示具体的应用构成：
这个图展示了应用的3个层级。
展现层：包括门店收款机App、移动端的手机App、小程序，以及通过浏览器访问的后台管理部分。 服务层：包括云端的销售模块、库存模块、营运模块、会员模块等。 数据层：MySQL数据库。 门店收款App、移动端的手机App，小程序等与数据库设计无关，我就不多说了。下面我重点介绍一下后台管理部分下面的服务层和数据层的相关内容。
服务层包括了销售、库存、营运、会员等管理模块。下面我就以库存管理中的盘点模块为例，详细介绍一下。因为这个模块比较简单，容易理解。
盘点，简单来说，就是把超市仓库里的商品都数一遍，然后跟电脑里的库存数比对，看看有没有不对的地方。实际数出来的库存数量叫做盘存数量，电脑中的库存数量叫做结存数量，比对的结果叫做盈亏数量。要是盘存数量比结存数量多，叫盘盈，否则叫做盘亏。
盘点操作是超市库存管理模块中的一个重要环节，是掌握实际库存的唯一办法。盘点盈亏数据也是衡量超市管理水平的重要指标。
盘点作业一般都在晚上门店营业结束以后进行。这也很好理解，毕竟，在白天营业的过程中，商品不断被顾客取走，又不断得到补充，库存处于一种变化状态，无法获取准确数据。
下面我来介绍下盘点的步骤。
先生成一张盘点表，把当前系统中的库存数量提取出来，获得结存数量； 把员工实际数出来的库存数据录入盘点表中，获得盘存数量； 计算盈亏数量，公式是“盈亏数量=盘存数量-结存数量”； 数据确认无误后，验收盘点表，并调整当前库存：库存数量=库存数量+盈亏数量。 经过这些操作，系统中的库存数量与实际的库存数量就一致了，盘点盈亏也被记录下来了，体现在日报等报表中，超市经营者可以进行查看，为经营决策提供依据。
介绍完了盘点业务，现在回到数据库设计的主题上来，看看如何把盘点业务用数据表的形式表现出来。
盘点业务都是在门店进行，由员工实际操作，对仓库中的商品进行清点。因此，盘点业务模块中肯定要包含员工、门店、仓库、商品等实体。这个时候，我们就可以使用ER模型这个工具，来理清盘点模块的业务逻辑。
盘点模块的ER模型我先把模型直接展示给你，一会儿我再带你具体分析一下。
首先，我们来分析下模型中的实体和关系。
这个ER模型中包括了5个实体，分别是：
商户 门店 员工 商品 仓库 其中，商户和商品是强实体，门店、仓库和员工是弱实体。
这个ER模型中还包含了5个关系，我们按照1对多和多对多来分下类。
1对多：
商户与门店的从属关系 门店与员工的雇佣关系 门店与仓库的拥有关系 多对多：
仓库与商品的库存关系 仓库、商品和员工参与的盘点关系 接下来，我们再分析一下这5个实体各自的属性。
商户：组号、名称、地址、电话、联系人。 门店：组号、门店编号、名称、地址、电话、类别。 员工：组号、门店编号、工号、名称、身份证、电话、职责。 仓库：组号、门店编号、仓库编号、类别。 商品：组号、条码、名称、规格、单位、价格。 除此之外，还有2个多对多关系的属性。</description></item><item><title>28_手把手带你设计一个完整的连锁超市信息系统数据库（下）</title><link>https://artisanbox.github.io/8/28/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/28/</guid><description>你好，我是朱晓峰。
上节课，我们完成了项目的需求分析和业务流程的梳理，为设计数据库做好了准备工作，接下来我们就可以开始具体的设计了。所以，今天，我就带你来建库建表、创建外键约束、视图、存储过程和触发器，最后制定容灾和备份的策略，从而完成一个完整的连锁超市项目数据库的设计，帮助你提高设计高效可靠的数据库的能力。
首先，我们一起来创建数据库和数据表。
如何创建数据库和数据表？经过上节课的分库分表操作，我们把数据库按照业务模块，拆分成了多个数据库。其中，盘点模块中的数据表分别被拆分到了营运数据库（operation）和库存数据库（inventory）中。
下面我们就按照上节课的分库策略，分别创建营运数据库和库存数据库：
mysql&amp;gt; CREATE DATABASE operation; Query OK, 1 row affected (0.03 sec) mysql&amp;gt; CREATE DATABASE inventory; Query OK, 1 row affected (0.02 sec) 接下来，我们来分别创建下这两个数据库中的表。
商户表、门店表、员工表、商品常用信息表和商品不常用信息表从属于营运数据库，我们先把这5个表创建出来。
商户表（operation.enterprice）：
mysql&amp;gt; CREATE TABLE operation.enterprice -&amp;gt; ( -&amp;gt; groupnumber SMALLINT PRIMARY KEY, &amp;ndash; 组号 -&amp;gt; groupname VARCHAR(100) NOT NULL, &amp;ndash; 名称 -&amp;gt; address TEXT NOT NULL, &amp;ndash; 地址 -&amp;gt; phone VARCHAR(20) NOT NULL, &amp;ndash; 电话 -&amp;gt; contactor VARCHAR(50) NOT NULL &amp;ndash; 联系人 -&amp;gt; ); Query OK, 0 rows affected (0.</description></item><item><title>开篇词_在实战中学习，是解锁MySQL技能的最佳方法</title><link>https://artisanbox.github.io/8/31/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/31/</guid><description>你好，我是朱晓峰。
工作二十多年来，我一直在和MySQL打交道。我曾任摩根大通银行技术部副总裁，带领团队为纽约、东京等分支银行提供数据存储和安全服务。目前，正致力于开发基于MySQL的管理信息系统，率领团队为包括国家开发银行、百度在线、北京西站等大型企业在内的客户提供了信息服务，并获得了11项软件著作权（比如商业数据管理系统、云POS系统等）。
因为具备丰富的MySQL开发经验，从2015年起，我受聘担任数据应用学院客座讲师，开始制作职业技术培训课程。我和团队开发了一个为期2周、30个课时的MySQL入门集训课。我们打破了传统的教学模式，不去讲零碎的知识点，而是借助一个实际项目去讲必备技能，帮助数百名初学者迅速掌握了MySQL的基本操作和核心技能。经过2周的集中培训，有几十位学生顺利进入谷歌、苹果和亚马逊等公司。
多年的项目开发以及培训经历，让我深刻地认识到，熟练使用MySQL，对技术人来说变得越来越重要，是我们拿到心仪Offer的敲门砖。
要知道，MySQL的入门门槛非常低，还具有免费、开放源码等优势，可以满足我们的多样化需求，是目前被广泛使用的数据库之一。
看到这里，你可能会问：“我知道学习MySQL很重要，也花了很多时间去学习，可是学来学去，还是连最简单的实际问题都无法解决，该怎么办呢？”
别着急，接下来我们就来聊聊高效的MySQL学习方法。
为什么学了很多知识，你依然不会用MySQL解决实际问题?很多人刚开始学习MySQL时，都会面临一系列问题。
市面上的MySQL资料这么多，该怎么挑选呢？ 我花了很多时间学习MysQL，但是最后真的遇到问题时，我发现我根本不知道怎么解决。 我会一些基本的操作，但还是很容易踩到坑里。比如，我曾经把字段设置成浮点数，但我不知道它是不精准的，幸亏领导发现了，不然很可能会给项目带来损失。 我储备了不少面试题，为什么一到面试就卡壳呢？ …… 其实，这些问题，本质上都是一个原因导致的：传统的资料都是在讲授一个个零碎的知识点，最多给出一些基础的小练习，让你进行一些简单的训练。所以，很多人花了很多时间去学习，好像懂得了很多东西，但是一遇到真实的项目问题，就会一头雾水，不知道如何用所学的知识去解决实际问题，更没有能力给出完整的解决方案。
我做过项目主管，也长期带团队，深知在工作中，最重要的绝对不是你的知识储备量，而是你解决实际问题的能力。但不幸的是，我见过太多面试时表现优异的人，最终却连试用期都过不了。
说到这里，我特别想和你分享一下我曾面试过的一个应届生的故事。
他是一名计算机专业的研究生，讲起MySQL数据库的相关知识，他说得非常清楚，也很有条理，所以我对他的期望值特别高。但是，等他真正上手做项目时，我才发现，他的知识都停留在理论层面。
举个小例子，一次，我们需要开发一个餐厅的点餐系统，我就请他做数据库设计。没想到他设计出来的订单表，居然没有包含客户编号，这就导致无法通过关联查询获取客户信息。这样的数据库根本不满足业务的需求，自然是不能用的。
这并不是个例，很多人在谈到某些知识时可以出口成章，但是一遇到真实的商业环境，就会毫无头绪，或者是犯这样那样的错误。
在我看来，正确的学习方法，远比你投入的时间更重要。而实战，就是最高效的方法。
为此，我特意选择了一个连锁超市的实战项目，手把手带你从0到1走完项目全流程，不仅帮你掌握核心操作，还能让你真正拥有实战能力，能够迅速上手任何一个项目。无论你是刚刚走入职场，想要迅速解锁MySQL这项技能，还是对它感兴趣，想要转岗到MySQL开发，都可以在这个课程中达到你理想的目标。
之所以选择采用连锁超市的项目，有两个原因。
你对超市这个场景足够熟悉。我们都有去超市购物的经历，会看到货架上摆着玲琅满目的商品，各种各样的促销招牌，还有忙着扫码收银的店员……借助熟悉的场景来讲解，可以最大程度减轻你的理解成本。 超市背后的业务环节非常复杂，产生的数据也多种多样，而MySQL是处理这类业务的利器。当我们完整地解决了超市项目中所遇见的复杂数据问题时，你再去做其他任何业务，就可以更游刃有余一些。 总之，我会从实际问题出发，带你学习技术点，让你能举一反三，快速应用在实战项目中。如果用一个公式去概括，就是：项目的实际需求--&amp;gt;解决问题所需的知识点--&amp;gt;用好这些知识的实战经验。
举个例子，超市的商品非常多，这些商品的名称、数量等，必须要被准确地存储、及时地更新，才能保证正常地售卖。这就是真实需求。要解决这个问题，就要用到MySQL的数据存储功能，我们就要掌握设计数据表、定义字段等知识，确保数据的存储效率最高以及数据的唯一性，同时减少错误。
不只是数据存储，我会带着你解决连锁超市所面临的一系列实际问题，从商品进货到库存查验，再到店面售卖、会员营销，等等。在这个过程中，我会给你讲解MySQL是怎样存储数据的、如何才能高效查询、如何提供经营决策的依据、如何确保数据的可靠性和安全性……
即使你没有数据库的知识基础，也完全不用担心，只要你跟着我的思路，就一定能真正地在短时间内入门MySQL，拥有解决问题的能力。
这门课是怎么设计的？说了这么多，课程的具体设计是怎样的呢？我来介绍一下。
课程总共有四个核心模块。
实践篇：我会从项目最基本的数据存储和操作开始讲起，包括创建数据库、数据表、对表中的数据进行增删改查操作、使用函数、表与表之间的关联操作等，帮你快速掌握最基本的用法。 进阶篇：随着用户管理水平的不断提升，对系统的要求也越来越多，越来越复杂，会用到MySQL的许多高级功能。我会手把手带你实现这些功能，包括把程序存储在服务器上、利用突发事件来调用程序、在不改变存储结构的前提下创建虚拟表以方便查询，等等。 优化篇：项目投入运营以后，随着数据的积累，性能优化的问题逐步凸显。在这个模块呢，我会给你讲一讲数据库的设计规范，还会带你创建数据模型，帮助你来理清设计思路。同时，我还会讲到提升性能的具体方法。 案例篇：在课程的最后，我会手把手带你从0到1设计一个连锁超市的信息系统数据库，把前面讲到的知识点都融入到项目设计中，不仅帮你巩固所学的知识，更教会你如何灵活使用。 除此之外，在课程正式开始之前，我会用图片+音频+视频的形式，带着你安装MySQL及必备的图形化管理工具Workbench。同时，我还特意设置了一个特别放送模块，给你讲解MySQL 8.0的新特性、空间定位的方法，以及大厂的高频面试题，帮你轻松拿下面试。
最后，我还想说，MySQL是一个非常优秀的数据库，里面包含了很多经典的设计思想。虽然现在你不需要掌握得这么深，但是我还是建议你多多体会这些思想，这会让你提前建立起大局观，还可以帮助你从更高的层面去看待所遇见的实际问题。
在这门课程里，我会把我这么多年的经验毫无保留地分享给你，欢迎你来学习这门课，也欢迎你把咱们的课程分享给你的朋友或同事，邀请他们和你一起学习，共同成长。
ul { list-style: none; display: block; list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } li { display: list-item; text-align: -webkit-match-parent; } ._2sjJGcOH_0 { list-style-position: inside; width: 100%; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -ms-flex-direction: row; flex-direction: row; margin-top: 26px; border-bottom: 1px solid rgba(233,233,233,0.</description></item><item><title>期末测试_一套习题，测出你的掌握程度</title><link>https://artisanbox.github.io/8/32/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/32/</guid><description>你好，我是朱晓峰。
咱们课程的核心内容都已经更新完了，在临近告别前，我还给你准备了一份期末测试题，这套测试题共有12道单选题和8道多选题，满分100，核心考点都出自前面讲到的所有重要知识，希望可以帮助你进行一场自测。
另外，我还为你准备了一份结课问卷，希望听一听你对这门课的反馈。只要填写，就有机会获得一个手绘护腕垫或者是价值99元的课程阅码。欢迎你花1分钟时间填写一下，期待你的畅所欲言。
ul { list-style: none; display: block; list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } li { display: list-item; text-align: -webkit-match-parent; } ._2sjJGcOH_0 { list-style-position: inside; width: 100%; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -ms-flex-direction: row; flex-direction: row; margin-top: 26px; border-bottom: 1px solid rgba(233,233,233,0.6); } ._2sjJGcOH_0 ._3FLYR4bF_0 { width: 34px; height: 34px; -ms-flex-negative: 0; flex-shrink: 0; border-radius: 50%; } .</description></item><item><title>特别发送（一）_经典面试题讲解第一弹</title><link>https://artisanbox.github.io/8/33/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/33/</guid><description>你好，我是朱晓峰。
到这里，“实践篇”的内容咱们就学完了。今天，我们来学点儿不一样的——5道经典面试题。这些都是在实际面试中的原题，当然，我没有完全照搬，而是结合咱们课程的具体情况，有针对性地进行了调整。我不仅会给你提供答案，还会和你一起分析，让你能够灵活地吃透这些题目，并能举一反三。
话不多说，我们现在开始。我先带你从一道简单的关于“索引”的面试题入手，索引在面试题里经常出现，来看看这一道你能不能做对。
第一题下面关于索引的描述，正确的是：
建立索引的主要目的是减少冗余数据，使数据表占用更少的空间，并且提高查询的速度 一个表上可以建立一个或者多个索引 组合索引可以有效提高查询的速度，比单字段索引更高效，所以，我们应该创建一个由所有的字段组成的组合索引，这样就可以解决所有问题了 因为索引可以提高查询效率，所以索引建得越多越好 解析：这道题的正确答案是选项2，我们来分析一下其他选项。
选项1说对了一半，索引可以提高查询效率，但是创建索引不能减少冗余数据，而且索引还要占用额外的存储空间，所以选项1不对。 选项3不对的原因有2个。第一，组合索引不一定比单字段索引高效，因为组合索引的字段是有序的，遵循左对齐的原则。如果查询的筛选条件不包含组合索引中最左边的字段，那么组合索引就完全不能用。第二，创建索引也是有成本的，需要占用额外的存储空间。用所有的字段创建组合索引的存储成本比较高，而且利用率比较低，完全用上的可能性几乎不存在，所以很少有人会这样做。而且一旦更改任何一个字段的数据，就必须要改索引，这样操作成本也比较高。 选项4错误，因为索引有成本，很少作为筛选条件的字段，没有必要创建索引。 如果这道题你回答错了，一定要回去复习下第11讲的内容。
第二题假设我们有这样一份学生成绩单，所有同学的成绩都各不相同，请编写一个简单的SQL语句，查询分数排在第三名的同学的成绩：
解析：这道题考查的是我们对查询语句的掌握情况。针对题目中的场景，可以分两步来进行查询。
第一步，按照成绩高低进行排序：
mysql&amp;gt; SELECT * -&amp;gt; FROM demo.test1 -&amp;gt; ORDER BY score DESC; -- DESC表示降序排列 +----+------+-------+ | id | name | score | +----+------+-------+ | 2 | 李四 | 90.00 | | 4 | 赵六 | 88.00 | | 1 | 张三 | 80.00 | | 3 | 王五 | 76.00 | | 5 | 孙七 | 67.</description></item><item><title>特别放送（三）_MySQL8都有哪些新特征？</title><link>https://artisanbox.github.io/8/35/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/35/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊MySQL 8的新特征。
作为应用最广泛的三大关系型数据库之一，MySQL的背后有一个强大的开发团队，使MySQL能够持续迭代和创新，满足不断变化的用户需求。在MySQL 8中，就有很多新特征。
今天，我就给你介绍两个重要的新特征：窗口函数和公用表表达式（Common Table Expressions，简称CTE）。它们可以帮助我们用相对简单的查询语句，实现更加强大的查询功能。
什么是窗口函数？窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。一会儿我会借助一个例子来对比下，在此之前，你要先掌握窗口函数的语法结构。
窗口函数的语法结构是：
函数 OVER（[PARTITION BY 字段]） 或者是：
函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名]） 现在，我借助一个小例子来解释一下窗口函数的用法。
假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：
mysql&amp;gt; SELECT * FROM demo.test1; +----+------+--------+------------+ | id | city | county | salesvalue | +----+------+--------+------------+ | 1 | 北京 | 海淀 | 10.00 | | 2 | 北京 | 朝阳 | 20.00 | | 3 | 上海 | 黄埔 | 30.00 | | 4 | 上海 | 长宁 | 10.</description></item><item><title>特别放送（二）_经典面试题讲解第二弹</title><link>https://artisanbox.github.io/8/34/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/34/</guid><description>你好，我是朱晓峰。
到这里，“进阶篇”的内容咱们就学完了。今天，我给你准备了7道面试题。这些面试题涵盖了这个模块的核心内容，我们一起借助面试题来复习一下。我不仅会给你提供正确答案，还会带你深入分析这些问题，让你真正能够做到举一反三。
好了，话不多说，我们现在开始。
第一题日志文件对数据库的故障恢复至关重要。下面这些关于日志文件的描述，正确的是：
MySQL日志记录的顺序可以与并发操作的执行顺序不一致 为了确保数据库是可恢复的，必须确保先写数据库后写日志 日志文件中检查点的主要作用是提高系统出现故障后恢复的效率 系统故障恢复必须使用日志文件以保证数据库系统重启时能正常恢复，事务故障恢复不一定需要使用日志文件 答案：选项3。
解析：
选项1是错误的。MySQL日志记录的顺序是严格按照操作执行的顺序记录的，不会出现日志记录的顺序与并发操作执行的顺序不一致的情况。
选项2也是错误的。MySQL的日志系统遵循WAL（Write-Ahead Logging）机制，也就是所谓的先写日志，后写数据库的机制。由于记录日志是顺序写入磁盘，而写入数据库的磁盘操作需要对磁头定位，因而写入日志的速度要远比写入数据快。为了提高执行的效率，MySQL执行的是先写日志，日志写入成功之后，就回复客户端操作成功，对数据库的磁盘写入则在之后的某个阶段执行。这样，即便遇到系统故障，由于有了日志记录，就可以通过日志对数据库进行恢复了。WAL机制包括3个规则：
对数据的修改操作必须在写入数据库之前写入到日志文件中； 日志必须严格按序记录，就是说，如果A操作发生在B操作之前，那么在日志中，A操作的记录必须在B操作的记录之前； 事务提交之后，必须在日志写入成功之后，才能回复事务处理成功。 选项3是正确的，检查点的作用是加快数据恢复的效率。当修改数据时，为了提高存取效率，采用的策略是先记录日志，实际的数据修改则发生在内存中，这些数据修改是没有写入数据库的，叫做脏页。MySQL把这些脏页分成小的批次，逐步写入磁盘中。因为如果把所有的脏页都一次性写入磁盘，会导致磁盘写入时间过长，影响到用户SQL操作的执行。检查点的作用就是标记哪些脏页已经写入磁盘。这样，当遇到故障时，MySQL可以从检查点的位置开始，执行日志记录的SQL操作，而不是把整个日志都检查一遍，所以，大大提高了故障恢复的效率。
选项4也是错误的。系统故障恢复必须使用日志文件以保证数据库系统重启时能正常恢复，这个表述是正确的，但后面的表述“事务故障恢复不一定需要使用日志文件”则是错误的。事务故障的恢复也必须要用到日志文件，事务故障恢复需要用到的日志文件有3个，分别是回滚日志、重做日志和二进制日志。
回滚日志：如果事务发生故障，可以借助回滚日志，恢复到故障前的状态，所以回滚日志对事务故障恢复有用。 重做日志：事务中的操作对数据更新进行提交时，会记录到重做日志，对数据的更新则只会发生在内存中，实际的数据更新写入磁盘，则会由后台的其他进程异步执行。如果这个时候事务故障，内存中的数据丢失，就必须要借助重做日志来找回。所以，重做日志对事务故障恢复有用。 二进制日志：在主从服务器架构的模式下，从服务器完全依赖二进制日志同步主服务器的操作，如果事务发生故障，从服务器只能依靠主服务器的二进制日志恢复。 第二题MySQL支持事务处理吗？
参考答案：
这个问题跟数据表用的是什么存储引擎有关。如果用的是Innodb，则支持事务处理；如果用的是MyISAM，则不支持事务处理。
MySQL 8.0 默认的存储引擎是Innodb，Innodb是支持事务处理的。在默认的情况下，MySQL启用AUTOCOMMIT模式，也就是每一个SQL操作都是一个事务操作，如果操作执行没有返回错误，MySQL会提交事务；如果操作返回错误，MySQL会执行事务回滚。
你也可以通过执行“START TRANSACTION”或者“BEGIN”来开始一个事务，这种情况下，就可以在事务处理中包含多个SQL操作语句，一直到“COMMIT”语句提交事务，或者是“ROLLBACK”语句回滚事务，来结束一个事务操作。
MyISAM存储引擎是不支持事务操作的，如果你对一个存储引擎是MyISAM的数据表执行事务操作，不管你是否执行“COMMIT”或者是“ROLLBACK”，都不会影响操作的结果。你可以通过下面的SQL语句来查看表的存储引擎：
mysql&amp;gt; SHOW CREATE TABLE demo.test; +-------+------------------------------------------------------------------------------------------------------------------+ | Table | Create Table | +-------+------------------------------------------------------------------------------------------------------------------+ | test | CREATE TABLE `test` ( `aa` int DEFAULT NULL ) ENGINE=MyISAM DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci | +-------+------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.02 sec) 第三题下面这些关于MySQL视图的描述中，错误的是：</description></item><item><title>特别放送（四）_位置信息：如何进行空间定位？</title><link>https://artisanbox.github.io/8/36/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/36/</guid><description>你好，我是朱晓峰。今天，我来和你聊一聊怎么进行空间定位。
我们每天都会用到空间数据，比如你在网上购买一件商品，你手机上的App就能够算出你是不是需要负担运费，负担多少运费。这其实就是因为手机获取到了你的空间位置信息，发送到网购平台，然后根据你所在的位置是否属于偏远地区，来决定你是否需要负担运费，如果需要的话，应该负担多少。
而从应用开发者的角度出发，我们需要知道怎么进行空间定位，获取用户的空间位置信息，以及如何计算发货点与客户地址的距离，这些都要借助与空间数据相关的技术才能解决。
今天，我还是借助一个真实的项目，来给你介绍下空间数据类型、空间数据处理函数，以及如何为空间数据创建索引，帮助你提升开发基于空间数据应用的能力。
在我们超市项目的实施过程中，超市经营者提出了这样一个要求：要给距离门店5公里范围内的、从线上下单的客户提供送货上门的服务。要想解决这个问题，就需要用到空间数据了。
空间数据类型与空间函数我先给你介绍下空间数据类型和空间函数。
MySQL支持的空间数据类型分为2类：
一类是包含单个值的几何类型（GEOMETRY）、点类型（POINT）、线类型（LINESTRINIG）和多边形类型（POLYGON）； 另一类是包含多个值的多点类型（MULTIPOINT）、多线类型（MULTILINESTRING）、多多边形类型（MULTIPOLYGON）和几何集类型（GEOMETRYCOLLECTION）。 我简单说明一下这几种空间数据类型的特点。
几何类型是一个通用的空间数据类型，你可以把点类型、线类型和多边形类型数据的值赋予几何类型数据。但是点类型、线类型和多边形类型数据则不具备这种通用性，你只能赋予它们各自类型数据的值。
几何集类型数据可以保存点类型数据、线类型数据和多边形类型数据值的集合。多点类型、多线类型和多多边形类型则分别只能保存点类型数据、线类型数据和多边形类型数据值的集合。
下面我们重点介绍一下点类型，因为这种类型是最简单、最基础的空间类型，也最常用。
点类型（POINT）点类型是最简单的空间数据类型，代表了坐标空间中的单个位置。在不同比例尺的坐标空间中，一个点可以有不同的含义。例如，在较大比例尺的世界地图中，一个点可能代表一座城市；而在较小比例尺的城市地图中，一个点可能只代表一个车站。
点类型数据的属性有2种：
坐标空间中的X轴的值（比如地理坐标中的经度值）； 坐标空间中的Y轴的值（比如地理坐标中的纬度值）。 点类型数据的维度是0，边界为空。
空间函数MySQL支持的空间函数有一百多种，我们没有必要全部都掌握。所以，我给你重点介绍几个比较常用的空间函数ST_Distance_Sphere()、MBRContains()、MBRWithin()和ST_GeomFromText()。
1.ST_Distance_Sphere()函数
我们先从计算空间距离的函数ST_Distance_Sphere()说起，这个函数的语法结构和功能如下所示：
ST_Distance_Sphere(g1,g2)：g1与g2为2个点，函数返回球体上2个点g1与g2之间的最小球面距离。 2.MBRContains()和MBRWithin()函数
在学习MBRContains()和MBRWithin()函数之前，我们要先了解一个概念，也就是最小边界矩形（MBR，Minimum Bounding Rectangle ）。
最小边界矩形是指以二维坐标表示的若干二维形状（例如点、直线、多边形）的最大范围，即以给定的二维形状各顶点中的最大横坐标、最小横坐标、最大纵坐标、最小纵坐标决定的边界的矩形。
知道了这个概念，你就能更好地理解这两个函数了。
MBRContains(g1,g2)：如果几何图形g1的最小边界矩形包含了几何图形g2的最小边界矩形，则返回1，否则返回0。 MBRWithin(g1,g2)：与MBRContains(g1,g2)函数正好相反，MBRWithin(g1,g2)表示，如果几何图形g1的最小边界矩形，包含在几何图形g2的最小边界矩形之内，则返回1，否则返回0。 3.ST_GeomFromText()
这个函数的作用是通过WKT形式创建几何图形。而ST_GeomFromText(WKT,SRID)就表示，返回用WKT形式和SRID指定的参照系表达的几何图形。
这里的WKT是一种文本标记语言，用来表示几何对象。SRID（Spatial Reference Identifier）是空间参照标识符，默认是0，表示平面坐标系。我们平时常用的SRID是4326，是目前世界通用的以地球质心为原点的地心坐标系。
知道了这些基础知识，我们就可以着手解决超市经营者提出的需求了。
这家超市有很多门店，该怎么计算是否应该送货上门呢？如果应该送货上门，应该从哪家门店送货呢？我带你分析下具体的思路。
第一步，把门店的位置信息录入数据表中； 第二步，根据下单客户的送货地址，获取到地理位置信息； 第三步，计算各门店位置与送货地址的距离，找出最近的门店安排送货，如果没有一家门店与客户的距离在5公里以内，则提示不能送货。 下面我们就来实际操作一下。
首先，我们创建一个门店表（demo.mybranch），包含门店编号、名称、位置等信息。
mysql&amp;gt; CREATE TABLE demo.mybranch -&amp;gt; ( -&amp;gt; branchid SMALLINT PRIMARY KEY, -&amp;gt; branchname VARCHAR(50) NOT NULL, -&amp;gt; address GEOMETRY NOT NULL SRID 4326 -&amp;gt; ); Query OK, 0 rows affected (0.</description></item><item><title>环境准备_带你安装MySQL和图形化管理工具Workbench</title><link>https://artisanbox.github.io/8/29/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/29/</guid><description>你好，我是朱晓峰。这节课，我来手把手带你安装和配置MySQL。
俗话说，“巧妇难为无米之炊”，我们不能凭空学习理论知识，必须要在实际的MySQL环境中进行操作，这是一切操作的基础。同时，我还会带你安装MySQL自带的图形化管理工具Workbench，我们之后要学习的表的关联、聚合、事务，以及存储过程等，都会用到它。
我会借助图文和音频给你介绍知识重点和操作要领，同时，我还录制了相应的视频，来展示具体的操作细节。你可以根据自己的习惯和需求，选择喜欢的形式来学习。
好了，话不多说，我们先来安装MySQL。
安装与配置首先，我们要下载MySQL的安装包，具体做法是，打开浏览器，输入网址：https://dev.mysql.com，进入MySQL的开发者专区进行下载。
在下载界面，你会看到需要选择操作系统。这是因为，MySQL可以在多种操作系统平台上运行，包括Windows、Linux、macOS等，因此，MySQL准备了针对不同操作系统平台的安装程序。这里我们主要介绍MySQL在Windows操作系统上的安装。因为Windows平台应用得最广泛，而且图形化操作也比较简单。
当然，如果你想了解Linux平台和macOS平台上的安装和配置，也可以通过官网https://dev.mysql.com/doc/refman/8.0/en/linux-installation.html 和https://dev.mysql.com/doc/refman/8.0/en/osx-installation.html 来进行查看。不同平台上的MySQL会略有不同，比如，同样的机器配置，Linux上的MySQL运行速度就比Windows快一些，不过它们支持的功能和SQL语法都是一样的，即使你使用的是其他系统，也不会影响到我们的学习。
好了，下载完成之后，我们就可以开始安装了。接下来我给你介绍下安装步骤。
第一步：点击运行下载的安装程序，安装MySQL数据库服务器及相关组件
我给你介绍下这些关键组件的作用。
MySQL Server：是MySQL数据库服务器，这是MySQL的核心组件。 MySQL Workbench：是一个管理MySQL的图形工具，一会儿我还会带你安装它。 MySQL Shell：是一个命令行工具。除了支持SQL语句，它还支持JavaScript和Python脚本，并且支持调用MySQL API接口。 MySQL Router：是一个轻量级的插件，可以在应用和数据库服务器之间，起到路由和负载均衡的作用。听起来有点复杂，我们来想象一个场景：假设你有多个MySQL数据库服务器，而前端的应用同时产生了很多数据库访问请求，这时，MySQL Router就可以对这些请求进行调度，把访问均衡地分配给每个数据库服务器，而不是集中在一个或几个数据库服务器上。 Connector/ODBC：是MySQL数据库的ODBC驱动程序。ODBC是微软的一套数据库连接标准，微软的产品（比如Excel）就可以通过ODBC驱动与MySQL数据库连接。 其他的组件，主要用来支持各种开发环境与MySQL的连接，还有MySQL帮助文档和示例。你一看就明白了，我就不多说了。
好了，知道这些作用，下面我们来点击“Execute”，运行安装程序，把这些组件安装到电脑上。
第二步：配置服务器
等所有组件安装完成之后，安装程序会提示配置服务器的类型（Config Type）、连接（Connectivity）以及高级选项（Advanced Configuration）等，如下图所示。这里我重点讲一下配置方法。
我们主要有2个部分需要配置，分别是服务器类别和服务器连接。
先说服务器类别配置。我们有3个选项，分别是开发计算机（Development Computer）、服务器计算机（Sever Computer）和专属计算机（Dedicated Computer）。它们的区别在于，MySQL数据库服务器会占用多大的内存。
如果选择开发计算机，MySQL数据库服务会占用所需最小的内存，以便其他应用可以正常运行。 服务器计算机是假设在这台计算机上有多个MySQL数据库服务器实例在运行，因此会占用中等程度的内存。 专属计算机则会占用计算机的全部内存资源。 这里我们选择配置成“开发计算机”，因为我们安装MySQL是为了学习它，因此，只需要MySQL占有运行所必需的最小资源就可以了。如果你要把它作为项目中的数据库服务器使用，就应该配置成服务器计算机或者专属计算机。
再来说说MySQL数据库的连接方式配置。我们也有3个选项：网络通讯协议（TCP/IP）、命名管道（Named Pipe）和共享内存（Shared Memory）。命名管道和共享内存的优势是速度很快，但是，它们都有一个局限，那就是只能从本机访问MySQL数据库服务器。所以，这里我们选择默认的网络通讯协议方式，这样的话，MySQL数据库服务就可以通过网络进行访问了。
MySQL默认的TCP/IP协议访问端口是3306，后面的X协议端口默认是33060，这里我们都不做修改。MySQL的X插件会用到X协议，主要是用来实现类似MongoDB 的文件存储服务。这方面的知识，我会在课程后面具体讲解，这里就不多说了。
高级配置（Show Advanced）和日志配置（Logging Options），在咱们的课程中用不到，这里不用勾选，系统会按照默认值进行配置。
第三步：身份验证配置
关于MySQL的身份验证的方式，我们选择系统推荐的基于SHA256的新加密算法caching_sha2_password。因为跟老版本的加密算法相比，新的加密算法具有相同的密码也不会生成相同的加密结果的特点，因此更加安全。
第四步：设置密码和用户权限
接着，我们要设置Root用户的密码。Root是MySQL的超级用户，拥有MySQL数据库访问的最高权限。这个密码很重要，我们之后会经常用到，你一定要牢记。
第五步：配置Windows服务
最后，我们要把MySQL服务器配置成Windows服务。Windows服务的好处在于，可以让MySQL数据库服务器一直在Windows环境中运行。而且，我们可以让MySQL数据库服务器随着Windows系统的启动而自动启动。
图形化管理工具Workbench安装完成之后，我再给你介绍一下MySQL自带的图形化管理工具Workbench。同时，我还会用Workbench的数据导入功能，带你导入一个Excel数据文件，创建出我们的第一个数据库和数据表。
首先，我们点击Windows左下角的“开始”按钮，如果你是Win10系统，可以直接看到所有程序，如果你是Win7系统，需要找到“所有程序”按钮，点击它就可以看到所有程序了。
接着，找到“MySQL”，点开，找到“MySQL Workbench 8.0 CE”。点击打开Workbench，如下图所示：
左下角有个本地连接，点击，录入Root的密码，登录本地MySQL数据库服务器，如下图所示：
这是一个图形化的界面，我来给你介绍下这个界面。
上方是菜单。左上方是导航栏，这里我们可以看到MySQL数据库服务器里面的数据库，包括数据表、视图、存储过程和函数；左下方是信息栏，可以显示上方选中的数据库、数据表等对象的信息。 中间上方是工作区，你可以在这里写SQL语句，点击上方菜单栏左边的第三个运行按钮，就可以执行工作区的SQL语句了。 中间下方是输出区，用来显示SQL语句的运行情况，包括什么时间开始运行的、运行的内容、运行的输出，以及所花费的时长等信息。 好了，下面我们就用Workbench实际创建一个数据库，并且导入一个Excel数据文件，来生成一个数据表。数据表是存储数据的载体，有了数据表以后，我们就能对数据进行操作了。
创建数据表第一步：录入Excel数据</description></item><item><title>结束语_不盲从于群体思维，走一条适合自己的路</title><link>https://artisanbox.github.io/8/30/</link><pubDate>Tue, 08 Mar 2022 18:37:53 +0800</pubDate><guid>https://artisanbox.github.io/8/30/</guid><description>你好，我是朱晓峰。
到这里，咱们的课程就全部结束了。不过，课程结束更新，并不意味着MySQL的学习结束了。相反，也许对于你来说，这是一个新的开始。
我一直强调，在真实项目中进行学习，是掌握MySQL的最好方法。所以，在课程结束以后，你一定要把学到的内容真正应用到实际工作中，反复实践，这样才能真正成为优秀的数据库开发人员。
那在今天这篇结束语里呢，我想暂且抛开MySQL，和你分享一个我的人生准则：不盲从于群体思维，按自己的意愿和个人的特质去做选择，走一条适合自己的路。
为什么在这告别之际，我最想给你分享这一点呢？
因为我们每个人都生活在群体之中，每天都在和不同的人打交道，尤其是现在信息极度丰富，每天都有人在表达着自己的观点，试图成为“意见领袖”，一不小心，别人的想法就会左右我们的行为。
但每个个体都是与众不同的，有的人擅长把细节做到极致，有的人擅长把控全局；有的人对数字特别敏感，有的人长于艺术想象……无论是学习技术，还是选择职业路径，只有适合自己的，才是我们成为人生赢家的捷径。
说到这儿，我想和你分享一个我的真实经历。
大学毕业以后，我进入一家外企工作，从普通程序员做起，一直做到构架师。工作很稳定，待遇也好，家人觉得很不错，希望我买套房子，赶紧结婚生子。
可是，我对这样的生活一点也不满意。因为我发现，在熟悉了工作内容之后，日常的一切对我已经没有什么挑战了，每天不过是重复熟悉的流程，感觉一年跟一天没有什么差别。这样的人生，不是我想要的。
我决定辞职，去美国留学，这件事情花光了我多年的积蓄。当时，很多人都在质疑我，觉得我是放弃了光明的前途，走向了未知的恐怖。但是，未知并不意味着恐怖，甚至可能是出乎预料的精彩。
事实证明，那段经历彻底改变了我。我学到了崭新的知识和不同的思维方式，也正因此，我又有机会进入到世界顶级的企业工作，成为了摩根大通银行东京分行副总裁，保证了一系列重大项目的落地和实施。
试想一下，假使我当时听从别人的劝导，选择过安安稳稳的日子，现在可能还在公司里面打工，计算着还有多少年可以退休。而现在的我，在开拓职业新赛道，同时也有机会写下这门课。
其实，人类的一个特点就是很容易接受暗示，尤其是在你犹豫不决的时候，往往一个简单暗示，就会影响你的决定。所以，你一定要慎重对待群体建议，在做每一个重要的决定前，都要先想想这个决定是为自己而做，还是为迎合群体而做。
你可能会说，我知道不要盲从群体思维，但是怎么按照自己的意愿去生活呢？接下来，我就结合我的人生经历，给你分享3条建议。
首先，你要制定长期规划，形成自己的一个稳定的内在架构。
有句话叫做：“谋定而后动，知止而有得。”如果做什么都没有规划，凡事跟着感觉走，是很难有作为的。而所谓的长期规划，我认为可以容纳进一套架构里。实际上，不只企业有架构，我们每个人都要形成自己的一个架构。
什么意思呢？我给你举个简单的小例子，你一听就明白了。
记得在银行工作的时候，有一次跟我们部门的一位传奇的交易员聊天，他每年为公司创造的利润超过你的想象。我问他怎么知道一笔交易能够盈利呢，他的回答出乎我的意料，他说：“我不知道这笔交易能不能赢，但是我的计算模型告诉我，我赢的可能性大于输的可能性。我一直这样做，只要交易足够多，我就不可能输。”
你看，我们眼中的一笔笔独立的交易，都是他长线规划中的一环。他实际上是预先做了计算的，一切都是按照计划进行的。虽然他不知道下一笔交易能不能赢，但按照计划行事，赢的可能性就比较大，只要时间足够长，交易量足够多，那么在最终的结果里，他肯定是赢家。
所以，要想走在自己期待的道路上，就要把视角放在更广阔的空间维度和更长久的时间维度上，建立起自己的一套架构，并不断用经验和经历去修正它，让它尽可能稳固，这样你才能在做决定时，有个指导，至少不会让你跑偏。
其次，对待任何结果，不过多计较一时的得失。
正确的决定，并不一定会带来好的结果；错误的决定，也可能会侥幸成功，重要的是客观地分析造成这个结果的原因，而不是简单地以结果的好坏，来判断决定的正确性。
我还是想分享一个我经历过的一件事。
记得云服务器刚开始流行起来的时候，因为我们觉得云服务器比自己搭建服务器，在可靠性、资源利用率和成本等方面都很有优势，于是，我们就给客户推荐了大厂的云服务器。可是，没想到大厂也有失手的时候，整个地区全部宕机，所有的客户都没法访问云服务器了。
这个时候，如果是你，你会怎么做呢？放弃云服务器，重新回归本地服务器，肯定会防止类似的事件再次发生，但问题是，这样的选择真的是正确的吗？
当时，云服务器确实比较新，大厂也可能会失手，但是，一次失败并不意味着云服务器就不能用了。从长远来说，云服务器比本地服务器的优势多太多了，大厂的技术也在不断成熟，给客户推荐云服务器肯定仍然是正确的选择。
实际上，任何事情都有成功和失败的概率。正确的选择是成功概率大的那个方案，不要因为一次偶然的失败，就轻易改变我们的选择。
总之，一定要学会不简单地以结果来评判对错，不妨问问自己，当初决定这样做的理由是什么？为什么会导致这个结果？是必然的呢？还是偶然因素造成的？哪个方案成功的概率最大？等等，在回答这些问题的过程中理清思路，努力做出全面客观的判断。
最后，正确的要坚持，但如果发现错了，果断放弃非常重要。
几乎所有人都在强调，做事要坚持不懈，这当然是非常重要的，毕竟不能忽视时间的力量。但是，如果你已经意识到方向错了，就一定要果断放弃。
我曾经非常迷信某大厂的软件开发生态，觉得它们能够提供全套的开发环境，稳定性好，特别人性化。自以为站在巨人的肩膀上，就可以借到力了。可是有一次，我们给客户定制的软件在客户的机器上无法启动，由于大厂的开发环境都是封闭的，我们无法了解内部到底发生了什么。这样一来，问题就一直得不到解决。最后，我们不得不回到几个月前的版本，重新编写相应的模块。
这件事使我意识到，要开发出真正满足客户需求的软件，必须要了解底层，开源的开发环境，才是最佳的选择。因为开源软件可以通过阅读源代码，了解所有的技术细节。
这个时候，我意识到，如果明知现在的方向不对，还要一直走下去，虽然比较省力，但是很多项目就不能做了，那样就会把路越走越窄。
最后，我们果断放弃了某大厂的软件，逐步切换到开源体系。刚开始的时候，因为要熟悉新的操作系统、新的编程语言、新的数据库软件，要学的东西太多，每一步都十分痛苦，很多人离开了。
但是，随着对开源体系越来越熟悉，发现原来的项目可以做，甚至很多原来不能做的项目也可以做了，这样一来，路就越走越宽了。
放弃正在走的错误的道路就意味着改变，而人十分容易产生惰性，一旦适应了现在的环境，就不愿意改变，这样就很容易忽视正确的东西。微小积累会引发持续改变这件事，不仅会在正确的地方得到验证，更会在错误的道路上体现得淋漓尽致。因此，在错误处调头，虽难，但意义重大。
好了，这些就是我在这几十年中，踩过无数坑、走了无数弯路后提炼出来的生活准则，很高兴有机会分享给你，但愿对你有所帮助。希望你不仅成为一个具有很强技术能力的人，同时还能真正走出一条适合自己的路，成为人生赢家。
课程的最后，我准备了一份调研问卷，希望你能花1分钟填写下，聊聊你对这门课的想法。同时，我也给你准备了礼物，只要填写问卷，就有机会获得一个手绘护腕垫或者是价值99元的课程阅码。期待你的畅所欲言。
ul { list-style: none; display: block; list-style-type: disc; margin-block-start: 1em; margin-block-end: 1em; margin-inline-start: 0px; margin-inline-end: 0px; padding-inline-start: 40px; } li { display: list-item; text-align: -webkit-match-parent; } ._2sjJGcOH_0 { list-style-position: inside; width: 100%; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -ms-flex-direction: row; flex-direction: row; margin-top: 26px; border-bottom: 1px solid rgba(233,233,233,0.</description></item></channel></rss>